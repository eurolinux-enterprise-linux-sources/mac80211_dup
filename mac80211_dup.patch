--- a/net/mac80211/aes_cmac.c	2015-06-23 11:07:42.823850654 +0200
+++ b/net/mac80211/aes_cmac.c	2015-06-23 14:54:14.854846463 +0200
@@ -128,7 +128,7 @@ void ieee80211_aes_cmac_key_free(struct
 	crypto_free_cipher(tfm);
 }
 
-void ieee80211_aes_cmac_calculate_k1_k2(struct ieee80211_key_conf *keyconf,
+void ieee80211_aes_cmac_calculate_k1_k2_dup(struct ieee80211_key_conf *keyconf,
 					u8 *k1, u8 *k2)
 {
 	u8 l[AES_BLOCK_SIZE] = {};
@@ -143,4 +143,4 @@ void ieee80211_aes_cmac_calculate_k1_k2(
 	memcpy(k2, k1, AES_BLOCK_SIZE);
 	gf_mulx(k2);
 }
-EXPORT_SYMBOL(ieee80211_aes_cmac_calculate_k1_k2);
+EXPORT_SYMBOL(ieee80211_aes_cmac_calculate_k1_k2_dup);
--- a/net/mac80211/agg-rx.c	2015-06-23 11:07:42.823850654 +0200
+++ b/net/mac80211/agg-rx.c	2015-06-23 14:54:14.927846791 +0200
@@ -56,7 +56,7 @@ static void ieee80211_free_tid_rx(struct
 	kfree(tid_rx);
 }
 
-void ___ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
+void ___ieee80211_stop_rx_ba_session_dup(struct sta_info *sta, u16 tid,
 				     u16 initiator, u16 reason, bool tx)
 {
 	struct ieee80211_local *local = sta->local;
@@ -100,15 +100,15 @@ void ___ieee80211_stop_rx_ba_session(str
 	call_rcu(&tid_rx->rcu_head, ieee80211_free_tid_rx);
 }
 
-void __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
+void __ieee80211_stop_rx_ba_session_dup(struct sta_info *sta, u16 tid,
 				    u16 initiator, u16 reason, bool tx)
 {
 	mutex_lock(&sta->ampdu_mlme.mtx);
-	___ieee80211_stop_rx_ba_session(sta, tid, initiator, reason, tx);
+	___ieee80211_stop_rx_ba_session_dup(sta, tid, initiator, reason, tx);
 	mutex_unlock(&sta->ampdu_mlme.mtx);
 }
 
-void ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
+void ieee80211_stop_rx_ba_session_dup(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
 				  const u8 *addr)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
@@ -126,10 +126,10 @@ void ieee80211_stop_rx_ba_session(struct
 		if (ba_rx_bitmap & BIT(i))
 			set_bit(i, sta->ampdu_mlme.tid_rx_stop_requested);
 
-	ieee80211_queue_work(&sta->local->hw, &sta->ampdu_mlme.work);
+	ieee80211_queue_work_dup(&sta->local->hw, &sta->ampdu_mlme.work);
 	rcu_read_unlock();
 }
-EXPORT_SYMBOL(ieee80211_stop_rx_ba_session);
+EXPORT_SYMBOL(ieee80211_stop_rx_ba_session_dup);
 
 /*
  * After accepting the AddBA Request we activated a timer,
@@ -167,7 +167,7 @@ static void sta_rx_agg_session_timer_exp
 	       sta->sta.addr, (u16)*ptid);
 
 	set_bit(*ptid, sta->ampdu_mlme.tid_rx_timer_expired);
-	ieee80211_queue_work(&sta->local->hw, &sta->ampdu_mlme.work);
+	ieee80211_queue_work_dup(&sta->local->hw, &sta->ampdu_mlme.work);
 }
 
 static void sta_rx_agg_reorder_timer_expired(unsigned long data)
@@ -275,7 +275,7 @@ void __ieee80211_start_rx_ba_session(str
 				   sta->sta.addr, tid);
 
 		/* delete existing Rx BA session on the same tid */
-		___ieee80211_stop_rx_ba_session(sta, tid, WLAN_BACK_RECIPIENT,
+		___ieee80211_stop_rx_ba_session_dup(sta, tid, WLAN_BACK_RECIPIENT,
 						WLAN_STATUS_UNSPECIFIED_QOS,
 						false);
 	}
@@ -375,7 +375,7 @@ void ieee80211_process_addba_request(str
 					buf_size, true, false);
 }
 
-void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,
+void ieee80211_start_rx_ba_session_offl_dup(struct ieee80211_vif *vif,
 					const u8 *addr, u16 tid)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
@@ -392,11 +392,11 @@ void ieee80211_start_rx_ba_session_offl(
 
 	skb->pkt_type = IEEE80211_SDATA_QUEUE_RX_AGG_START;
 	skb_queue_tail(&sdata->skb_queue, skb);
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 }
-EXPORT_SYMBOL(ieee80211_start_rx_ba_session_offl);
+EXPORT_SYMBOL(ieee80211_start_rx_ba_session_offl_dup);
 
-void ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif,
+void ieee80211_stop_rx_ba_session_offl_dup(struct ieee80211_vif *vif,
 				       const u8 *addr, u16 tid)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
@@ -413,6 +413,6 @@ void ieee80211_stop_rx_ba_session_offl(s
 
 	skb->pkt_type = IEEE80211_SDATA_QUEUE_RX_AGG_STOP;
 	skb_queue_tail(&sdata->skb_queue, skb);
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 }
-EXPORT_SYMBOL(ieee80211_stop_rx_ba_session_offl);
+EXPORT_SYMBOL(ieee80211_stop_rx_ba_session_offl_dup);
--- a/net/mac80211/agg-tx.c	2015-06-23 11:07:42.823850654 +0200
+++ b/net/mac80211/agg-tx.c	2015-06-23 14:54:14.992847083 +0200
@@ -32,12 +32,12 @@
  *
  * When TX aggregation is started by some subsystem (usually the rate
  * control algorithm would be appropriate) by calling the
- * ieee80211_start_tx_ba_session() function, the driver will be
+ * ieee80211_start_tx_ba_session_dup() function, the driver will be
  * notified via its @ampdu_action function, with the
  * %IEEE80211_AMPDU_TX_START action.
  *
  * In response to that, the driver is later required to call the
- * ieee80211_start_tx_ba_cb_irqsafe() function, which will really
+ * ieee80211_start_tx_ba_cb_irqsafe_dup() function, which will really
  * start the aggregation session after the peer has also responded.
  * If the peer responds negatively, the session will be stopped
  * again right away. Note that it is possible for the aggregation
@@ -51,10 +51,10 @@
  * @ampdu_action callback.
  *
  * Similarly, when the aggregation session is stopped by the peer
- * or something calling ieee80211_stop_tx_ba_session(), the driver's
+ * or something calling ieee80211_stop_tx_ba_session_dup(), the driver's
  * @ampdu_action function will be called with the action
  * %IEEE80211_AMPDU_TX_STOP. In this case, the call must not fail,
- * and the driver must later call ieee80211_stop_tx_ba_cb_irqsafe().
+ * and the driver must later call ieee80211_stop_tx_ba_cb_irqsafe_dup().
  * Note that the sta can get destroyed before the BA tear down is
  * complete.
  */
@@ -110,7 +110,7 @@ static void ieee80211_send_addba_request
 	ieee80211_tx_skb(sdata, skb);
 }
 
-void ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn)
+void ieee80211_send_bar_dup(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct ieee80211_local *local = sdata->local;
@@ -139,7 +139,7 @@ void ieee80211_send_bar(struct ieee80211
 					IEEE80211_TX_CTL_REQ_TX_STATUS;
 	ieee80211_tx_skb_tid(sdata, skb, tid);
 }
-EXPORT_SYMBOL(ieee80211_send_bar);
+EXPORT_SYMBOL(ieee80211_send_bar_dup);
 
 void ieee80211_assign_tid_tx(struct sta_info *sta, int tid,
 			     struct tid_ampdu_tx *tid_tx)
@@ -251,7 +251,7 @@ static void ieee80211_remove_tid_tx(stru
 	kfree_rcu(tid_tx, rcu_head);
 }
 
-int ___ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
+int ___ieee80211_stop_tx_ba_session_dup(struct sta_info *sta, u16 tid,
 				    enum ieee80211_agg_stop_reason reason)
 {
 	struct ieee80211_local *local = sta->local;
@@ -397,7 +397,7 @@ static void sta_addba_resp_timer_expired
 	ht_dbg(sta->sdata, "addBA response timer expired on %pM tid %d\n",
 	       sta->sta.addr, tid);
 
-	ieee80211_stop_tx_ba_session(&sta->sta, tid);
+	ieee80211_stop_tx_ba_session_dup(&sta->sta, tid);
 	rcu_read_unlock();
 }
 
@@ -497,10 +497,10 @@ static void sta_tx_agg_session_timer_exp
 	ht_dbg(sta->sdata, "tx session timer expired on %pM tid %d\n",
 	       sta->sta.addr, (u16)*ptid);
 
-	ieee80211_stop_tx_ba_session(&sta->sta, *ptid);
+	ieee80211_stop_tx_ba_session_dup(&sta->sta, *ptid);
 }
 
-int ieee80211_start_tx_ba_session(struct ieee80211_sta *pubsta, u16 tid,
+int ieee80211_start_tx_ba_session_dup(struct ieee80211_sta *pubsta, u16 tid,
 				  u16 timeout)
 {
 	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
@@ -625,14 +625,14 @@ int ieee80211_start_tx_ba_session(struct
 	 */
 	sta->ampdu_mlme.tid_start_tx[tid] = tid_tx;
 
-	ieee80211_queue_work(&local->hw, &sta->ampdu_mlme.work);
+	ieee80211_queue_work_dup(&local->hw, &sta->ampdu_mlme.work);
 
 	/* this flow continues off the work */
  err_unlock_sta:
 	spin_unlock_bh(&sta->lock);
 	return ret;
 }
-EXPORT_SYMBOL(ieee80211_start_tx_ba_session);
+EXPORT_SYMBOL(ieee80211_start_tx_ba_session_dup);
 
 static void ieee80211_agg_tx_operational(struct ieee80211_local *local,
 					 struct sta_info *sta, u16 tid)
@@ -710,7 +710,7 @@ void ieee80211_start_tx_ba_cb(struct iee
 	mutex_unlock(&local->sta_mtx);
 }
 
-void ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif,
+void ieee80211_start_tx_ba_cb_irqsafe_dup(struct ieee80211_vif *vif,
 				      const u8 *ra, u16 tid)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
@@ -727,25 +727,25 @@ void ieee80211_start_tx_ba_cb_irqsafe(st
 
 	skb->pkt_type = IEEE80211_SDATA_QUEUE_AGG_START;
 	skb_queue_tail(&sdata->skb_queue, skb);
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 }
-EXPORT_SYMBOL(ieee80211_start_tx_ba_cb_irqsafe);
+EXPORT_SYMBOL(ieee80211_start_tx_ba_cb_irqsafe_dup);
 
-int __ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
+int __ieee80211_stop_tx_ba_session_dup(struct sta_info *sta, u16 tid,
 				   enum ieee80211_agg_stop_reason reason)
 {
 	int ret;
 
 	mutex_lock(&sta->ampdu_mlme.mtx);
 
-	ret = ___ieee80211_stop_tx_ba_session(sta, tid, reason);
+	ret = ___ieee80211_stop_tx_ba_session_dup(sta, tid, reason);
 
 	mutex_unlock(&sta->ampdu_mlme.mtx);
 
 	return ret;
 }
 
-int ieee80211_stop_tx_ba_session(struct ieee80211_sta *pubsta, u16 tid)
+int ieee80211_stop_tx_ba_session_dup(struct ieee80211_sta *pubsta, u16 tid)
 {
 	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
 	struct ieee80211_sub_if_data *sdata = sta->sdata;
@@ -779,13 +779,13 @@ int ieee80211_stop_tx_ba_session(struct
 	}
 
 	set_bit(HT_AGG_STATE_WANT_STOP, &tid_tx->state);
-	ieee80211_queue_work(&local->hw, &sta->ampdu_mlme.work);
+	ieee80211_queue_work_dup(&local->hw, &sta->ampdu_mlme.work);
 
  unlock:
 	spin_unlock_bh(&sta->lock);
 	return ret;
 }
-EXPORT_SYMBOL(ieee80211_stop_tx_ba_session);
+EXPORT_SYMBOL(ieee80211_stop_tx_ba_session_dup);
 
 void ieee80211_stop_tx_ba_cb(struct ieee80211_vif *vif, u8 *ra, u8 tid)
 {
@@ -836,7 +836,7 @@ void ieee80211_stop_tx_ba_cb(struct ieee
 	mutex_unlock(&local->sta_mtx);
 }
 
-void ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif,
+void ieee80211_stop_tx_ba_cb_irqsafe_dup(struct ieee80211_vif *vif,
 				     const u8 *ra, u16 tid)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
@@ -853,9 +853,9 @@ void ieee80211_stop_tx_ba_cb_irqsafe(str
 
 	skb->pkt_type = IEEE80211_SDATA_QUEUE_AGG_STOP;
 	skb_queue_tail(&sdata->skb_queue, skb);
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 }
-EXPORT_SYMBOL(ieee80211_stop_tx_ba_cb_irqsafe);
+EXPORT_SYMBOL(ieee80211_stop_tx_ba_cb_irqsafe_dup);
 
 
 void ieee80211_process_addba_resp(struct ieee80211_local *local,
@@ -929,7 +929,7 @@ void ieee80211_process_addba_resp(struct
 		}
 
 	} else {
-		___ieee80211_stop_tx_ba_session(sta, tid, AGG_STOP_DECLINED);
+		___ieee80211_stop_tx_ba_session_dup(sta, tid, AGG_STOP_DECLINED);
 	}
 
  out:
--- a/net/mac80211/cfg.c	2015-06-23 11:07:42.823850654 +0200
+++ b/net/mac80211/cfg.c	2015-06-23 14:54:15.036847281 +0200
@@ -858,7 +858,7 @@ static int ieee80211_stop_ap(struct wiph
 	if (sdata->wdev.cac_started) {
 		chandef = sdata->vif.bss_conf.chandef;
 		cancel_delayed_work_sync(&sdata->dfs_cac_timer_work);
-		cfg80211_cac_event(sdata->dev, &chandef,
+		cfg80211_cac_event_dup(sdata->dev, &chandef,
 				   NL80211_RADAR_CAC_ABORTED,
 				   GFP_KERNEL);
 	}
@@ -1295,7 +1295,7 @@ static int ieee80211_change_station(stru
 		goto out_err;
 	}
 
-	err = cfg80211_check_station_change(wiphy, params, statype);
+	err = cfg80211_check_station_change_dup(wiphy, params, statype);
 	if (err)
 		goto out_err;
 
@@ -2240,7 +2240,7 @@ int __ieee80211_request_smps_ap(struct i
 	 /* If no associated stations, there's no need to do anything */
 	if (!atomic_read(&sdata->u.ap.num_mcast_sta)) {
 		sdata->smps_mode = smps_mode;
-		ieee80211_queue_work(&sdata->local->hw, &sdata->recalc_smps);
+		ieee80211_queue_work_dup(&sdata->local->hw, &sdata->recalc_smps);
 		return 0;
 	}
 
@@ -2295,7 +2295,7 @@ int __ieee80211_request_smps_ap(struct i
 	mutex_unlock(&sdata->local->sta_mtx);
 
 	sdata->smps_mode = smps_mode;
-	ieee80211_queue_work(&sdata->local->hw, &sdata->recalc_smps);
+	ieee80211_queue_work_dup(&sdata->local->hw, &sdata->recalc_smps);
 
 	return 0;
 }
@@ -2561,7 +2561,7 @@ static int ieee80211_start_roc_work(stru
 
 	/* if not HW assist, just queue & schedule work */
 	if (!local->ops->remain_on_channel) {
-		ieee80211_queue_delayed_work(&local->hw, &roc->work, 0);
+		ieee80211_queue_delayed_work_dup(&local->hw, &roc->work, 0);
 		goto out_queue;
 	}
 
@@ -2739,7 +2739,7 @@ static int ieee80211_cancel_roc(struct i
 	} else {
 		/* work may be pending so use it all the time */
 		found->abort = true;
-		ieee80211_queue_delayed_work(&local->hw, &found->work, 0);
+		ieee80211_queue_delayed_work_dup(&local->hw, &found->work, 0);
 
 		mutex_unlock(&local->mtx);
 
@@ -2786,7 +2786,7 @@ static int ieee80211_start_radar_detecti
 	if (err)
 		goto out_unlock;
 
-	ieee80211_queue_delayed_work(&sdata->local->hw,
+	ieee80211_queue_delayed_work_dup(&sdata->local->hw,
 				     &sdata->dfs_cac_timer_work,
 				     msecs_to_jiffies(cac_time_ms));
 
@@ -2851,14 +2851,14 @@ cfg80211_beacon_dup(struct cfg80211_beac
 	return new_beacon;
 }
 
-void ieee80211_csa_finish(struct ieee80211_vif *vif)
+void ieee80211_csa_finish_dup(struct ieee80211_vif *vif)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 
-	ieee80211_queue_work(&sdata->local->hw,
+	ieee80211_queue_work_dup(&sdata->local->hw,
 			     &sdata->csa_finalize_work);
 }
-EXPORT_SYMBOL(ieee80211_csa_finish);
+EXPORT_SYMBOL(ieee80211_csa_finish_dup);
 
 static int ieee80211_set_after_csa_beacon(struct ieee80211_sub_if_data *sdata,
 					  u32 *changed)
@@ -2917,7 +2917,7 @@ static int __ieee80211_csa_finalize(stru
 
 	if (sdata->reserved_chanctx) {
 		/*
-		 * with multi-vif csa driver may call ieee80211_csa_finish()
+		 * with multi-vif csa driver may call ieee80211_csa_finish_dup()
 		 * many times while waiting for other interfaces to use their
 		 * reservations
 		 */
@@ -2949,7 +2949,7 @@ static int __ieee80211_csa_finalize(stru
 	if (err)
 		return err;
 
-	cfg80211_ch_switch_notify(sdata->dev, &sdata->csa_chandef);
+	cfg80211_ch_switch_notify_dup(sdata->dev, &sdata->csa_chandef);
 
 	return 0;
 }
@@ -2958,7 +2958,7 @@ static void ieee80211_csa_finalize(struc
 {
 	if (__ieee80211_csa_finalize(sdata)) {
 		sdata_info(sdata, "failed to finalize CSA, disconnecting\n");
-		cfg80211_stop_iface(sdata->local->hw.wiphy, &sdata->wdev,
+		cfg80211_stop_iface_dup(sdata->local->hw.wiphy, &sdata->wdev,
 				    GFP_KERNEL);
 	}
 }
@@ -3202,7 +3202,7 @@ __ieee80211_channel_switch(struct wiphy
 		ieee80211_stop_vif_queues(local, sdata,
 					  IEEE80211_QUEUE_STOP_REASON_CSA);
 
-	cfg80211_ch_switch_started_notify(sdata->dev, &sdata->csa_chandef,
+	cfg80211_ch_switch_started_notify_dup(sdata->dev, &sdata->csa_chandef,
 					  params->count);
 
 	if (changed) {
@@ -3419,7 +3419,7 @@ static void ieee80211_mgmt_frame_registe
 		if (!local->open_count)
 			break;
 
-		ieee80211_queue_work(&local->hw, &local->reconfig_filter);
+		ieee80211_queue_work_dup(&local->hw, &local->reconfig_filter);
 		break;
 	default:
 		break;
--- a/net/mac80211/debugfs_netdev.c	2015-06-23 11:07:42.824850666 +0200
+++ b/net/mac80211/debugfs_netdev.c	2015-06-23 14:54:15.103847582 +0200
@@ -362,7 +362,7 @@ static ssize_t ieee80211_if_parse_beacon
 	if (!ieee80211_sdata_running(sdata) || !sdata->vif.bss_conf.assoc)
 		return -ENOTCONN;
 
-	ieee80211_beacon_loss(&sdata->vif);
+	ieee80211_beacon_loss_dup(&sdata->vif);
 
 	return buflen;
 }
--- a/net/mac80211/debugfs_sta.c	2015-06-23 11:07:42.824850666 +0200
+++ b/net/mac80211/debugfs_sta.c	2015-06-23 14:54:15.142847757 +0200
@@ -241,11 +241,11 @@ static ssize_t sta_agg_status_write(stru
 
 	if (tx) {
 		if (start)
-			ret = ieee80211_start_tx_ba_session(&sta->sta, tid, 5000);
+			ret = ieee80211_start_tx_ba_session_dup(&sta->sta, tid, 5000);
 		else
-			ret = ieee80211_stop_tx_ba_session(&sta->sta, tid);
+			ret = ieee80211_stop_tx_ba_session_dup(&sta->sta, tid);
 	} else {
-		__ieee80211_stop_rx_ba_session(sta, tid, WLAN_BACK_RECIPIENT,
+		__ieee80211_stop_rx_ba_session_dup(sta, tid, WLAN_BACK_RECIPIENT,
 					       3, true);
 		ret = 0;
 	}
@@ -373,7 +373,7 @@ static ssize_t sta_current_tx_rate_read(
 	struct rate_info rinfo;
 	u16 rate;
 	sta_set_rate_info_tx(sta, &sta->last_tx_rate, &rinfo);
-	rate = cfg80211_calculate_bitrate(&rinfo);
+	rate = cfg80211_calculate_bitrate_dup(&rinfo);
 
 	return mac80211_format_buffer(userbuf, count, ppos,
 				      "%d.%d MBit/s\n",
@@ -390,7 +390,7 @@ static ssize_t sta_last_rx_rate_read(str
 
 	sta_set_rate_info_rx(sta, &rinfo);
 
-	rate = cfg80211_calculate_bitrate(&rinfo);
+	rate = cfg80211_calculate_bitrate_dup(&rinfo);
 
 	return mac80211_format_buffer(userbuf, count, ppos,
 				      "%d.%d MBit/s\n",
--- a/net/mac80211/ethtool.c	2015-06-23 11:07:42.824850666 +0200
+++ b/net/mac80211/ethtool.c	2015-06-23 14:54:15.185847950 +0200
@@ -119,11 +119,11 @@ static void ieee80211_get_stats(struct n
 
 		if (sinfo.filled & STATION_INFO_TX_BITRATE)
 			data[i] = 100000 *
-				cfg80211_calculate_bitrate(&sinfo.txrate);
+				cfg80211_calculate_bitrate_dup(&sinfo.txrate);
 		i++;
 		if (sinfo.filled & STATION_INFO_RX_BITRATE)
 			data[i] = 100000 *
-				cfg80211_calculate_bitrate(&sinfo.rxrate);
+				cfg80211_calculate_bitrate_dup(&sinfo.rxrate);
 		i++;
 
 		if (sinfo.filled & STATION_INFO_SIGNAL_AVG)
@@ -232,7 +232,7 @@ static void ieee80211_get_regs(struct net_device *dev,
 }
 
 const struct ethtool_ops ieee80211_ethtool_ops = {
-	.get_drvinfo = cfg80211_get_drvinfo,
+	.get_drvinfo = cfg80211_get_drvinfo_dup,
 	.get_regs_len = ieee80211_get_regs_len,
 	.get_regs = ieee80211_get_regs,
 	.get_link = ethtool_op_get_link,
--- a/net/mac80211/event.c	2015-06-23 11:07:42.824850666 +0200
+++ b/net/mac80211/event.c	2015-06-23 14:54:15.233848166 +0200
@@ -19,7 +19,7 @@ void mac80211_ev_michael_mic_failure(str
 				     struct ieee80211_hdr *hdr, const u8 *tsc,
 				     gfp_t gfp)
 {
-	cfg80211_michael_mic_failure(sdata->dev, hdr->addr2,
+	cfg80211_michael_mic_failure_dup(sdata->dev, hdr->addr2,
 				     (hdr->addr1[0] & 0x01) ?
 				     NL80211_KEYTYPE_GROUP :
 				     NL80211_KEYTYPE_PAIRWISE,
--- a/net/mac80211/ht.c	2015-06-23 11:07:42.824850666 +0200
+++ b/net/mac80211/ht.c	2015-06-23 14:54:15.287848408 +0200
@@ -289,8 +289,8 @@ void ieee80211_sta_tear_down_BA_sessions
 	cancel_work_sync(&sta->ampdu_mlme.work);
 
 	for (i = 0; i <  IEEE80211_NUM_TIDS; i++) {
-		__ieee80211_stop_tx_ba_session(sta, i, reason);
-		__ieee80211_stop_rx_ba_session(sta, i, WLAN_BACK_RECIPIENT,
+		__ieee80211_stop_tx_ba_session_dup(sta, i, reason);
+		__ieee80211_stop_rx_ba_session_dup(sta, i, WLAN_BACK_RECIPIENT,
 					       WLAN_REASON_QSTA_LEAVE_QBSS,
 					       reason != AGG_STOP_DESTROY_STA &&
 					       reason != AGG_STOP_PEER_REQUEST);
@@ -316,13 +316,13 @@ void ieee80211_ba_session_work(struct wo
 	mutex_lock(&sta->ampdu_mlme.mtx);
 	for (tid = 0; tid < IEEE80211_NUM_TIDS; tid++) {
 		if (test_and_clear_bit(tid, sta->ampdu_mlme.tid_rx_timer_expired))
-			___ieee80211_stop_rx_ba_session(
+			___ieee80211_stop_rx_ba_session_dup(
 				sta, tid, WLAN_BACK_RECIPIENT,
 				WLAN_REASON_QSTA_TIMEOUT, true);
 
 		if (test_and_clear_bit(tid,
 				       sta->ampdu_mlme.tid_rx_stop_requested))
-			___ieee80211_stop_rx_ba_session(
+			___ieee80211_stop_rx_ba_session_dup(
 				sta, tid, WLAN_BACK_RECIPIENT,
 				WLAN_REASON_UNSPECIFIED, true);
 
@@ -351,7 +351,7 @@ void ieee80211_ba_session_work(struct wo
 		tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
 		if (tid_tx && test_and_clear_bit(HT_AGG_STATE_WANT_STOP,
 						 &tid_tx->state))
-			___ieee80211_stop_tx_ba_session(sta, tid,
+			___ieee80211_stop_tx_ba_session_dup(sta, tid,
 							AGG_STOP_LOCAL_REQUEST);
 	}
 	mutex_unlock(&sta->ampdu_mlme.mtx);
@@ -417,10 +417,10 @@ void ieee80211_process_delba(struct ieee
 			   le16_to_cpu(mgmt->u.action.u.delba.reason_code));
 
 	if (initiator == WLAN_BACK_INITIATOR)
-		__ieee80211_stop_rx_ba_session(sta, tid, WLAN_BACK_INITIATOR, 0,
+		__ieee80211_stop_rx_ba_session_dup(sta, tid, WLAN_BACK_INITIATOR, 0,
 					       true);
 	else
-		__ieee80211_stop_tx_ba_session(sta, tid, AGG_STOP_PEER_REQUEST);
+		__ieee80211_stop_tx_ba_session_dup(sta, tid, AGG_STOP_PEER_REQUEST);
 }
 
 int ieee80211_send_smps_action(struct ieee80211_sub_if_data *sdata,
@@ -494,7 +494,7 @@ void ieee80211_request_smps_ap_work(stru
 	sdata_unlock(sdata);
 }
 
-void ieee80211_request_smps(struct ieee80211_vif *vif,
+void ieee80211_request_smps_dup(struct ieee80211_vif *vif,
 			    enum ieee80211_smps_mode smps_mode)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
@@ -507,7 +507,7 @@ void ieee80211_request_smps(struct ieee8
 		if (sdata->u.mgd.driver_smps_mode == smps_mode)
 			return;
 		sdata->u.mgd.driver_smps_mode = smps_mode;
-		ieee80211_queue_work(&sdata->local->hw,
+		ieee80211_queue_work_dup(&sdata->local->hw,
 				     &sdata->u.mgd.request_smps_work);
 	} else {
 		/* AUTOMATIC is meaningless in AP mode */
@@ -516,9 +516,9 @@ void ieee80211_request_smps(struct ieee8
 		if (sdata->u.ap.driver_smps_mode == smps_mode)
 			return;
 		sdata->u.ap.driver_smps_mode = smps_mode;
-		ieee80211_queue_work(&sdata->local->hw,
+		ieee80211_queue_work_dup(&sdata->local->hw,
 				     &sdata->u.ap.request_smps_work);
 	}
 }
 /* this might change ... don't want non-open drivers using it */
-EXPORT_SYMBOL_GPL(ieee80211_request_smps);
+EXPORT_SYMBOL_GPL(ieee80211_request_smps_dup);
--- a/net/mac80211/chan.c	2015-06-23 11:07:42.823850654 +0200
+++ b/net/mac80211/chan.c	2015-06-23 14:54:15.330848602 +0200
@@ -91,7 +91,7 @@ ieee80211_chanctx_reserved_chandef(struc
 		if (!compat)
 			compat = &sdata->reserved_chandef;
 
-		compat = cfg80211_chandef_compatible(&sdata->reserved_chandef,
+		compat = cfg80211_chandef_compatible_dup(&sdata->reserved_chandef,
 						     compat);
 		if (!compat)
 			break;
@@ -117,7 +117,7 @@ ieee80211_chanctx_non_reserved_chandef(s
 		if (!compat)
 			compat = &sdata->vif.bss_conf.chandef;
 
-		compat = cfg80211_chandef_compatible(
+		compat = cfg80211_chandef_compatible_dup(
 				&sdata->vif.bss_conf.chandef, compat);
 		if (!compat)
 			break;
@@ -338,7 +338,7 @@ static void ieee80211_change_chanctx(str
 	if (cfg80211_chandef_identical(&ctx->conf.def, chandef))
 		return;
 
-	WARN_ON(!cfg80211_chandef_compatible(&ctx->conf.def, chandef));
+	WARN_ON(!cfg80211_chandef_compatible_dup(&ctx->conf.def, chandef));
 
 	ctx->conf.def = *chandef;
 	drv_change_chanctx(local, ctx, IEEE80211_CHANCTX_CHANGE_WIDTH);
@@ -371,7 +371,7 @@ ieee80211_find_chanctx(struct ieee80211_
 		if (ctx->mode == IEEE80211_CHANCTX_EXCLUSIVE)
 			continue;
 
-		compat = cfg80211_chandef_compatible(&ctx->conf.def, chandef);
+		compat = cfg80211_chandef_compatible_dup(&ctx->conf.def, chandef);
 		if (!compat)
 			continue;
 
@@ -548,7 +548,7 @@ static void ieee80211_recalc_chanctx_cha
 		if (!compat)
 			compat = &sdata->vif.bss_conf.chandef;
 
-		compat = cfg80211_chandef_compatible(
+		compat = cfg80211_chandef_compatible_dup(
 				&sdata->vif.bss_conf.chandef, compat);
 		if (WARN_ON_ONCE(!compat))
 			break;
@@ -912,11 +912,11 @@ ieee80211_vif_chanctx_reservation_comple
 	case NL80211_IFTYPE_AP:
 	case NL80211_IFTYPE_MESH_POINT:
 	case NL80211_IFTYPE_OCB:
-		ieee80211_queue_work(&sdata->local->hw,
+		ieee80211_queue_work_dup(&sdata->local->hw,
 				     &sdata->csa_finalize_work);
 		break;
 	case NL80211_IFTYPE_STATION:
-		ieee80211_queue_work(&sdata->local->hw,
+		ieee80211_queue_work_dup(&sdata->local->hw,
 				     &sdata->u.mgd.chswitch_work);
 		break;
 	case NL80211_IFTYPE_UNSPECIFIED:
@@ -1411,7 +1411,7 @@ static int ieee80211_vif_use_reserved_sw
 					   "failed to finalize (re-)assign reservation (err=%d)\n",
 					   err);
 				ieee80211_vif_unreserve_chanctx(sdata);
-				cfg80211_stop_iface(local->hw.wiphy,
+				cfg80211_stop_iface_dup(local->hw.wiphy,
 						    &sdata->wdev,
 						    GFP_KERNEL);
 			}
@@ -1501,7 +1501,7 @@ int ieee80211_vif_use_channel(struct iee
 
 	mutex_lock(&local->chanctx_mtx);
 
-	ret = cfg80211_chandef_dfs_required(local->hw.wiphy,
+	ret = cfg80211_chandef_dfs_required_dup(local->hw.wiphy,
 					    chandef,
 					    sdata->wdev.iftype);
 	if (ret < 0)
@@ -1617,7 +1617,7 @@ int ieee80211_vif_change_bandwidth(struc
 	const struct cfg80211_chan_def *compat;
 	int ret;
 
-	if (!cfg80211_chandef_usable(sdata->local->hw.wiphy, chandef,
+	if (!cfg80211_chandef_usable_dup(sdata->local->hw.wiphy, chandef,
 				     IEEE80211_CHAN_DISABLED))
 		return -EINVAL;
 
@@ -1642,7 +1642,7 @@ int ieee80211_vif_change_bandwidth(struc
 
 	ctx = container_of(conf, struct ieee80211_chanctx, conf);
 
-	compat = cfg80211_chandef_compatible(&conf->def, chandef);
+	compat = cfg80211_chandef_compatible_dup(&conf->def, chandef);
 	if (!compat) {
 		ret = -EINVAL;
 		goto out;
@@ -1709,7 +1709,7 @@ void ieee80211_vif_vlan_copy_chanctx(str
 	mutex_unlock(&local->chanctx_mtx);
 }
 
-void ieee80211_iter_chan_contexts_atomic(
+void ieee80211_iter_chan_contexts_atomic_dup(
 	struct ieee80211_hw *hw,
 	void (*iter)(struct ieee80211_hw *hw,
 		     struct ieee80211_chanctx_conf *chanctx_conf,
@@ -1725,4 +1725,4 @@ void ieee80211_iter_chan_contexts_atomic
 			iter(hw, &ctx->conf, iter_data);
 	rcu_read_unlock();
 }
-EXPORT_SYMBOL_GPL(ieee80211_iter_chan_contexts_atomic);
+EXPORT_SYMBOL_GPL(ieee80211_iter_chan_contexts_atomic_dup);
--- a/net/mac80211/ibss.c	2015-06-23 11:07:42.825850677 +0200
+++ b/net/mac80211/ibss.c	2015-06-23 14:54:15.375848803 +0200
@@ -128,7 +128,7 @@ ieee80211_ibss_build_presp(struct ieee80
 	if (sband->band == IEEE80211_BAND_2GHZ) {
 		*pos++ = WLAN_EID_DS_PARAMS;
 		*pos++ = 1;
-		*pos++ = ieee80211_frequency_to_channel(
+		*pos++ = ieee80211_frequency_to_channel_dup(
 				chandef->chan->center_freq);
 	}
 
@@ -142,7 +142,7 @@ ieee80211_ibss_build_presp(struct ieee80
 		*pos++ = WLAN_EID_CHANNEL_SWITCH;
 		*pos++ = 3;
 		*pos++ = csa_settings->block_tx ? 1 : 0;
-		*pos++ = ieee80211_frequency_to_channel(
+		*pos++ = ieee80211_frequency_to_channel_dup(
 				csa_settings->chandef.chan->center_freq);
 		presp->csa_counter_offsets[0] = (pos - presp->head);
 		*pos++ = csa_settings->count;
@@ -254,7 +254,7 @@ static void __ieee80211_sta_join_ibss(st
 	/* make a copy of the chandef, it could be modified below. */
 	chandef = *req_chandef;
 	chan = chandef.chan;
-	if (!cfg80211_reg_can_beacon(local->hw.wiphy, &chandef,
+	if (!cfg80211_reg_can_beacon_dup(local->hw.wiphy, &chandef,
 				     NL80211_IFTYPE_ADHOC)) {
 		if (chandef.width == NL80211_CHAN_WIDTH_5 ||
 		    chandef.width == NL80211_CHAN_WIDTH_10 ||
@@ -267,7 +267,7 @@ static void __ieee80211_sta_join_ibss(st
 		chandef.width = NL80211_CHAN_WIDTH_20;
 		chandef.center_freq1 = chan->center_freq;
 		/* check again for downgraded chandef */
-		if (!cfg80211_reg_can_beacon(local->hw.wiphy, &chandef,
+		if (!cfg80211_reg_can_beacon_dup(local->hw.wiphy, &chandef,
 					     NL80211_IFTYPE_ADHOC)) {
 			sdata_info(sdata,
 				   "Failed to join IBSS, beacons forbidden\n");
@@ -275,7 +275,7 @@ static void __ieee80211_sta_join_ibss(st
 		}
 	}
 
-	err = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,
+	err = cfg80211_chandef_dfs_required_dup(sdata->local->hw.wiphy,
 					    &chandef, NL80211_IFTYPE_ADHOC);
 	if (err < 0) {
 		sdata_info(sdata,
@@ -375,12 +375,12 @@ static void __ieee80211_sta_join_ibss(st
 		  round_jiffies(jiffies + IEEE80211_IBSS_MERGE_INTERVAL));
 
 	scan_width = cfg80211_chandef_to_scan_width(&chandef);
-	bss = cfg80211_inform_bss_width_frame(local->hw.wiphy, chan,
+	bss = cfg80211_inform_bss_width_frame_dup(local->hw.wiphy, chan,
 					      scan_width, mgmt,
 					      presp->head_len, 0, GFP_KERNEL);
-	cfg80211_put_bss(local->hw.wiphy, bss);
+	cfg80211_put_bss_dup(local->hw.wiphy, bss);
 	netif_carrier_on(sdata->dev);
-	cfg80211_ibss_joined(sdata->dev, ifibss->bssid, chan, GFP_KERNEL);
+	cfg80211_ibss_joined_dup(sdata->dev, ifibss->bssid, chan, GFP_KERNEL);
 }
 
 static void ieee80211_sta_join_ibss(struct ieee80211_sub_if_data *sdata,
@@ -409,17 +409,17 @@ static void ieee80211_sta_join_ibss(stru
 	case NL80211_CHAN_WIDTH_20:
 	case NL80211_CHAN_WIDTH_40:
 		chan_type = cfg80211_get_chandef_type(&sdata->u.ibss.chandef);
-		cfg80211_chandef_create(&chandef, cbss->channel, chan_type);
+		cfg80211_chandef_create_dup(&chandef, cbss->channel, chan_type);
 		break;
 	case NL80211_CHAN_WIDTH_5:
 	case NL80211_CHAN_WIDTH_10:
-		cfg80211_chandef_create(&chandef, cbss->channel,
+		cfg80211_chandef_create_dup(&chandef, cbss->channel,
 					NL80211_CHAN_WIDTH_20_NOHT);
 		chandef.width = sdata->u.ibss.chandef.width;
 		break;
 	default:
 		/* fall back to 20 MHz for unsupported modes */
-		cfg80211_chandef_create(&chandef, cbss->channel,
+		cfg80211_chandef_create_dup(&chandef, cbss->channel,
 					NL80211_CHAN_WIDTH_20_NOHT);
 		break;
 	}
@@ -481,7 +481,7 @@ int ieee80211_ibss_csa_beacon(struct iee
 	if (ifibss->privacy)
 		capability |= WLAN_CAPABILITY_PRIVACY;
 
-	cbss = cfg80211_get_bss(sdata->local->hw.wiphy, ifibss->chandef.chan,
+	cbss = cfg80211_get_bss_dup(sdata->local->hw.wiphy, ifibss->chandef.chan,
 				ifibss->bssid, ifibss->ssid,
 				ifibss->ssid_len, WLAN_CAPABILITY_IBSS |
 				WLAN_CAPABILITY_PRIVACY,
@@ -496,7 +496,7 @@ int ieee80211_ibss_csa_beacon(struct iee
 	ies = rcu_dereference(cbss->ies);
 	tsf = ies->tsf;
 	rcu_read_unlock();
-	cfg80211_put_bss(sdata->local->hw.wiphy, cbss);
+	cfg80211_put_bss_dup(sdata->local->hw.wiphy, cbss);
 
 	old_presp = rcu_dereference_protected(ifibss->presp,
 					  lockdep_is_held(&sdata->wdev.mtx));
@@ -536,7 +536,7 @@ int ieee80211_ibss_finish_csa(struct iee
 		if (ifibss->privacy)
 			capability |= WLAN_CAPABILITY_PRIVACY;
 
-		cbss = cfg80211_get_bss(sdata->local->hw.wiphy,
+		cbss = cfg80211_get_bss_dup(sdata->local->hw.wiphy,
 					ifibss->chandef.chan,
 					ifibss->bssid, ifibss->ssid,
 					ifibss->ssid_len, WLAN_CAPABILITY_IBSS |
@@ -545,7 +545,7 @@ int ieee80211_ibss_finish_csa(struct iee
 		/* XXX: should not really modify cfg80211 data */
 		if (cbss) {
 			cbss->channel = sdata->csa_chandef.chan;
-			cfg80211_put_bss(sdata->local->hw.wiphy, cbss);
+			cfg80211_put_bss_dup(sdata->local->hw.wiphy, cbss);
 		}
 	}
 
@@ -646,7 +646,7 @@ ieee80211_ibss_add_sta(struct ieee80211_
 	/* make sure mandatory rates are always added */
 	sband = local->hw.wiphy->bands[band];
 	sta->sta.supp_rates[band] = supp_rates |
-			ieee80211_mandatory_rates(sband, scan_width);
+			ieee80211_mandatory_rates_dup(sband, scan_width);
 
 	return ieee80211_ibss_finish_sta(sta);
 }
@@ -690,15 +690,15 @@ static void ieee80211_ibss_disconnect(st
 		if (ifibss->privacy)
 			capability |= WLAN_CAPABILITY_PRIVACY;
 
-		cbss = cfg80211_get_bss(local->hw.wiphy, ifibss->chandef.chan,
+		cbss = cfg80211_get_bss_dup(local->hw.wiphy, ifibss->chandef.chan,
 					ifibss->bssid, ifibss->ssid,
 					ifibss->ssid_len, WLAN_CAPABILITY_IBSS |
 					WLAN_CAPABILITY_PRIVACY,
 					capability);
 
 		if (cbss) {
-			cfg80211_unlink_bss(local->hw.wiphy, cbss);
-			cfg80211_put_bss(sdata->local->hw.wiphy, cbss);
+			cfg80211_unlink_bss_dup(local->hw.wiphy, cbss);
+			cfg80211_put_bss_dup(sdata->local->hw.wiphy, cbss);
 		}
 	}
 
@@ -754,7 +754,7 @@ static void ieee80211_csa_connection_dro
 	skb_queue_purge(&sdata->skb_queue);
 
 	/* trigger a scan to find another IBSS network to join */
-	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&sdata->local->hw, &sdata->work);
 
 	sdata_unlock(sdata);
 }
@@ -767,11 +767,11 @@ static void ieee80211_ibss_csa_mark_rada
 	/* if the current channel is a DFS channel, mark the channel as
 	 * unavailable.
 	 */
-	err = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,
+	err = cfg80211_chandef_dfs_required_dup(sdata->local->hw.wiphy,
 					    &ifibss->chandef,
 					    NL80211_IFTYPE_ADHOC);
 	if (err > 0)
-		cfg80211_radar_event(sdata->local->hw.wiphy, &ifibss->chandef,
+		cfg80211_radar_event_dup(sdata->local->hw.wiphy, &ifibss->chandef,
 				     GFP_ATOMIC);
 }
 
@@ -833,7 +833,7 @@ ieee80211_ibss_process_chanswitch(struct
 		 * keep the mode which we announce.
 		 */
 		ch_type = cfg80211_get_chandef_type(&ifibss->chandef);
-		cfg80211_chandef_create(&params.chandef, params.chandef.chan,
+		cfg80211_chandef_create_dup(&params.chandef, params.chandef.chan,
 					ch_type);
 		break;
 	case NL80211_CHAN_WIDTH_5:
@@ -855,7 +855,7 @@ ieee80211_ibss_process_chanswitch(struct
 		goto disconnect;
 	}
 
-	if (!cfg80211_reg_can_beacon(sdata->local->hw.wiphy, &params.chandef,
+	if (!cfg80211_reg_can_beacon_dup(sdata->local->hw.wiphy, &params.chandef,
 				     NL80211_IFTYPE_ADHOC)) {
 		sdata_info(sdata,
 			   "IBSS %pM switches to unsupported channel (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\n",
@@ -867,7 +867,7 @@ ieee80211_ibss_process_chanswitch(struct
 		goto disconnect;
 	}
 
-	err = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,
+	err = cfg80211_chandef_dfs_required_dup(sdata->local->hw.wiphy,
 					    &params.chandef,
 					    NL80211_IFTYPE_ADHOC);
 	if (err < 0)
@@ -902,7 +902,7 @@ ieee80211_ibss_process_chanswitch(struct
 	return true;
 disconnect:
 	ibss_dbg(sdata, "Can't handle channel switch, disconnect\n");
-	ieee80211_queue_work(&sdata->local->hw,
+	ieee80211_queue_work_dup(&sdata->local->hw,
 			     &ifibss->csa_connection_drop_work);
 
 	ieee80211_ibss_csa_mark_radar(sdata);
@@ -1022,7 +1022,7 @@ static void ieee80211_rx_bss_info(struct
 					scan_width = NL80211_BSS_CHAN_WIDTH_10;
 
 				sta->sta.supp_rates[band] = supp_rates |
-					ieee80211_mandatory_rates(sband,
+					ieee80211_mandatory_rates_dup(sband,
 								  scan_width);
 				if (sta->sta.supp_rates[band] != prev_rates) {
 					ibss_dbg(sdata,
@@ -1200,12 +1200,12 @@ void ieee80211_ibss_rx_no_sta(struct iee
 	/* make sure mandatory rates are always added */
 	sband = local->hw.wiphy->bands[band];
 	sta->sta.supp_rates[band] = supp_rates |
-			ieee80211_mandatory_rates(sband, scan_width);
+			ieee80211_mandatory_rates_dup(sband, scan_width);
 
 	spin_lock(&ifibss->incomplete_lock);
 	list_add(&sta->list, &ifibss->incomplete_stations);
 	spin_unlock(&ifibss->incomplete_lock);
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 }
 
 static void ieee80211_ibss_sta_expire(struct ieee80211_sub_if_data *sdata)
@@ -1337,7 +1337,7 @@ static void ieee80211_sta_find_ibss(stru
 		chan = ifibss->chandef.chan;
 	if (!is_zero_ether_addr(ifibss->bssid))
 		bssid = ifibss->bssid;
-	cbss = cfg80211_get_bss(local->hw.wiphy, chan, bssid,
+	cbss = cfg80211_get_bss_dup(local->hw.wiphy, chan, bssid,
 				ifibss->ssid, ifibss->ssid_len,
 				WLAN_CAPABILITY_IBSS | WLAN_CAPABILITY_PRIVACY,
 				capability);
@@ -1593,7 +1593,7 @@ static void ieee80211_ibss_timer(unsigne
 	struct ieee80211_sub_if_data *sdata =
 		(struct ieee80211_sub_if_data *) data;
 
-	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&sdata->local->hw, &sdata->work);
 }
 
 void ieee80211_ibss_setup_sdata(struct ieee80211_sub_if_data *sdata)
@@ -1620,7 +1620,7 @@ void ieee80211_ibss_notify_scan_complete
 		if (sdata->vif.type != NL80211_IFTYPE_ADHOC)
 			continue;
 		sdata->u.ibss.last_scan_completed = jiffies;
-		ieee80211_queue_work(&local->hw, &sdata->work);
+		ieee80211_queue_work_dup(&local->hw, &sdata->work);
 	}
 	mutex_unlock(&local->iflist_mtx);
 }
@@ -1637,7 +1637,7 @@ int ieee80211_ibss_join(struct ieee80211
 	int i;
 	int ret;
 
-	ret = cfg80211_chandef_dfs_required(local->hw.wiphy,
+	ret = cfg80211_chandef_dfs_required_dup(local->hw.wiphy,
 					    &params->chandef,
 					    sdata->wdev.iftype);
 	if (ret < 0)
@@ -1724,7 +1724,7 @@ int ieee80211_ibss_join(struct ieee80211
 	sdata->smps_mode = IEEE80211_SMPS_OFF;
 	sdata->needed_rx_chains = local->rx_chains;
 
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 
 	return 0;
 }
--- a/net/mac80211/ieee80211_i.h	2015-06-23 11:07:42.825850677 +0200
+++ b/net/mac80211/ieee80211_i.h	2015-06-23 14:54:15.482849284 +0200
@@ -180,37 +180,37 @@ typedef unsigned __bitwise__ ieee80211_r
 
 /**
  * enum ieee80211_packet_rx_flags - packet RX flags
- * @IEEE80211_RX_RA_MATCH: frame is destined to interface currently processed
+ * @ieee80211_rx_RA_MATCH: frame is destined to interface currently processed
  *	(incl. multicast frames)
- * @IEEE80211_RX_FRAGMENTED: fragmented frame
- * @IEEE80211_RX_AMSDU: a-MSDU packet
- * @IEEE80211_RX_MALFORMED_ACTION_FRM: action frame is malformed
- * @IEEE80211_RX_DEFERRED_RELEASE: frame was subjected to receive reordering
+ * @ieee80211_rx_FRAGMENTED: fragmented frame
+ * @ieee80211_rx_AMSDU: a-MSDU packet
+ * @ieee80211_rx_MALFORMED_ACTION_FRM: action frame is malformed
+ * @ieee80211_rx_DEFERRED_RELEASE: frame was subjected to receive reordering
  *
  * These are per-frame flags that are attached to a frame in the
  * @rx_flags field of &struct ieee80211_rx_status.
  */
 enum ieee80211_packet_rx_flags {
-	IEEE80211_RX_RA_MATCH			= BIT(1),
-	IEEE80211_RX_FRAGMENTED			= BIT(2),
-	IEEE80211_RX_AMSDU			= BIT(3),
-	IEEE80211_RX_MALFORMED_ACTION_FRM	= BIT(4),
-	IEEE80211_RX_DEFERRED_RELEASE		= BIT(5),
+	ieee80211_rx_RA_MATCH			= BIT(1),
+	ieee80211_rx_FRAGMENTED			= BIT(2),
+	ieee80211_rx_AMSDU			= BIT(3),
+	ieee80211_rx_MALFORMED_ACTION_FRM	= BIT(4),
+	ieee80211_rx_DEFERRED_RELEASE		= BIT(5),
 };
 
 /**
  * enum ieee80211_rx_flags - RX data flags
  *
- * @IEEE80211_RX_CMNTR: received on cooked monitor already
- * @IEEE80211_RX_BEACON_REPORTED: This frame was already reported
- *	to cfg80211_report_obss_beacon().
+ * @ieee80211_rx_CMNTR: received on cooked monitor already
+ * @ieee80211_rx_BEACON_REPORTED: This frame was already reported
+ *	to cfg80211_report_obss_beacon_dup().
  *
  * These flags are used across handling multiple interfaces
  * for a single frame.
  */
 enum ieee80211_rx_flags {
-	IEEE80211_RX_CMNTR		= BIT(0),
-	IEEE80211_RX_BEACON_REPORTED	= BIT(1),
+	ieee80211_rx_CMNTR		= BIT(0),
+	ieee80211_rx_BEACON_REPORTED	= BIT(1),
 };
 
 struct ieee80211_rx_data {
@@ -1008,8 +1008,8 @@ enum sdata_queue_type {
 };
 
 enum {
-	IEEE80211_RX_MSG	= 1,
-	IEEE80211_TX_STATUS_MSG	= 2,
+	ieee80211_rx_MSG	= 1,
+	ieee80211_tx_status_MSG	= 2,
 };
 
 enum queue_stop_reason {
@@ -1116,7 +1116,7 @@ struct ieee80211_local {
 
 	/*
 	 * private workqueue to mac80211. mac80211 makes this accessible
-	 * via ieee80211_queue_work()
+	 * via ieee80211_queue_work_dup()
 	 */
 	struct workqueue_struct *workqueue;
 
@@ -1163,7 +1163,7 @@ struct ieee80211_local {
 
 	/*
 	 * Resuming is true while suspended, but when we're reprogramming the
-	 * hardware -- at that time it's allowed to use ieee80211_queue_work()
+	 * hardware -- at that time it's allowed to use ieee80211_queue_work_dup()
 	 * again even though some other parts of the stack are still suspended
 	 * and we still drop received frames to avoid waking the stack.
 	 */
@@ -1681,9 +1681,9 @@ void ieee80211_request_smps_mgd_work(str
 bool ieee80211_smps_is_restrictive(enum ieee80211_smps_mode smps_mode_old,
 				   enum ieee80211_smps_mode smps_mode_new);
 
-void ___ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
+void ___ieee80211_stop_rx_ba_session_dup(struct sta_info *sta, u16 tid,
 				     u16 initiator, u16 reason, bool stop);
-void __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,
+void __ieee80211_stop_rx_ba_session_dup(struct sta_info *sta, u16 tid,
 				    u16 initiator, u16 reason, bool stop);
 void __ieee80211_start_rx_ba_session(struct sta_info *sta,
 				     u8 dialog_token, u16 timeout,
@@ -1703,9 +1703,9 @@ void ieee80211_process_addba_request(str
 				     struct ieee80211_mgmt *mgmt,
 				     size_t len);
 
-int __ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
+int __ieee80211_stop_tx_ba_session_dup(struct sta_info *sta, u16 tid,
 				   enum ieee80211_agg_stop_reason reason);
-int ___ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,
+int ___ieee80211_stop_tx_ba_session_dup(struct sta_info *sta, u16 tid,
 				    enum ieee80211_agg_stop_reason reason);
 void ieee80211_start_tx_ba_cb(struct ieee80211_vif *vif, u8 *ra, u16 tid);
 void ieee80211_stop_tx_ba_cb(struct ieee80211_vif *vif, u8 *ra, u8 tid);
@@ -1872,7 +1872,7 @@ void ieee80211_sta_rx_notify(struct ieee
 void ieee80211_sta_tx_notify(struct ieee80211_sub_if_data *sdata,
 			     struct ieee80211_hdr *hdr, bool ack, u16 tx_time);
 
-void ieee80211_wake_queues_by_reason(struct ieee80211_hw *hw,
+void ieee80211_wake_queues_by_reason_dup(struct ieee80211_hw *hw,
 				     unsigned long queues,
 				     enum queue_stop_reason reason,
 				     bool refcounted);
@@ -1882,7 +1882,7 @@ void ieee80211_stop_vif_queues(struct ie
 void ieee80211_wake_vif_queues(struct ieee80211_local *local,
 			       struct ieee80211_sub_if_data *sdata,
 			       enum queue_stop_reason reason);
-void ieee80211_stop_queues_by_reason(struct ieee80211_hw *hw,
+void ieee80211_stop_queues_by_reason_dup(struct ieee80211_hw *hw,
 				     unsigned long queues,
 				     enum queue_stop_reason reason,
 				     bool refcounted);
--- a/net/mac80211/iface.c	2015-06-23 11:07:42.825850677 +0200
+++ b/net/mac80211/iface.c	2015-06-23 14:54:15.608849850 +0200
@@ -881,7 +881,7 @@ static void ieee80211_do_stop(struct iee
 		mutex_lock(&local->mtx);
 		ieee80211_vif_release_channel(sdata);
 		mutex_unlock(&local->mtx);
-		cfg80211_cac_event(sdata->dev, &chandef,
+		cfg80211_cac_event_dup(sdata->dev, &chandef,
 				   NL80211_RADAR_CAC_ABORTED,
 				   GFP_KERNEL);
 	}
@@ -904,7 +904,7 @@ static void ieee80211_do_stop(struct iee
 			if (skb->dev == sdata->dev) {
 				__skb_unlink(skb, &ps->bc_buf);
 				local->total_ps_buffered--;
-				ieee80211_free_txskb(&local->hw, skb);
+				ieee80211_free_txskb_dup(&local->hw, skb);
 			}
 		}
 		spin_unlock_irqrestore(&ps->bc_buf.lock, flags);
@@ -967,7 +967,7 @@ static void ieee80211_do_stop(struct iee
 			struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 			if (info->control.vif == &sdata->vif) {
 				__skb_unlink(skb, &local->pending[i]);
-				ieee80211_free_txskb(&local->hw, skb);
+				ieee80211_free_txskb_dup(&local->hw, skb);
 			}
 		}
 	}
@@ -1074,7 +1074,7 @@ static void ieee80211_set_multicast_list
 			&dev->mc_list, &dev->mc_count);
 #endif
 	spin_unlock_bh(&local->filter_lock);
-	ieee80211_queue_work(&local->hw, &local->reconfig_filter);
+	ieee80211_queue_work_dup(&local->hw, &local->reconfig_filter);
 }
 
 /*
@@ -1188,7 +1188,7 @@ static void ieee80211_iface_work(struct
 		return;
 
 	/*
-	 * ieee80211_queue_work() should have picked up most cases,
+	 * ieee80211_queue_work_dup() should have picked up most cases,
 	 * here we'll pick the rest.
 	 */
 	if (WARN(local->suspended,
@@ -1222,7 +1222,7 @@ static void ieee80211_iface_work(struct
 			mutex_lock(&local->sta_mtx);
 			sta = sta_info_get_bss(sdata, rx_agg->addr);
 			if (sta)
-				__ieee80211_stop_rx_ba_session(sta,
+				__ieee80211_stop_rx_ba_session_dup(sta,
 							rx_agg->tid,
 							WLAN_BACK_RECIPIENT, 0,
 							false);
@@ -1280,7 +1280,7 @@ static void ieee80211_iface_work(struct
 				u16 tid = *ieee80211_get_qos_ctl(hdr) &
 						IEEE80211_QOS_CTL_TID_MASK;
 
-				__ieee80211_stop_rx_ba_session(
+				__ieee80211_stop_rx_ba_session_dup(
 					sta, tid, WLAN_BACK_RECIPIENT,
 					WLAN_REASON_QSTA_REQUIRE_SETUP,
 					true);
@@ -1818,7 +1818,7 @@ void ieee80211_if_remove(struct ieee8021
 	if (sdata->dev) {
 		unregister_netdevice(sdata->dev);
 	} else {
-		cfg80211_unregister_wdev(&sdata->wdev);
+		cfg80211_unregister_wdev_dup(&sdata->wdev);
 		kfree(sdata);
 	}
 }
@@ -1866,7 +1866,7 @@ void ieee80211_remove_interfaces(struct
 
 	list_for_each_entry_safe(sdata, tmp, &wdev_list, list) {
 		list_del(&sdata->list);
-		cfg80211_unregister_wdev(&sdata->wdev);
+		cfg80211_unregister_wdev_dup(&sdata->wdev);
 		kfree(sdata);
 	}
 }
--- a/net/mac80211/key.c	2015-06-23 11:07:42.825850677 +0200
+++ b/net/mac80211/key.c	2015-06-23 14:54:15.678850165 +0200
@@ -563,7 +563,7 @@ void ieee80211_enable_keys(struct ieee80
 	mutex_unlock(&sdata->local->key_mtx);
 }
 
-void ieee80211_iter_keys(struct ieee80211_hw *hw,
+void ieee80211_iter_keys_dup(struct ieee80211_hw *hw,
 			 struct ieee80211_vif *vif,
 			 void (*iter)(struct ieee80211_hw *hw,
 				      struct ieee80211_vif *vif,
@@ -595,7 +595,7 @@ void ieee80211_iter_keys(struct ieee8021
 	}
 	mutex_unlock(&local->key_mtx);
 }
-EXPORT_SYMBOL(ieee80211_iter_keys);
+EXPORT_SYMBOL(ieee80211_iter_keys_dup);
 
 static void ieee80211_free_keys_iface(struct ieee80211_sub_if_data *sdata,
 				      struct list_head *keys)
@@ -713,18 +713,18 @@ void ieee80211_delayed_tailroom_dec(stru
 	mutex_unlock(&sdata->local->key_mtx);
 }
 
-void ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,
+void ieee80211_gtk_rekey_notify_dup(struct ieee80211_vif *vif, const u8 *bssid,
 				const u8 *replay_ctr, gfp_t gfp)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 
 	trace_api_gtk_rekey_notify(sdata, bssid, replay_ctr);
 
-	cfg80211_gtk_rekey_notify(sdata->dev, bssid, replay_ctr, gfp);
+	cfg80211_gtk_rekey_notify_dup(sdata->dev, bssid, replay_ctr, gfp);
 }
-EXPORT_SYMBOL_GPL(ieee80211_gtk_rekey_notify);
+EXPORT_SYMBOL_GPL(ieee80211_gtk_rekey_notify_dup);
 
-void ieee80211_get_key_tx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_key_tx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      struct ieee80211_key_seq *seq)
 {
 	struct ieee80211_key *key;
@@ -762,9 +762,9 @@ void ieee80211_get_key_tx_seq(struct iee
 		WARN_ON(1);
 	}
 }
-EXPORT_SYMBOL(ieee80211_get_key_tx_seq);
+EXPORT_SYMBOL(ieee80211_get_key_tx_seq_dup);
 
-void ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_key_rx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      int tid, struct ieee80211_key_seq *seq)
 {
 	struct ieee80211_key *key;
@@ -796,9 +796,9 @@ void ieee80211_get_key_rx_seq(struct iee
 		break;
 	}
 }
-EXPORT_SYMBOL(ieee80211_get_key_rx_seq);
+EXPORT_SYMBOL(ieee80211_get_key_rx_seq_dup);
 
-void ieee80211_set_key_tx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_set_key_tx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      struct ieee80211_key_seq *seq)
 {
 	struct ieee80211_key *key;
@@ -834,9 +834,9 @@ void ieee80211_set_key_tx_seq(struct iee
 		break;
 	}
 }
-EXPORT_SYMBOL_GPL(ieee80211_set_key_tx_seq);
+EXPORT_SYMBOL_GPL(ieee80211_set_key_tx_seq_dup);
 
-void ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_set_key_rx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      int tid, struct ieee80211_key_seq *seq)
 {
 	struct ieee80211_key *key;
@@ -871,9 +871,9 @@ void ieee80211_set_key_rx_seq(struct iee
 		break;
 	}
 }
-EXPORT_SYMBOL_GPL(ieee80211_set_key_rx_seq);
+EXPORT_SYMBOL_GPL(ieee80211_set_key_rx_seq_dup);
 
-void ieee80211_remove_key(struct ieee80211_key_conf *keyconf)
+void ieee80211_remove_key_dup(struct ieee80211_key_conf *keyconf)
 {
 	struct ieee80211_key *key;
 
@@ -896,10 +896,10 @@ void ieee80211_remove_key(struct ieee802
 
 	ieee80211_key_free(key, false);
 }
-EXPORT_SYMBOL_GPL(ieee80211_remove_key);
+EXPORT_SYMBOL_GPL(ieee80211_remove_key_dup);
 
 struct ieee80211_key_conf *
-ieee80211_gtk_rekey_add(struct ieee80211_vif *vif,
+ieee80211_gtk_rekey_add_dup(struct ieee80211_vif *vif,
 			struct ieee80211_key_conf *keyconf)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
@@ -928,4 +928,4 @@ ieee80211_gtk_rekey_add(struct ieee80211
 
 	return &key->conf;
 }
-EXPORT_SYMBOL_GPL(ieee80211_gtk_rekey_add);
+EXPORT_SYMBOL_GPL(ieee80211_gtk_rekey_add_dup);
--- a/net/mac80211/led.c	2015-06-23 11:07:42.825850677 +0200
+++ b/net/mac80211/led.c	2015-06-23 14:54:15.726850381 +0200
@@ -148,37 +148,37 @@ void ieee80211_led_exit(struct ieee80211
 	}
 }
 
-char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw)
+char *__ieee80211_get_radio_led_name_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
 	return local->radio_led_name;
 }
-EXPORT_SYMBOL(__ieee80211_get_radio_led_name);
+EXPORT_SYMBOL(__ieee80211_get_radio_led_name_dup);
 
-char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)
+char *__ieee80211_get_assoc_led_name_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
 	return local->assoc_led_name;
 }
-EXPORT_SYMBOL(__ieee80211_get_assoc_led_name);
+EXPORT_SYMBOL(__ieee80211_get_assoc_led_name_dup);
 
-char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw)
+char *__ieee80211_get_tx_led_name_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
 	return local->tx_led_name;
 }
-EXPORT_SYMBOL(__ieee80211_get_tx_led_name);
+EXPORT_SYMBOL(__ieee80211_get_tx_led_name_dup);
 
-char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw)
+char *__ieee80211_get_rx_led_name_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
 	return local->rx_led_name;
 }
-EXPORT_SYMBOL(__ieee80211_get_rx_led_name);
+EXPORT_SYMBOL(__ieee80211_get_rx_led_name_dup);
 
 static unsigned long tpt_trig_traffic(struct ieee80211_local *local,
 				      struct tpt_led_trigger *tpt_trig)
@@ -226,7 +226,7 @@ static void tpt_trig_timer(unsigned long
 	read_unlock(&tpt_trig->trig.leddev_list_lock);
 }
 
-char *__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,
+char *__ieee80211_create_tpt_led_trigger_dup(struct ieee80211_hw *hw,
 				unsigned int flags,
 				const struct ieee80211_tpt_blink *blink_table,
 				unsigned int blink_table_len)
@@ -256,7 +256,7 @@ char *__ieee80211_create_tpt_led_trigger
 
 	return tpt_trig->name;
 }
-EXPORT_SYMBOL(__ieee80211_create_tpt_led_trigger);
+EXPORT_SYMBOL(__ieee80211_create_tpt_led_trigger_dup);
 
 static void ieee80211_start_tpt_led_trig(struct ieee80211_local *local)
 {
--- a/net/mac80211/main.c	2015-06-23 11:07:42.826850689 +0200
+++ b/net/mac80211/main.c	2015-06-23 14:54:15.776850605 +0200
@@ -116,7 +116,7 @@ static u32 ieee80211_hw_conf_chan(struct
 	} else
 		chandef = local->_oper_chandef;
 
-	WARN(!cfg80211_chandef_valid(&chandef),
+	WARN(!cfg80211_chandef_valid_dup(&chandef),
 	     "control:%d MHz width:%d center: %d/%d MHz",
 	     chandef.chan->center_freq, chandef.width,
 	     chandef.center_freq1, chandef.center_freq2);
@@ -230,15 +230,15 @@ static void ieee80211_tasklet_handler(un
 	while ((skb = skb_dequeue(&local->skb_queue)) ||
 	       (skb = skb_dequeue(&local->skb_queue_unreliable))) {
 		switch (skb->pkt_type) {
-		case IEEE80211_RX_MSG:
+		case ieee80211_rx_MSG:
 			/* Clear skb->pkt_type in order to not confuse kernel
 			 * netstack. */
 			skb->pkt_type = 0;
-			ieee80211_rx(&local->hw, skb);
+			ieee80211_rx_dup(&local->hw, skb);
 			break;
-		case IEEE80211_TX_STATUS_MSG:
+		case ieee80211_tx_status_MSG:
 			skb->pkt_type = 0;
-			ieee80211_tx_status(&local->hw, skb);
+			ieee80211_tx_status_dup(&local->hw, skb);
 			break;
 		default:
 			WARN(1, "mac80211: Packet is of unknown type %d\n",
@@ -266,7 +266,7 @@ static void ieee80211_restart_work(struc
 	rtnl_unlock();
 }
 
-void ieee80211_restart_hw(struct ieee80211_hw *hw)
+void ieee80211_restart_hw_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
@@ -276,7 +276,7 @@ void ieee80211_restart_hw(struct ieee802
 		   "Hardware restart was requested\n");
 
 	/* use this reason, ieee80211_reconfig will unblock it */
-	ieee80211_stop_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,
+	ieee80211_stop_queues_by_reason_dup(hw, IEEE80211_MAX_QUEUE_MAP,
 					IEEE80211_QUEUE_STOP_REASON_SUSPEND,
 					false);
 
@@ -289,7 +289,7 @@ void ieee80211_restart_hw(struct ieee802
 
 	schedule_work(&local->restart_work);
 }
-EXPORT_SYMBOL(ieee80211_restart_hw);
+EXPORT_SYMBOL(ieee80211_restart_hw_dup);
 
 #ifdef CONFIG_INET
 static int ieee80211_ifa_changed(struct notifier_block *nb,
@@ -482,7 +482,7 @@ static const struct ieee80211_vht_cap ma
 	},
 };
 
-struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
+struct ieee80211_hw *ieee80211_alloc_hw_nm_dup(size_t priv_data_len,
 					   const struct ieee80211_ops *ops,
 					   const char *requested_name)
 {
@@ -524,7 +524,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
 	 */
 	priv_size = ALIGN(sizeof(*local), NETDEV_ALIGN) + priv_data_len;
 
-	wiphy = wiphy_new_nm(&mac80211_config_ops, priv_size, requested_name);
+	wiphy = wiphy_new_nm_dup(&mac80211_config_ops, priv_size, requested_name);
 
 	if (!wiphy)
 		return NULL;
@@ -657,7 +657,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
 
 	return &local->hw;
 }
-EXPORT_SYMBOL(ieee80211_alloc_hw_nm);
+EXPORT_SYMBOL(ieee80211_alloc_hw_nm_dup);
 
 static int ieee80211_init_cipher_suites(struct ieee80211_local *local)
 {
@@ -755,7 +755,7 @@ static int ieee80211_init_cipher_suites(
 	return 0;
 }
 
-int ieee80211_register_hw(struct ieee80211_hw *hw)
+int ieee80211_register_hw_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 	int result, i;
@@ -839,7 +839,7 @@ int ieee80211_register_hw(struct ieee802
 			continue;
 
 		if (!dflt_chandef.chan) {
-			cfg80211_chandef_create(&dflt_chandef,
+			cfg80211_chandef_create_dup(&dflt_chandef,
 						&sband->channels[0],
 						NL80211_CHAN_NO_HT);
 			/* init channel we're on */
@@ -918,7 +918,7 @@ int ieee80211_register_hw(struct ieee802
 		local->hw.wiphy->signal_type = CFG80211_SIGNAL_TYPE_UNSPEC;
 		if (hw->max_signal <= 0) {
 			result = -EINVAL;
-			goto fail_wiphy_register;
+			goto fail_wiphy_register_dup;
 		}
 	}
 
@@ -958,7 +958,7 @@ int ieee80211_register_hw(struct ieee802
 
 	result = ieee80211_init_cipher_suites(local);
 	if (result < 0)
-		goto fail_wiphy_register;
+		goto fail_wiphy_register_dup;
 
 	if (!local->ops->remain_on_channel)
 		local->hw.wiphy->max_remain_on_channel_duration = 5000;
@@ -973,9 +973,9 @@ int ieee80211_register_hw(struct ieee802
 
 	local->hw.wiphy->max_num_csa_counters = IEEE80211_MAX_CSA_COUNTERS_NUM;
 
-	result = wiphy_register(local->hw.wiphy);
+	result = wiphy_register_dup(local->hw.wiphy);
 	if (result < 0)
-		goto fail_wiphy_register;
+		goto fail_wiphy_register_dup;
 
 	/*
 	 * We use the number of queues for feature tests (QoS, HT) internally
@@ -997,7 +997,7 @@ int ieee80211_register_hw(struct ieee802
 	 * interfaces, but never both at the same time.
 	 */
 	local->tx_headroom = max_t(unsigned int , local->hw.extra_tx_headroom,
-				   IEEE80211_TX_STATUS_HEADROOM);
+				   ieee80211_tx_status_HEADROOM);
 
 	debugfs_hw_add(local);
 
@@ -1089,16 +1089,16 @@ int ieee80211_register_hw(struct ieee802
 	sta_info_stop(local);
 	destroy_workqueue(local->workqueue);
  fail_workqueue:
-	wiphy_unregister(local->hw.wiphy);
- fail_wiphy_register:
+	wiphy_unregister_dup(local->hw.wiphy);
+ fail_wiphy_register_dup:
 	if (local->wiphy_ciphers_allocated)
 		kfree(local->hw.wiphy->cipher_suites);
 	kfree(local->int_scan_req);
 	return result;
 }
-EXPORT_SYMBOL(ieee80211_register_hw);
+EXPORT_SYMBOL(ieee80211_register_hw_dup);
 
-void ieee80211_napi_add(struct ieee80211_hw *hw, struct napi_struct *napi,
+void ieee80211_napi_add_dup(struct ieee80211_hw *hw, struct napi_struct *napi,
 			struct net_device *napi_dev,
 			int (*poll)(struct napi_struct *, int),
 			int weight)
@@ -1108,9 +1108,9 @@ void ieee80211_napi_add(struct ieee80211
 	netif_napi_add(napi_dev, napi, poll, weight);
 	local->napi = napi;
 }
-EXPORT_SYMBOL_GPL(ieee80211_napi_add);
+EXPORT_SYMBOL_GPL(ieee80211_napi_add_dup);
 
-void ieee80211_unregister_hw(struct ieee80211_hw *hw)
+void ieee80211_unregister_hw_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
@@ -1151,13 +1151,13 @@ void ieee80211_unregister_hw(struct ieee
 	skb_queue_purge(&local->skb_queue_unreliable);
 
 	destroy_workqueue(local->workqueue);
-	wiphy_unregister(local->hw.wiphy);
+	wiphy_unregister_dup(local->hw.wiphy);
 	sta_info_stop(local);
 	ieee80211_wep_free(local);
 	ieee80211_led_exit(local);
 	kfree(local->int_scan_req);
 }
-EXPORT_SYMBOL(ieee80211_unregister_hw);
+EXPORT_SYMBOL(ieee80211_unregister_hw_dup);
 
 static int ieee80211_free_ack_frame(int id, void *p, void *data)
 {
@@ -1166,7 +1166,7 @@ static int ieee80211_free_ack_frame(int
 	return 0;
 }
 
-void ieee80211_free_hw(struct ieee80211_hw *hw)
+void ieee80211_free_hw_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
@@ -1182,9 +1182,9 @@ void ieee80211_free_hw(struct ieee80211_
 
 	kfree(rcu_access_pointer(local->tx_latency));
 
-	wiphy_free(local->hw.wiphy);
+	wiphy_free_dup(local->hw.wiphy);
 }
-EXPORT_SYMBOL(ieee80211_free_hw);
+EXPORT_SYMBOL(ieee80211_free_hw_dup);
 
 static int __init ieee80211_init(void)
 {
--- a/net/mac80211/mesh.c	2015-06-23 11:07:42.826850689 +0200
+++ b/net/mac80211/mesh.c	2015-06-23 14:54:15.828850839 +0200
@@ -47,7 +47,7 @@ static void ieee80211_mesh_housekeeping_
 
 	set_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags);
 
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 }
 
 /**
@@ -94,7 +94,7 @@ bool mesh_matches_local(struct ieee80211
 	ieee80211_ht_oper_to_chandef(sdata->vif.bss_conf.chandef.chan,
 				     ie->ht_operation, &sta_chan_def);
 
-	if (!cfg80211_chandef_compatible(&sdata->vif.bss_conf.chandef,
+	if (!cfg80211_chandef_compatible_dup(&sdata->vif.bss_conf.chandef,
 					 &sta_chan_def))
 		return false;
 
@@ -366,7 +366,7 @@ int mesh_add_rsn_ie(struct ieee80211_sub
 		return 0;
 
 	/* find RSN IE */
-	data = cfg80211_find_ie(WLAN_EID_RSN, ifmsh->ie, ifmsh->ie_len);
+	data = cfg80211_find_ie_dup(WLAN_EID_RSN, ifmsh->ie, ifmsh->ie_len);
 	if (!data)
 		return 0;
 
@@ -401,7 +401,7 @@ static int mesh_add_ds_params_ie(struct
 	pos = skb_put(skb, 2 + 1);
 	*pos++ = WLAN_EID_DS_PARAMS;
 	*pos++ = 1;
-	*pos++ = ieee80211_frequency_to_channel(chan->center_freq);
+	*pos++ = ieee80211_frequency_to_channel_dup(chan->center_freq);
 
 	return 0;
 }
@@ -472,7 +472,7 @@ static void ieee80211_mesh_path_timer(un
 	struct ieee80211_sub_if_data *sdata =
 		(struct ieee80211_sub_if_data *) data;
 
-	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&sdata->local->hw, &sdata->work);
 }
 
 static void ieee80211_mesh_path_root_timer(unsigned long data)
@@ -483,7 +483,7 @@ static void ieee80211_mesh_path_root_tim
 
 	set_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);
 
-	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&sdata->local->hw, &sdata->work);
 }
 
 void ieee80211_mesh_root_setup(struct ieee80211_if_mesh *ifmsh)
@@ -677,7 +677,7 @@ ieee80211_mesh_build_beacon(struct ieee8
 		*pos++ = WLAN_EID_CHANNEL_SWITCH;
 		*pos++ = 3;
 		*pos++ = 0x0;
-		*pos++ = ieee80211_frequency_to_channel(
+		*pos++ = ieee80211_frequency_to_channel_dup(
 				csa->settings.chandef.chan->center_freq);
 		bcn->csa_counter_offsets[0] = hdr_len + 6;
 		*pos++ = csa->settings.count;
@@ -765,7 +765,7 @@ void ieee80211_mbss_info_change_notify(s
 	for_each_set_bit(bit, &bits, sizeof(changed) * BITS_PER_BYTE)
 		set_bit(bit, &ifmsh->mbss_changed);
 	set_bit(MESH_WORK_MBSS_CHANGED, &ifmsh->wrkq_flags);
-	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&sdata->local->hw, &sdata->work);
 }
 
 int ieee80211_start_mesh(struct ieee80211_sub_if_data *sdata)
@@ -790,7 +790,7 @@ int ieee80211_start_mesh(struct ieee8021
 	ifmsh->sync_offset_clockdrift_max = 0;
 	set_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags);
 	ieee80211_mesh_root_setup(ifmsh);
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 	sdata->vif.bss_conf.ht_operation_mode =
 				ifmsh->mshcfg.ht_opmode;
 	sdata->vif.bss_conf.enable_beacon = true;
@@ -885,7 +885,7 @@ ieee80211_mesh_process_chnswitch(struct
 	params.chandef = csa_ie.chandef;
 	params.count = csa_ie.count;
 
-	if (!cfg80211_chandef_usable(sdata->local->hw.wiphy, &params.chandef,
+	if (!cfg80211_chandef_usable_dup(sdata->local->hw.wiphy, &params.chandef,
 				     IEEE80211_CHAN_DISABLED)) {
 		sdata_info(sdata,
 			   "mesh STA %pM switches to unsupported channel (%d MHz, width:%d, CF1/2: %d/%d MHz), aborting\n",
@@ -897,7 +897,7 @@ ieee80211_mesh_process_chnswitch(struct
 		return false;
 	}
 
-	err = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,
+	err = cfg80211_chandef_dfs_required_dup(sdata->local->hw.wiphy,
 					    &params.chandef,
 					    NL80211_IFTYPE_MESH_POINT);
 	if (err < 0)
@@ -1030,7 +1030,7 @@ static void ieee80211_mesh_rx_bcn_presp(
 		return;
 
 	if (elems.ds_params)
-		freq = ieee80211_channel_to_frequency(elems.ds_params[0], band);
+		freq = ieee80211_channel_to_frequency_dup(elems.ds_params[0], band);
 	else
 		freq = rx_status->freq;
 
@@ -1305,7 +1305,7 @@ void ieee80211_mesh_notify_scan_complete
 	list_for_each_entry_rcu(sdata, &local->interfaces, list)
 		if (ieee80211_vif_is_mesh(&sdata->vif) &&
 		    ieee80211_sdata_running(sdata))
-			ieee80211_queue_work(&local->hw, &sdata->work);
+			ieee80211_queue_work_dup(&local->hw, &sdata->work);
 	rcu_read_unlock();
 }
 
--- a/net/mac80211/mesh_hwmp.c	2015-06-23 11:07:42.826850689 +0200
+++ b/net/mac80211/mesh_hwmp.c	2015-06-23 14:54:15.926851279 +0200
@@ -337,7 +337,7 @@ static u32 airtime_link_metric_get(struc
 		return MAX_METRIC;
 
 	sta_set_rate_info_tx(sta, &sta->last_tx_rate, &rinfo);
-	rate = cfg80211_calculate_bitrate(&rinfo);
+	rate = cfg80211_calculate_bitrate_dup(&rinfo);
 	if (WARN_ON(!rate))
 		return MAX_METRIC;
 
@@ -952,14 +952,14 @@ static void mesh_queue_preq(struct mesh_
 	spin_unlock_bh(&ifmsh->mesh_preq_queue_lock);
 
 	if (time_after(jiffies, ifmsh->last_preq + min_preq_int_jiff(sdata)))
-		ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+		ieee80211_queue_work_dup(&sdata->local->hw, &sdata->work);
 
 	else if (time_before(jiffies, ifmsh->last_preq)) {
 		/* avoid long wait if did not send preqs for a long time
 		 * and jiffies wrapped around
 		 */
 		ifmsh->last_preq = jiffies - min_preq_int_jiff(sdata) - 1;
-		ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+		ieee80211_queue_work_dup(&sdata->local->hw, &sdata->work);
 	} else
 		mod_timer(&ifmsh->mesh_path_timer, ifmsh->last_preq +
 						min_preq_int_jiff(sdata));
--- a/net/mac80211/mesh_pathtbl.c	2015-06-23 11:07:42.826850689 +0200
+++ b/net/mac80211/mesh_pathtbl.c	2015-06-23 14:54:15.981851526 +0200
@@ -231,7 +231,7 @@ static void prepare_for_gate(struct sk_b
 	char *next_hop;
 
 	hdr = (struct ieee80211_hdr *) skb->data;
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 	mshdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);
 
 	if (!(mshdr->flags & MESH_FLAGS_AE)) {
@@ -592,7 +592,7 @@ struct mesh_path *mesh_path_add(struct i
 
 	if (grow) {
 		set_bit(MESH_WORK_GROW_MPATH_TABLE,  &ifmsh->wrkq_flags);
-		ieee80211_queue_work(&local->hw, &sdata->work);
+		ieee80211_queue_work_dup(&local->hw, &sdata->work);
 	}
 	mpath = new_mpath;
 found:
@@ -724,7 +724,7 @@ int mpp_path_add(struct ieee80211_sub_if
 
 	if (grow) {
 		set_bit(MESH_WORK_GROW_MPP_TABLE,  &ifmsh->wrkq_flags);
-		ieee80211_queue_work(&local->hw, &sdata->work);
+		ieee80211_queue_work_dup(&local->hw, &sdata->work);
 	}
 	return 0;
 
--- a/net/mac80211/mesh_plink.c	2015-06-23 11:07:42.827850700 +0200
+++ b/net/mac80211/mesh_plink.c	2015-06-23 14:54:16.026851728 +0200
@@ -449,7 +449,7 @@ mesh_sta_info_alloc(struct ieee80211_sub
 	/* Userspace handles station allocation */
 	if (sdata->u.mesh.user_mpm ||
 	    sdata->u.mesh.security & IEEE80211_MESH_SEC_AUTHED)
-		cfg80211_notify_new_peer_candidate(sdata->dev, addr,
+		cfg80211_notify_new_peer_candidate_dup(sdata->dev, addr,
 						   elems->ie_start,
 						   elems->total_len,
 						   GFP_KERNEL);
--- a/net/mac80211/mlme.c	2015-06-23 11:07:42.828850712 +0200
+++ b/net/mac80211/mlme.c	2015-06-23 14:54:16.118852142 +0200
@@ -178,7 +178,7 @@ ieee80211_determine_chantype(struct ieee
 		goto out;
 	}
 
-	ht_cfreq = ieee80211_channel_to_frequency(ht_oper->primary_chan,
+	ht_cfreq = ieee80211_channel_to_frequency_dup(ht_oper->primary_chan,
 						  channel->band);
 	/* check that channel matches the right operating channel */
 	if (!tracking && channel->center_freq != ht_cfreq) {
@@ -224,7 +224,7 @@ ieee80211_determine_chantype(struct ieee
 
 	vht_chandef.chan = channel;
 	vht_chandef.center_freq1 =
-		ieee80211_channel_to_frequency(vht_oper->center_freq_seg1_idx,
+		ieee80211_channel_to_frequency_dup(vht_oper->center_freq_seg1_idx,
 					       channel->band);
 	vht_chandef.center_freq2 = 0;
 
@@ -242,7 +242,7 @@ ieee80211_determine_chantype(struct ieee
 	case IEEE80211_VHT_CHANWIDTH_80P80MHZ:
 		vht_chandef.width = NL80211_CHAN_WIDTH_80P80;
 		vht_chandef.center_freq2 =
-			ieee80211_channel_to_frequency(
+			ieee80211_channel_to_frequency_dup(
 				vht_oper->center_freq_seg2_idx,
 				channel->band);
 		break;
@@ -255,7 +255,7 @@ ieee80211_determine_chantype(struct ieee
 		goto out;
 	}
 
-	if (!cfg80211_chandef_valid(&vht_chandef)) {
+	if (!cfg80211_chandef_valid_dup(&vht_chandef)) {
 		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 			sdata_info(sdata,
 				   "AP VHT information is invalid, disable VHT\n");
@@ -268,7 +268,7 @@ ieee80211_determine_chantype(struct ieee
 		goto out;
 	}
 
-	if (!cfg80211_chandef_compatible(chandef, &vht_chandef)) {
+	if (!cfg80211_chandef_compatible_dup(chandef, &vht_chandef)) {
 		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
 			sdata_info(sdata,
 				   "AP VHT information doesn't match HT, disable VHT\n");
@@ -315,7 +315,7 @@ out:
 	 * information we have is wrong/outdated and disables the channel
 	 * that we're actually using for the connection to the AP.
 	 */
-	while (!cfg80211_chandef_usable(sdata->local->hw.wiphy, chandef,
+	while (!cfg80211_chandef_usable_dup(sdata->local->hw.wiphy, chandef,
 					tracking ? 0 :
 						   IEEE80211_CHAN_DISABLED)) {
 		if (WARN_ON(chandef->width == NL80211_CHAN_WIDTH_20_NOHT)) {
@@ -331,7 +331,7 @@ out:
 		sdata_info(sdata,
 			   "capabilities/regulatory prevented using AP HT/VHT configuration, downgraded\n");
 
-	WARN_ON_ONCE(!cfg80211_chandef_valid(chandef));
+	WARN_ON_ONCE(!cfg80211_chandef_valid_dup(chandef));
 	return ret;
 }
 
@@ -411,7 +411,7 @@ static int ieee80211_config_bw(struct ie
 				      IEEE80211_STA_DISABLE_40MHZ |
 				      IEEE80211_STA_DISABLE_80P80MHZ |
 				      IEEE80211_STA_DISABLE_160MHZ)) ||
-	    !cfg80211_chandef_valid(&chandef)) {
+	    !cfg80211_chandef_valid_dup(&chandef)) {
 		sdata_info(sdata,
 			   "AP %pM changed bandwidth in a way we can't support - disconnect\n",
 			   ifmgd->bssid);
@@ -762,7 +762,7 @@ static void ieee80211_send_assoc(struct
 		*pos++ = WLAN_EID_SUPPORTED_CHANNELS;
 		*pos++ = 2 * sband->n_channels;
 		for (i = 0; i < sband->n_channels; i++) {
-			*pos++ = ieee80211_frequency_to_channel(
+			*pos++ = ieee80211_frequency_to_channel_dup(
 					sband->channels[i].center_freq);
 			*pos++ = 1; /* one channel in the subband*/
 		}
@@ -839,7 +839,7 @@ static void ieee80211_send_assoc(struct
 		};
 
 		/* RIC already taken above, so no need to handle here anymore */
-		noffset = ieee80211_ie_split(assoc_data->ie, assoc_data->ie_len,
+		noffset = ieee80211_ie_split_dup(assoc_data->ie, assoc_data->ie_len,
 					     before_vht, ARRAY_SIZE(before_vht),
 					     offset);
 		pos = skb_put(skb, noffset - offset);
@@ -895,7 +895,7 @@ void ieee80211_send_pspoll(struct ieee80
 	struct ieee80211_pspoll *pspoll;
 	struct sk_buff *skb;
 
-	skb = ieee80211_pspoll_get(&local->hw, &sdata->vif);
+	skb = ieee80211_pspoll_get_dup(&local->hw, &sdata->vif);
 	if (!skb)
 		return;
 
@@ -914,7 +914,7 @@ void ieee80211_send_nullfunc(struct ieee
 	struct ieee80211_hdr_3addr *nullfunc;
 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
 
-	skb = ieee80211_nullfunc_get(&local->hw, &sdata->vif);
+	skb = ieee80211_nullfunc_get_dup(&local->hw, &sdata->vif);
 	if (!skb)
 		return;
 
@@ -995,7 +995,7 @@ static void ieee80211_chswitch_work(stru
 
 	if (sdata->reserved_chanctx) {
 		/*
-		 * with multi-vif csa driver may call ieee80211_csa_finish()
+		 * with multi-vif csa driver may call ieee80211_csa_finish_dup()
 		 * many times while waiting for other interfaces to use their
 		 * reservations
 		 */
@@ -1007,7 +1007,7 @@ static void ieee80211_chswitch_work(stru
 			sdata_info(sdata,
 				   "failed to use reserved channel context, disconnecting (err=%d)\n",
 				   ret);
-			ieee80211_queue_work(&sdata->local->hw,
+			ieee80211_queue_work_dup(&sdata->local->hw,
 					     &ifmgd->csa_connection_drop_work);
 			goto out;
 		}
@@ -1019,7 +1019,7 @@ static void ieee80211_chswitch_work(stru
 					&sdata->csa_chandef)) {
 		sdata_info(sdata,
 			   "failed to finalize channel switch, disconnecting\n");
-		ieee80211_queue_work(&sdata->local->hw,
+		ieee80211_queue_work_dup(&sdata->local->hw,
 				     &ifmgd->csa_connection_drop_work);
 		goto out;
 	}
@@ -1061,15 +1061,15 @@ static void ieee80211_chswitch_post_beac
 	if (ret) {
 		sdata_info(sdata,
 			   "driver post channel switch failed, disconnecting\n");
-		ieee80211_queue_work(&local->hw,
+		ieee80211_queue_work_dup(&local->hw,
 				     &ifmgd->csa_connection_drop_work);
 		return;
 	}
 
-	cfg80211_ch_switch_notify(sdata->dev, &sdata->reserved_chandef);
+	cfg80211_ch_switch_notify_dup(sdata->dev, &sdata->reserved_chandef);
 }
 
-void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success)
+void ieee80211_chswitch_done_dup(struct ieee80211_vif *vif, bool success)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
@@ -1078,20 +1078,20 @@ void ieee80211_chswitch_done(struct ieee
 	if (!success) {
 		sdata_info(sdata,
 			   "driver channel switch failed, disconnecting\n");
-		ieee80211_queue_work(&sdata->local->hw,
+		ieee80211_queue_work_dup(&sdata->local->hw,
 				     &ifmgd->csa_connection_drop_work);
 	} else {
-		ieee80211_queue_work(&sdata->local->hw, &ifmgd->chswitch_work);
+		ieee80211_queue_work_dup(&sdata->local->hw, &ifmgd->chswitch_work);
 	}
 }
-EXPORT_SYMBOL(ieee80211_chswitch_done);
+EXPORT_SYMBOL(ieee80211_chswitch_done_dup);
 
 static void ieee80211_chswitch_timer(unsigned long data)
 {
 	struct ieee80211_sub_if_data *sdata =
 		(struct ieee80211_sub_if_data *) data;
 
-	ieee80211_queue_work(&sdata->local->hw, &sdata->u.mgd.chswitch_work);
+	ieee80211_queue_work_dup(&sdata->local->hw, &sdata->u.mgd.chswitch_work);
 }
 
 static void
@@ -1128,12 +1128,12 @@ ieee80211_sta_process_chanswitch(struct
 					   ifmgd->flags,
 					   ifmgd->associated->bssid, &csa_ie);
 	if (res	< 0)
-		ieee80211_queue_work(&local->hw,
+		ieee80211_queue_work_dup(&local->hw,
 				     &ifmgd->csa_connection_drop_work);
 	if (res)
 		return;
 
-	if (!cfg80211_chandef_usable(local->hw.wiphy, &csa_ie.chandef,
+	if (!cfg80211_chandef_usable_dup(local->hw.wiphy, &csa_ie.chandef,
 				     IEEE80211_CHAN_DISABLED)) {
 		sdata_info(sdata,
 			   "AP %pM switches to unsupported channel (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\n",
@@ -1141,7 +1141,7 @@ ieee80211_sta_process_chanswitch(struct
 			   csa_ie.chandef.chan->center_freq,
 			   csa_ie.chandef.width, csa_ie.chandef.center_freq1,
 			   csa_ie.chandef.center_freq2);
-		ieee80211_queue_work(&local->hw,
+		ieee80211_queue_work_dup(&local->hw,
 				     &ifmgd->csa_connection_drop_work);
 		return;
 	}
@@ -1153,7 +1153,7 @@ ieee80211_sta_process_chanswitch(struct
 	if (!conf) {
 		sdata_info(sdata,
 			   "no channel context assigned to vif?, disconnecting\n");
-		ieee80211_queue_work(&local->hw,
+		ieee80211_queue_work_dup(&local->hw,
 				     &ifmgd->csa_connection_drop_work);
 		mutex_unlock(&local->chanctx_mtx);
 		mutex_unlock(&local->mtx);
@@ -1166,7 +1166,7 @@ ieee80211_sta_process_chanswitch(struct
 	    !(local->hw.flags & IEEE80211_HW_CHANCTX_STA_CSA)) {
 		sdata_info(sdata,
 			   "driver doesn't support chan-switch with channel contexts\n");
-		ieee80211_queue_work(&local->hw,
+		ieee80211_queue_work_dup(&local->hw,
 				     &ifmgd->csa_connection_drop_work);
 		mutex_unlock(&local->chanctx_mtx);
 		mutex_unlock(&local->mtx);
@@ -1182,7 +1182,7 @@ ieee80211_sta_process_chanswitch(struct
 	if (drv_pre_channel_switch(sdata, &ch_switch)) {
 		sdata_info(sdata,
 			   "preparing for channel switch failed, disconnecting\n");
-		ieee80211_queue_work(&local->hw,
+		ieee80211_queue_work_dup(&local->hw,
 				     &ifmgd->csa_connection_drop_work);
 		mutex_unlock(&local->chanctx_mtx);
 		mutex_unlock(&local->mtx);
@@ -1195,7 +1195,7 @@ ieee80211_sta_process_chanswitch(struct
 		sdata_info(sdata,
 			   "failed to reserve channel context for channel switch, disconnecting (err=%d)\n",
 			   res);
-		ieee80211_queue_work(&local->hw,
+		ieee80211_queue_work_dup(&local->hw,
 				     &ifmgd->csa_connection_drop_work);
 		mutex_unlock(&local->chanctx_mtx);
 		mutex_unlock(&local->mtx);
@@ -1212,7 +1212,7 @@ ieee80211_sta_process_chanswitch(struct
 					  IEEE80211_QUEUE_STOP_REASON_CSA);
 	mutex_unlock(&local->mtx);
 
-	cfg80211_ch_switch_started_notify(sdata->dev, &csa_ie.chandef,
+	cfg80211_ch_switch_started_notify_dup(sdata->dev, &csa_ie.chandef,
 					  csa_ie.count);
 
 	if (local->ops->channel_switch) {
@@ -1223,7 +1223,7 @@ ieee80211_sta_process_chanswitch(struct
 
 	/* channel switch handled in software */
 	if (csa_ie.count <= 1)
-		ieee80211_queue_work(&local->hw, &ifmgd->chswitch_work);
+		ieee80211_queue_work_dup(&local->hw, &ifmgd->chswitch_work);
 	else
 		mod_timer(&ifmgd->chswitch_timer,
 			  TU_TO_EXP_TIME((csa_ie.count - 1) *
@@ -1238,7 +1238,7 @@ ieee80211_find_80211h_pwr_constr(struct
 				 int *chan_pwr, int *pwr_reduction)
 {
 	struct ieee80211_country_ie_triplet *triplet;
-	int chan = ieee80211_frequency_to_channel(channel->center_freq);
+	int chan = ieee80211_frequency_to_channel_dup(channel->center_freq);
 	int i, chan_increment;
 	bool have_chan_pwr = false;
 
@@ -1534,7 +1534,7 @@ void ieee80211_dynamic_ps_disable_work(s
 		ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);
 	}
 
-	ieee80211_wake_queues_by_reason(&local->hw,
+	ieee80211_wake_queues_by_reason_dup(&local->hw,
 					IEEE80211_MAX_QUEUE_MAP,
 					IEEE80211_QUEUE_STOP_REASON_PS,
 					false);
@@ -1616,7 +1616,7 @@ void ieee80211_dynamic_ps_timer(unsigned
 	if (local->quiescing || local->suspended)
 		return;
 
-	ieee80211_queue_work(&local->hw, &local->dynamic_ps_enable_work);
+	ieee80211_queue_work_dup(&local->hw, &local->dynamic_ps_enable_work);
 }
 
 void ieee80211_dfs_cac_timer_work(struct work_struct *work)
@@ -1631,7 +1631,7 @@ void ieee80211_dfs_cac_timer_work(struct
 	mutex_lock(&sdata->local->mtx);
 	if (sdata->wdev.cac_started) {
 		ieee80211_vif_release_channel(sdata);
-		cfg80211_cac_event(sdata->dev, &chandef,
+		cfg80211_cac_event_dup(sdata->dev, &chandef,
 				   NL80211_RADAR_CAC_FINISHED,
 				   GFP_KERNEL);
 	}
@@ -1911,7 +1911,7 @@ static void ieee80211_set_associated(str
 		if (ies) {
 			int ret;
 
-			ret = cfg80211_get_p2p_attr(
+			ret = cfg80211_get_p2p_attr_dup(
 					ies->data, ies->len,
 					IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
 					(u8 *) &bss_conf->p2p_noa_attr,
@@ -2186,7 +2186,7 @@ void ieee80211_sta_tx_notify(struct ieee
 			ieee80211_sta_reset_conn_monitor(sdata);
 		else
 			sdata->u.mgd.nullfunc_failed = true;
-		ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+		ieee80211_queue_work_dup(&sdata->local->hw, &sdata->work);
 		return;
 	}
 
@@ -2225,7 +2225,7 @@ static void ieee80211_mgd_probe_ap_send(
 		int ssid_len;
 
 		rcu_read_lock();
-		ssid = ieee80211_bss_get_ie(ifmgd->associated, WLAN_EID_SSID);
+		ssid = ieee80211_bss_get_ie_dup(ifmgd->associated, WLAN_EID_SSID);
 		if (WARN_ON_ONCE(ssid == NULL))
 			ssid_len = 0;
 		else
@@ -2268,7 +2268,7 @@ static void ieee80211_mgd_probe_ap(struc
 				     "detected beacon loss from AP (missed %d beacons) - probing\n",
 				     beacon_loss_count);
 
-		ieee80211_cqm_beacon_loss_notify(&sdata->vif, GFP_KERNEL);
+		ieee80211_cqm_beacon_loss_notify_dup(&sdata->vif, GFP_KERNEL);
 	}
 
 	/*
@@ -2302,7 +2302,7 @@ static void ieee80211_mgd_probe_ap(struc
 	sdata_unlock(sdata);
 }
 
-struct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_ap_probereq_get_dup(struct ieee80211_hw *hw,
 					  struct ieee80211_vif *vif)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
@@ -2327,7 +2327,7 @@ struct sk_buff *ieee80211_ap_probereq_ge
 		return NULL;
 
 	rcu_read_lock();
-	ssid = ieee80211_bss_get_ie(cbss, WLAN_EID_SSID);
+	ssid = ieee80211_bss_get_ie_dup(cbss, WLAN_EID_SSID);
 	if (WARN_ON_ONCE(ssid == NULL))
 		ssid_len = 0;
 	else
@@ -2341,7 +2341,7 @@ struct sk_buff *ieee80211_ap_probereq_ge
 
 	return skb;
 }
-EXPORT_SYMBOL(ieee80211_ap_probereq_get);
+EXPORT_SYMBOL(ieee80211_ap_probereq_get_dup);
 
 static void ieee80211_report_disconnect(struct ieee80211_sub_if_data *sdata,
 					const u8 *buf, size_t len, bool tx,
@@ -2354,9 +2354,9 @@ static void ieee80211_report_disconnect(
 	};
 
 	if (tx)
-		cfg80211_tx_mlme_mgmt(sdata->dev, buf, len);
+		cfg80211_tx_mlme_mgmt_dup(sdata->dev, buf, len);
 	else
-		cfg80211_rx_mlme_mgmt(sdata->dev, buf, len);
+		cfg80211_rx_mlme_mgmt_dup(sdata->dev, buf, len);
 
 	drv_event_callback(sdata->local, sdata, &event);
 }
@@ -2426,7 +2426,7 @@ static void ieee80211_csa_connection_dro
 	__ieee80211_disconnect(sdata);
 }
 
-void ieee80211_beacon_loss(struct ieee80211_vif *vif)
+void ieee80211_beacon_loss_dup(struct ieee80211_vif *vif)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct ieee80211_hw *hw = &sdata->local->hw;
@@ -2434,11 +2434,11 @@ void ieee80211_beacon_loss(struct ieee80
 	trace_api_beacon_loss(sdata);
 
 	sdata->u.mgd.connection_loss = false;
-	ieee80211_queue_work(hw, &sdata->u.mgd.beacon_connection_loss_work);
+	ieee80211_queue_work_dup(hw, &sdata->u.mgd.beacon_connection_loss_work);
 }
-EXPORT_SYMBOL(ieee80211_beacon_loss);
+EXPORT_SYMBOL(ieee80211_beacon_loss_dup);
 
-void ieee80211_connection_loss(struct ieee80211_vif *vif)
+void ieee80211_connection_loss_dup(struct ieee80211_vif *vif)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct ieee80211_hw *hw = &sdata->local->hw;
@@ -2446,9 +2446,9 @@ void ieee80211_connection_loss(struct ie
 	trace_api_connection_loss(sdata);
 
 	sdata->u.mgd.connection_loss = true;
-	ieee80211_queue_work(hw, &sdata->u.mgd.beacon_connection_loss_work);
+	ieee80211_queue_work_dup(hw, &sdata->u.mgd.beacon_connection_loss_work);
 }
-EXPORT_SYMBOL(ieee80211_connection_loss);
+EXPORT_SYMBOL(ieee80211_connection_loss_dup);
 
 
 static void ieee80211_destroy_auth_data(struct ieee80211_sub_if_data *sdata,
@@ -2469,7 +2469,7 @@ static void ieee80211_destroy_auth_data(
 		mutex_unlock(&sdata->local->mtx);
 	}
 
-	cfg80211_put_bss(sdata->local->hw.wiphy, auth_data->bss);
+	cfg80211_put_bss_dup(sdata->local->hw.wiphy, auth_data->bss);
 	kfree(auth_data);
 	sdata->u.mgd.auth_data = NULL;
 }
@@ -2541,7 +2541,7 @@ static void ieee80211_rx_mgmt_auth(struc
 		sdata_info(sdata, "%pM denied authentication (status %d)\n",
 			   mgmt->sa, status_code);
 		ieee80211_destroy_auth_data(sdata, false);
-		cfg80211_rx_mlme_mgmt(sdata->dev, (u8 *)mgmt, len);
+		cfg80211_rx_mlme_mgmt_dup(sdata->dev, (u8 *)mgmt, len);
 		event.u.mlme.status = MLME_DENIED;
 		event.u.mlme.reason = status_code;
 		drv_event_callback(sdata->local, sdata, &event);
@@ -2581,7 +2581,7 @@ static void ieee80211_rx_mgmt_auth(struc
 		 * Report auth frame to user space for processing since another
 		 * round of Authentication frames is still needed.
 		 */
-		cfg80211_rx_mlme_mgmt(sdata->dev, (u8 *)mgmt, len);
+		cfg80211_rx_mlme_mgmt_dup(sdata->dev, (u8 *)mgmt, len);
 		return;
 	}
 
@@ -2598,7 +2598,7 @@ static void ieee80211_rx_mgmt_auth(struc
 	}
 	mutex_unlock(&sdata->local->sta_mtx);
 
-	cfg80211_rx_mlme_mgmt(sdata->dev, (u8 *)mgmt, len);
+	cfg80211_rx_mlme_mgmt_dup(sdata->dev, (u8 *)mgmt, len);
 	return;
  out_err:
 	mutex_unlock(&sdata->local->sta_mtx);
@@ -3104,7 +3104,7 @@ static void ieee80211_rx_mgmt_assoc_resp
 		if (!ieee80211_assoc_success(sdata, bss, mgmt, len)) {
 			/* oops -- internal error -- send timeout for now */
 			ieee80211_destroy_assoc_data(sdata, false);
-			cfg80211_assoc_timeout(sdata->dev, bss);
+			cfg80211_assoc_timeout_dup(sdata->dev, bss);
 			return;
 		}
 		event.u.mlme.status = MLME_SUCCESS;
@@ -3125,7 +3125,7 @@ static void ieee80211_rx_mgmt_assoc_resp
 				uapsd_queues |= BIT(ac);
 	}
 
-	cfg80211_rx_assoc_resp(sdata->dev, bss, (u8 *)mgmt, len, uapsd_queues);
+	cfg80211_rx_assoc_resp_dup(sdata->dev, bss, (u8 *)mgmt, len, uapsd_queues);
 }
 
 static void ieee80211_rx_bss_info(struct ieee80211_sub_if_data *sdata,
@@ -3342,14 +3342,14 @@ static void ieee80211_rx_mgmt_beacon(str
 		if (sig < thold &&
 		    (last_event == 0 || sig < last_event - hyst)) {
 			ifmgd->last_cqm_event_signal = sig;
-			ieee80211_cqm_rssi_notify(
+			ieee80211_cqm_rssi_notify_dup(
 				&sdata->vif,
 				NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
 				GFP_KERNEL);
 		} else if (sig > thold &&
 			   (last_event == 0 || sig > last_event + hyst)) {
 			ifmgd->last_cqm_event_signal = sig;
-			ieee80211_cqm_rssi_notify(
+			ieee80211_cqm_rssi_notify_dup(
 				&sdata->vif,
 				NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
 				GFP_KERNEL);
@@ -3405,7 +3405,7 @@ static void ieee80211_rx_mgmt_beacon(str
 		struct ieee80211_p2p_noa_attr noa = {};
 		int ret;
 
-		ret = cfg80211_get_p2p_attr(mgmt->u.beacon.variable,
+		ret = cfg80211_get_p2p_attr_dup(mgmt->u.beacon.variable,
 					    len - baselen,
 					    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
 					    (u8 *) &noa, sizeof(noa));
@@ -3611,7 +3611,7 @@ static void ieee80211_sta_timer(unsigned
 	struct ieee80211_sub_if_data *sdata =
 		(struct ieee80211_sub_if_data *) data;
 
-	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&sdata->local->hw, &sdata->work);
 }
 
 static void ieee80211_sta_connection_lost(struct ieee80211_sub_if_data *sdata,
@@ -3648,7 +3648,7 @@ static int ieee80211_probe_auth(struct i
 		 * Most likely AP is not in the range so remove the
 		 * bss struct for that AP.
 		 */
-		cfg80211_unlink_bss(local->hw.wiphy, auth_data->bss);
+		cfg80211_unlink_bss_dup(local->hw.wiphy, auth_data->bss);
 
 		return -ETIMEDOUT;
 	}
@@ -3688,7 +3688,7 @@ static int ieee80211_probe_auth(struct i
 			   IEEE80211_AUTH_MAX_TRIES);
 
 		rcu_read_lock();
-		ssidie = ieee80211_bss_get_ie(auth_data->bss, WLAN_EID_SSID);
+		ssidie = ieee80211_bss_get_ie_dup(auth_data->bss, WLAN_EID_SSID);
 		if (!ssidie) {
 			rcu_read_unlock();
 			return -EINVAL;
@@ -3734,7 +3734,7 @@ static int ieee80211_do_assoc(struct iee
 		 * Most likely AP is not in the range so remove the
 		 * bss struct for that AP.
 		 */
-		cfg80211_unlink_bss(local->hw.wiphy, assoc_data->bss);
+		cfg80211_unlink_bss_dup(local->hw.wiphy, assoc_data->bss);
 
 		return -ETIMEDOUT;
 	}
@@ -3768,7 +3768,7 @@ void ieee80211_mgd_conn_tx_status(struct
 	sdata->u.mgd.status_acked = acked;
 	sdata->u.mgd.status_received = true;
 
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 }
 
 void ieee80211_sta_work(struct ieee80211_sub_if_data *sdata)
@@ -3827,7 +3827,7 @@ void ieee80211_sta_work(struct ieee80211
 
 			ieee80211_destroy_auth_data(sdata, false);
 
-			cfg80211_auth_timeout(sdata->dev, bssid);
+			cfg80211_auth_timeout_dup(sdata->dev, bssid);
 			drv_event_callback(sdata->local, sdata, &event);
 		}
 	} else if (ifmgd->auth_data && ifmgd->auth_data->timeout_started)
@@ -3845,7 +3845,7 @@ void ieee80211_sta_work(struct ieee80211
 			};
 
 			ieee80211_destroy_assoc_data(sdata, false);
-			cfg80211_assoc_timeout(sdata->dev, bss);
+			cfg80211_assoc_timeout_dup(sdata->dev, bss);
 			drv_event_callback(sdata->local, sdata, &event);
 		}
 	} else if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started)
@@ -3928,7 +3928,7 @@ static void ieee80211_sta_bcn_mon_timer(
 		return;
 
 	sdata->u.mgd.connection_loss = false;
-	ieee80211_queue_work(&sdata->local->hw,
+	ieee80211_queue_work_dup(&sdata->local->hw,
 			     &sdata->u.mgd.beacon_connection_loss_work);
 }
 
@@ -3945,7 +3945,7 @@ static void ieee80211_sta_conn_mon_timer
 	if (sdata->vif.csa_active && !ifmgd->csa_waiting_bcn)
 		return;
 
-	ieee80211_queue_work(&local->hw, &ifmgd->monitor_work);
+	ieee80211_queue_work_dup(&local->hw, &ifmgd->monitor_work);
 }
 
 static void ieee80211_sta_monitor_work(struct work_struct *work)
@@ -3967,10 +3967,10 @@ static void ieee80211_restart_sta_timer(
 		/* let's probe the connection once */
 		flags = sdata->local->hw.flags;
 		if (!(flags & IEEE80211_HW_CONNECTION_MONITOR))
-			ieee80211_queue_work(&sdata->local->hw,
+			ieee80211_queue_work_dup(&sdata->local->hw,
 					     &sdata->u.mgd.monitor_work);
 		/* and do all the other regular work too */
-		ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+		ieee80211_queue_work_dup(&sdata->local->hw, &sdata->work);
 	}
 }
 
@@ -4000,7 +4000,7 @@ void ieee80211_mgd_quiesce(struct ieee80
 			ieee80211_destroy_assoc_data(sdata, false);
 		if (ifmgd->auth_data)
 			ieee80211_destroy_auth_data(sdata, false);
-		cfg80211_tx_mlme_mgmt(sdata->dev, frame_buf,
+		cfg80211_tx_mlme_mgmt_dup(sdata->dev, frame_buf,
 				      IEEE80211_DEAUTH_FRAME_LEN);
 	}
 
@@ -4115,7 +4115,7 @@ static u8 ieee80211_ht_vht_rx_chains(str
 	if (ifmgd->flags & IEEE80211_STA_DISABLE_HT)
 		return chains;
 
-	ht_cap_ie = ieee80211_bss_get_ie(cbss, WLAN_EID_HT_CAPABILITY);
+	ht_cap_ie = ieee80211_bss_get_ie_dup(cbss, WLAN_EID_HT_CAPABILITY);
 	if (ht_cap_ie && ht_cap_ie[1] >= sizeof(*ht_cap)) {
 		ht_cap = (void *)(ht_cap_ie + 2);
 		chains = ieee80211_mcs_to_chains(&ht_cap->mcs);
@@ -4128,7 +4128,7 @@ static u8 ieee80211_ht_vht_rx_chains(str
 	if (ifmgd->flags & IEEE80211_STA_DISABLE_VHT)
 		return chains;
 
-	vht_cap_ie = ieee80211_bss_get_ie(cbss, WLAN_EID_VHT_CAPABILITY);
+	vht_cap_ie = ieee80211_bss_get_ie_dup(cbss, WLAN_EID_VHT_CAPABILITY);
 	if (vht_cap_ie && vht_cap_ie[1] >= sizeof(*vht_cap)) {
 		u8 nss;
 		u16 tx_mcs_map;
@@ -4171,11 +4171,11 @@ static int ieee80211_prep_channel(struct
 	    sband->ht_cap.ht_supported) {
 		const u8 *ht_oper_ie, *ht_cap_ie;
 
-		ht_oper_ie = ieee80211_bss_get_ie(cbss, WLAN_EID_HT_OPERATION);
+		ht_oper_ie = ieee80211_bss_get_ie_dup(cbss, WLAN_EID_HT_OPERATION);
 		if (ht_oper_ie && ht_oper_ie[1] >= sizeof(*ht_oper))
 			ht_oper = (void *)(ht_oper_ie + 2);
 
-		ht_cap_ie = ieee80211_bss_get_ie(cbss, WLAN_EID_HT_CAPABILITY);
+		ht_cap_ie = ieee80211_bss_get_ie_dup(cbss, WLAN_EID_HT_CAPABILITY);
 		if (ht_cap_ie && ht_cap_ie[1] >= sizeof(*ht_cap))
 			ht_cap = (void *)(ht_cap_ie + 2);
 
@@ -4189,7 +4189,7 @@ static int ieee80211_prep_channel(struct
 	    sband->vht_cap.vht_supported) {
 		const u8 *vht_oper_ie, *vht_cap;
 
-		vht_oper_ie = ieee80211_bss_get_ie(cbss,
+		vht_oper_ie = ieee80211_bss_get_ie_dup(cbss,
 						   WLAN_EID_VHT_OPERATION);
 		if (vht_oper_ie && vht_oper_ie[1] >= sizeof(*vht_oper))
 			vht_oper = (void *)(vht_oper_ie + 2);
@@ -4201,7 +4201,7 @@ static int ieee80211_prep_channel(struct
 			ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 		}
 
-		vht_cap = ieee80211_bss_get_ie(cbss, WLAN_EID_VHT_CAPABILITY);
+		vht_cap = ieee80211_bss_get_ie_dup(cbss, WLAN_EID_VHT_CAPABILITY);
 		if (!vht_cap || vht_cap[1] < sizeof(struct ieee80211_vht_cap)) {
 			ifmgd->flags |= IEEE80211_STA_DISABLE_VHT;
 			vht_oper = NULL;
@@ -4341,7 +4341,7 @@ static int ieee80211_prep_connection(str
 			sdata->vif.bss_conf.sync_tsf = ies->tsf;
 			sdata->vif.bss_conf.sync_device_ts =
 				bss->device_ts_beacon;
-			tim_ie = cfg80211_find_ie(WLAN_EID_TIM,
+			tim_ie = cfg80211_find_ie_dup(WLAN_EID_TIM,
 						  ies->data, ies->len);
 			if (tim_ie && tim_ie[1] >= 2)
 				sdata->vif.bss_conf.sync_dtim_count = tim_ie[2];
@@ -4487,7 +4487,7 @@ int ieee80211_mgd_auth(struct ieee80211_
 	}
 
 	/* hold our own reference */
-	cfg80211_ref_bss(local->hw.wiphy, auth_data->bss);
+	cfg80211_ref_bss_dup(local->hw.wiphy, auth_data->bss);
 	return 0;
 
  err_clear:
@@ -4554,7 +4554,7 @@ int ieee80211_mgd_assoc(struct ieee80211
 		return -ENOMEM;
 
 	rcu_read_lock();
-	ssidie = ieee80211_bss_get_ie(req->bss, WLAN_EID_SSID);
+	ssidie = ieee80211_bss_get_ie_dup(req->bss, WLAN_EID_SSID);
 	if (!ssidie) {
 		rcu_read_unlock();
 		kfree(assoc_data);
@@ -4611,7 +4611,7 @@ int ieee80211_mgd_assoc(struct ieee80211
 		end = start + ies->len;
 
 		while (true) {
-			wp = cfg80211_find_vendor_ie(
+			wp = cfg80211_find_vendor_ie_dup(
 				WLAN_OUI_MICROSOFT,
 				WLAN_OUI_TYPE_MICROSOFT_WMM,
 				start, end - start);
@@ -4711,13 +4711,13 @@ int ieee80211_mgd_assoc(struct ieee80211
 	assoc_data->supp_rates_len = bss->supp_rates_len;
 
 	rcu_read_lock();
-	ht_ie = ieee80211_bss_get_ie(req->bss, WLAN_EID_HT_OPERATION);
+	ht_ie = ieee80211_bss_get_ie_dup(req->bss, WLAN_EID_HT_OPERATION);
 	if (ht_ie && ht_ie[1] >= sizeof(struct ieee80211_ht_operation))
 		assoc_data->ap_ht_param =
 			((struct ieee80211_ht_operation *)(ht_ie + 2))->ht_param;
 	else
 		ifmgd->flags |= IEEE80211_STA_DISABLE_HT;
-	vht_ie = ieee80211_bss_get_ie(req->bss, WLAN_EID_VHT_CAPABILITY);
+	vht_ie = ieee80211_bss_get_ie_dup(req->bss, WLAN_EID_VHT_CAPABILITY);
 	if (vht_ie && vht_ie[1] >= sizeof(struct ieee80211_vht_cap))
 		memcpy(&assoc_data->ap_vht_cap, vht_ie + 2,
 		       sizeof(struct ieee80211_vht_cap));
@@ -4790,7 +4790,7 @@ int ieee80211_mgd_assoc(struct ieee80211
 		assoc_data->timeout_started = true;
 		assoc_data->need_beacon = true;
 	} else if (beacon_ies) {
-		const u8 *tim_ie = cfg80211_find_ie(WLAN_EID_TIM,
+		const u8 *tim_ie = cfg80211_find_ie_dup(WLAN_EID_TIM,
 						    beacon_ies->data,
 						    beacon_ies->len);
 		u8 dtim_count = 0;
@@ -4939,7 +4939,7 @@ void ieee80211_mgd_stop(struct ieee80211
 	if (ifmgd->assoc_data) {
 		struct cfg80211_bss *bss = ifmgd->assoc_data->bss;
 		ieee80211_destroy_assoc_data(sdata, false);
-		cfg80211_assoc_timeout(sdata->dev, bss);
+		cfg80211_assoc_timeout_dup(sdata->dev, bss);
 	}
 	if (ifmgd->auth_data)
 		ieee80211_destroy_auth_data(sdata, false);
@@ -4954,7 +4954,7 @@ void ieee80211_mgd_stop(struct ieee80211
 	sdata_unlock(sdata);
 }
 
-void ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,
+void ieee80211_cqm_rssi_notify_dup(struct ieee80211_vif *vif,
 			       enum nl80211_cqm_rssi_threshold_event rssi_event,
 			       gfp_t gfp)
 {
@@ -4962,16 +4962,16 @@ void ieee80211_cqm_rssi_notify(struct ie
 
 	trace_api_cqm_rssi_notify(sdata, rssi_event);
 
-	cfg80211_cqm_rssi_notify(sdata->dev, rssi_event, gfp);
+	cfg80211_cqm_rssi_notify_dup(sdata->dev, rssi_event, gfp);
 }
-EXPORT_SYMBOL(ieee80211_cqm_rssi_notify);
+EXPORT_SYMBOL(ieee80211_cqm_rssi_notify_dup);
 
-void ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp)
+void ieee80211_cqm_beacon_loss_notify_dup(struct ieee80211_vif *vif, gfp_t gfp)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 
 	trace_api_cqm_beacon_loss_notify(sdata->local, sdata);
 
-	cfg80211_cqm_beacon_loss_notify(sdata->dev, gfp);
+	cfg80211_cqm_beacon_loss_notify_dup(sdata->dev, gfp);
 }
-EXPORT_SYMBOL(ieee80211_cqm_beacon_loss_notify);
+EXPORT_SYMBOL(ieee80211_cqm_beacon_loss_notify_dup);
--- a/net/mac80211/ocb.c	2015-06-23 11:07:42.828850712 +0200
+++ b/net/mac80211/ocb.c	2015-06-23 14:54:16.197852497 +0200
@@ -80,12 +80,12 @@ void ieee80211_ocb_rx_no_sta(struct ieee
 	/* Add only mandatory rates for now */
 	sband = local->hw.wiphy->bands[band];
 	sta->sta.supp_rates[band] =
-		ieee80211_mandatory_rates(sband, scan_width);
+		ieee80211_mandatory_rates_dup(sband, scan_width);
 
 	spin_lock(&ifocb->incomplete_lock);
 	list_add(&sta->list, &ifocb->incomplete_stations);
 	spin_unlock(&ifocb->incomplete_lock);
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 }
 
 static struct sta_info *ieee80211_ocb_finish_sta(struct sta_info *sta)
@@ -160,7 +160,7 @@ static void ieee80211_ocb_housekeeping_t
 
 	set_bit(OCB_WORK_HOUSEKEEPING, &ifocb->wrkq_flags);
 
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 }
 
 void ieee80211_ocb_setup_sdata(struct ieee80211_sub_if_data *sdata)
@@ -201,7 +201,7 @@ int ieee80211_ocb_join(struct ieee80211_
 	ifocb->joined = true;
 
 	set_bit(OCB_WORK_HOUSEKEEPING, &ifocb->wrkq_flags);
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 
 	netif_carrier_on(sdata->dev);
 	return 0;
--- a/net/mac80211/offchannel.c	2015-06-23 11:07:42.828850712 +0200
+++ b/net/mac80211/offchannel.c	2015-06-23 14:54:16.246852717 +0200
@@ -118,7 +118,7 @@ void ieee80211_offchannel_stop_vifs(stru
 	 * Stop queues and transmit all frames queued by the driver
 	 * before sending nullfunc to enable powersave at the AP.
 	 */
-	ieee80211_stop_queues_by_reason(&local->hw, IEEE80211_MAX_QUEUE_MAP,
+	ieee80211_stop_queues_by_reason_dup(&local->hw, IEEE80211_MAX_QUEUE_MAP,
 					IEEE80211_QUEUE_STOP_REASON_OFFCHANNEL,
 					false);
 	ieee80211_flush_queues(local, NULL);
@@ -182,7 +182,7 @@ void ieee80211_offchannel_return(struct
 	}
 	mutex_unlock(&local->iflist_mtx);
 
-	ieee80211_wake_queues_by_reason(&local->hw, IEEE80211_MAX_QUEUE_MAP,
+	ieee80211_wake_queues_by_reason_dup(&local->hw, IEEE80211_MAX_QUEUE_MAP,
 					IEEE80211_QUEUE_STOP_REASON_OFFCHANNEL,
 					false);
 }
@@ -199,7 +199,7 @@ void ieee80211_handle_roc_started(struct
 			roc->frame = NULL;
 		}
 	} else {
-		cfg80211_ready_on_channel(&roc->sdata->wdev, roc->cookie,
+		cfg80211_ready_on_channel_dup(&roc->sdata->wdev, roc->cookie,
 					  roc->chan, roc->req_duration,
 					  GFP_KERNEL);
 	}
@@ -242,7 +242,7 @@ static void ieee80211_hw_roc_start(struc
 	mutex_unlock(&local->mtx);
 }
 
-void ieee80211_ready_on_channel(struct ieee80211_hw *hw)
+void ieee80211_ready_on_channel_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
@@ -250,9 +250,9 @@ void ieee80211_ready_on_channel(struct i
 
 	trace_api_ready_on_channel(local);
 
-	ieee80211_queue_work(hw, &local->hw_roc_start);
+	ieee80211_queue_work_dup(hw, &local->hw_roc_start);
 }
-EXPORT_SYMBOL_GPL(ieee80211_ready_on_channel);
+EXPORT_SYMBOL_GPL(ieee80211_ready_on_channel_dup);
 
 void ieee80211_start_next_roc(struct ieee80211_local *local)
 {
@@ -290,11 +290,11 @@ void ieee80211_start_next_roc(struct iee
 			 * queue the work struct again to avoid recursion
 			 * when multiple failures occur
 			 */
-			ieee80211_remain_on_channel_expired(&local->hw);
+			ieee80211_remain_on_channel_expired_dup(&local->hw);
 		}
 	} else {
 		/* delay it a bit */
-		ieee80211_queue_delayed_work(&local->hw, &roc->work,
+		ieee80211_queue_delayed_work_dup(&local->hw, &roc->work,
 					     round_jiffies_relative(HZ/2));
 	}
 }
@@ -308,7 +308,7 @@ void ieee80211_roc_notify_destroy(struct
 
 	/* was never transmitted */
 	if (roc->frame) {
-		cfg80211_mgmt_tx_status(&roc->sdata->wdev,
+		cfg80211_mgmt_tx_status_dup(&roc->sdata->wdev,
 					(unsigned long)roc->frame,
 					roc->frame->data, roc->frame->len,
 					false, GFP_KERNEL);
@@ -316,7 +316,7 @@ void ieee80211_roc_notify_destroy(struct
 	}
 
 	if (!roc->mgmt_tx_cookie)
-		cfg80211_remain_on_channel_expired(&roc->sdata->wdev,
+		cfg80211_remain_on_channel_expired_dup(&roc->sdata->wdev,
 						   roc->cookie, roc->chan,
 						   GFP_KERNEL);
 
@@ -387,7 +387,7 @@ void ieee80211_sw_roc_work(struct work_s
 			goto finish;
 
 		roc->started = true;
-		ieee80211_queue_delayed_work(&local->hw, &roc->work,
+		ieee80211_queue_delayed_work_dup(&local->hw, &roc->work,
 					     msecs_to_jiffies(roc->duration));
 	} else {
 		/* finish this ROC */
@@ -446,15 +446,15 @@ static void ieee80211_hw_roc_done(struct
 	mutex_unlock(&local->mtx);
 }
 
-void ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw)
+void ieee80211_remain_on_channel_expired_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
 	trace_api_remain_on_channel_expired(local);
 
-	ieee80211_queue_work(hw, &local->hw_roc_done);
+	ieee80211_queue_work_dup(hw, &local->hw_roc_done);
 }
-EXPORT_SYMBOL_GPL(ieee80211_remain_on_channel_expired);
+EXPORT_SYMBOL_GPL(ieee80211_remain_on_channel_expired_dup);
 
 void ieee80211_roc_setup(struct ieee80211_local *local)
 {
@@ -489,7 +489,7 @@ void ieee80211_roc_purge(struct ieee8021
 			list_del(&roc->list);
 			ieee80211_roc_notify_destroy(roc, true);
 		} else {
-			ieee80211_queue_delayed_work(&local->hw, &roc->work, 0);
+			ieee80211_queue_delayed_work_dup(&local->hw, &roc->work, 0);
 
 			/* work will clean up etc */
 			flush_delayed_work(&roc->work);
--- a/net/mac80211/pm.c	2015-06-23 11:07:42.828850712 +0200
+++ b/net/mac80211/pm.c	2015-06-23 14:54:16.295852937 +0200
@@ -33,7 +33,7 @@ int __ieee80211_suspend(struct ieee80211
 		mutex_unlock(&local->sta_mtx);
 	}
 
-	ieee80211_stop_queues_by_reason(hw,
+	ieee80211_stop_queues_by_reason_dup(hw,
 					IEEE80211_MAX_QUEUE_MAP,
 					IEEE80211_QUEUE_STOP_REASON_SUSPEND,
 					false);
@@ -73,7 +73,7 @@ int __ieee80211_suspend(struct ieee80211
 				}
 				mutex_unlock(&local->sta_mtx);
 			}
-			ieee80211_wake_queues_by_reason(hw,
+			ieee80211_wake_queues_by_reason_dup(hw,
 					IEEE80211_MAX_QUEUE_MAP,
 					IEEE80211_QUEUE_STOP_REASON_SUSPEND,
 					false);
@@ -144,12 +144,12 @@ int __ieee80211_suspend(struct ieee80211
  * hang/firmware failure/etc. recovery.
  */
 
-void ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,
+void ieee80211_report_wowlan_wakeup_dup(struct ieee80211_vif *vif,
 				    struct cfg80211_wowlan_wakeup *wakeup,
 				    gfp_t gfp)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 
-	cfg80211_report_wowlan_wakeup(&sdata->wdev, wakeup, gfp);
+	cfg80211_report_wowlan_wakeup_dup(&sdata->wdev, wakeup, gfp);
 }
-EXPORT_SYMBOL(ieee80211_report_wowlan_wakeup);
+EXPORT_SYMBOL(ieee80211_report_wowlan_wakeup_dup);
--- a/net/mac80211/rate.c	2015-06-23 11:07:42.828850712 +0200
+++ b/net/mac80211/rate.c	2015-06-23 14:54:16.346853166 +0200
@@ -29,7 +29,7 @@ module_param(ieee80211_default_rc_algo,
 MODULE_PARM_DESC(ieee80211_default_rc_algo,
 		 "Default rate control algorithm for mac80211 to use");
 
-int ieee80211_rate_control_register(const struct rate_control_ops *ops)
+int ieee80211_rate_control_register_dup(const struct rate_control_ops *ops)
 {
 	struct rate_control_alg *alg;
 
@@ -58,9 +58,9 @@ int ieee80211_rate_control_register(cons
 
 	return 0;
 }
-EXPORT_SYMBOL(ieee80211_rate_control_register);
+EXPORT_SYMBOL(ieee80211_rate_control_register_dup);
 
-void ieee80211_rate_control_unregister(const struct rate_control_ops *ops)
+void ieee80211_rate_control_unregister_dup(const struct rate_control_ops *ops)
 {
 	struct rate_control_alg *alg;
 
@@ -74,7 +74,7 @@ void ieee80211_rate_control_unregister(c
 	}
 	mutex_unlock(&rate_ctrl_mutex);
 }
-EXPORT_SYMBOL(ieee80211_rate_control_unregister);
+EXPORT_SYMBOL(ieee80211_rate_control_unregister_dup);
 
 static const struct rate_control_ops *
 ieee80211_try_rate_control_ops_get(const char *name)
@@ -218,7 +218,7 @@ static void rc_send_low_basicrate(s8 *id
 	/* could not find a basic rate; use original selection */
 }
 
-static void __rate_control_send_low(struct ieee80211_hw *hw,
+static void __rate_control_send_low_dup(struct ieee80211_hw *hw,
 				    struct ieee80211_supported_band *sband,
 				    struct ieee80211_sta *sta,
 				    struct ieee80211_tx_info *info,
@@ -256,7 +256,7 @@ static void __rate_control_send_low(stru
 }
 
 
-bool rate_control_send_low(struct ieee80211_sta *pubsta,
+bool rate_control_send_low_dup(struct ieee80211_sta *pubsta,
 			   void *priv_sta,
 			   struct ieee80211_tx_rate_control *txrc)
 {
@@ -267,7 +267,7 @@ bool rate_control_send_low(struct ieee80
 	bool use_basicrate = false;
 
 	if (!pubsta || !priv_sta || rc_no_data_or_no_ack_use_min(txrc)) {
-		__rate_control_send_low(txrc->hw, sband, pubsta, info,
+		__rate_control_send_low_dup(txrc->hw, sband, pubsta, info,
 					txrc->rate_idx_mask);
 
 		if (!pubsta && txrc->bss) {
@@ -292,7 +292,7 @@ bool rate_control_send_low(struct ieee80
 	}
 	return false;
 }
-EXPORT_SYMBOL(rate_control_send_low);
+EXPORT_SYMBOL(rate_control_send_low_dup);
 
 static bool rate_idx_match_legacy_mask(struct ieee80211_tx_rate *rate,
 				       int n_bitrates, u32 mask)
@@ -628,7 +628,7 @@ static void rate_control_apply_mask(stru
 	}
 }
 
-void ieee80211_get_tx_rates(struct ieee80211_vif *vif,
+void ieee80211_get_tx_rates_dup(struct ieee80211_vif *vif,
 			    struct ieee80211_sta *sta,
 			    struct sk_buff *skb,
 			    struct ieee80211_tx_rate *dest,
@@ -651,13 +651,13 @@ void ieee80211_get_tx_rates(struct ieee8
 		rate_control_apply_mask(sdata, sta, sband, info, dest, max_rates);
 
 	if (dest[0].idx < 0)
-		__rate_control_send_low(&sdata->local->hw, sband, sta, info,
+		__rate_control_send_low_dup(&sdata->local->hw, sband, sta, info,
 					sdata->rc_rateidx_mask[info->band]);
 
 	if (sta)
 		rate_fixup_ratelist(vif, sband, info, dest, max_rates);
 }
-EXPORT_SYMBOL(ieee80211_get_tx_rates);
+EXPORT_SYMBOL(ieee80211_get_tx_rates_dup);
 
 void rate_control_get_rate(struct ieee80211_sub_if_data *sdata,
 			   struct sta_info *sta,
@@ -688,12 +688,12 @@ void rate_control_get_rate(struct ieee80
 	if (sdata->local->hw.flags & IEEE80211_HW_SUPPORTS_RC_TABLE)
 		return;
 
-	ieee80211_get_tx_rates(&sdata->vif, ista, txrc->skb,
+	ieee80211_get_tx_rates_dup(&sdata->vif, ista, txrc->skb,
 			       info->control.rates,
 			       ARRAY_SIZE(info->control.rates));
 }
 
-int rate_control_set_rates(struct ieee80211_hw *hw,
+int rate_control_set_rates_dup(struct ieee80211_hw *hw,
 			   struct ieee80211_sta *pubsta,
 			   struct ieee80211_sta_rates *rates)
 {
@@ -715,7 +715,7 @@ int rate_control_set_rates(struct ieee80
 
 	return 0;
 }
-EXPORT_SYMBOL(rate_control_set_rates);
+EXPORT_SYMBOL(rate_control_set_rates_dup);
 
 int ieee80211_init_rate_ctrl_alg(struct ieee80211_local *local,
 				 const char *name)
--- a/net/mac80211/rc80211_minstrel.c	2015-06-23 11:07:42.828850712 +0200
+++ b/net/mac80211/rc80211_minstrel.c	2015-06-23 14:54:16.390853364 +0200
@@ -124,7 +124,7 @@ minstrel_update_rates(struct minstrel_pr
 	ratetbl->rate[i].count_cts = mp->max_retry;
 	ratetbl->rate[i].count_rts = mp->max_retry;
 
-	rate_control_set_rates(mp->hw, mi->sta, ratetbl);
+	rate_control_set_rates_dup(mp->hw, mi->sta, ratetbl);
 }
 
 static void
@@ -305,7 +305,7 @@ minstrel_get_rate(void *priv, struct iee
 	int sampling_ratio;
 
 	/* management/no-ack frames do not use rate control */
-	if (rate_control_send_low(sta, priv_sta, txrc))
+	if (rate_control_send_low_dup(sta, priv_sta, txrc))
 		return;
 
 	/* check multi-rate-retry capabilities & adjust lookaround_rate */
@@ -690,12 +690,12 @@ const struct rate_control_ops mac80211_m
 int __init
 rc80211_minstrel_init(void)
 {
-	return ieee80211_rate_control_register(&mac80211_minstrel);
+	return ieee80211_rate_control_register_dup(&mac80211_minstrel);
 }
 
 void
 rc80211_minstrel_exit(void)
 {
-	ieee80211_rate_control_unregister(&mac80211_minstrel);
+	ieee80211_rate_control_unregister_dup(&mac80211_minstrel);
 }
 
--- a/net/mac80211/rc80211_minstrel_ht.c	2015-06-23 11:07:42.828850712 +0200
+++ b/net/mac80211/rc80211_minstrel_ht.c	2015-06-23 14:54:16.438853579 +0200
@@ -700,7 +700,7 @@ minstrel_aggr_check(struct ieee80211_sta
 	if (likely(sta->ampdu_mlme.tid_tx[tid]))
 		return;
 
-	ieee80211_start_tx_ba_session(pubsta, tid, 5000);
+	ieee80211_start_tx_ba_session_dup(pubsta, tid, 5000);
 }
 
 static void
@@ -909,7 +909,7 @@ minstrel_ht_update_rates(struct minstrel
 	}
 
 	rates->rate[i].idx = -1;
-	rate_control_set_rates(mp->hw, mi->sta, rates);
+	rate_control_set_rates_dup(mp->hw, mi->sta, rates);
 }
 
 static inline int
@@ -1014,7 +1014,7 @@ minstrel_ht_get_rate(void *priv, struct
 	struct minstrel_priv *mp = priv;
 	int sample_idx;
 
-	if (rate_control_send_low(sta, priv_sta, txrc))
+	if (rate_control_send_low_dup(sta, priv_sta, txrc))
 		return;
 
 	if (!msp->is_ht)
@@ -1378,11 +1378,11 @@ int __init
 rc80211_minstrel_ht_init(void)
 {
 	init_sample_table();
-	return ieee80211_rate_control_register(&mac80211_minstrel_ht);
+	return ieee80211_rate_control_register_dup(&mac80211_minstrel_ht);
 }
 
 void
 rc80211_minstrel_ht_exit(void)
 {
-	ieee80211_rate_control_unregister(&mac80211_minstrel_ht);
+	ieee80211_rate_control_unregister_dup(&mac80211_minstrel_ht);
 }
--- a/net/mac80211/rc80211_pid_algo.c	2015-06-23 11:07:42.829850723 +0200
+++ b/net/mac80211/rc80211_pid_algo.c	2015-06-23 14:54:16.493853826 +0200
@@ -275,7 +275,7 @@ rate_control_pid_get_rate(void *priv, st
 			txrc->hw->conf.short_frame_max_tx_count;
 
 	/* Send management frames and NO_ACK data using lowest rate. */
-	if (rate_control_send_low(sta, priv_sta, txrc))
+	if (rate_control_send_low_dup(sta, priv_sta, txrc))
 		return;
 
 	rateidx = spinfo->txrate_idx;
@@ -468,10 +468,10 @@ static struct rate_control_ops mac80211_
 
 int __init rc80211_pid_init(void)
 {
-	return ieee80211_rate_control_register(&mac80211_rcpid);
+	return ieee80211_rate_control_register_dup(&mac80211_rcpid);
 }
 
 void rc80211_pid_exit(void)
 {
-	ieee80211_rate_control_unregister(&mac80211_rcpid);
+	ieee80211_rate_control_unregister_dup(&mac80211_rcpid);
 }
--- a/net/mac80211/rx.c	2015-06-23 11:07:42.829850723 +0200
+++ b/net/mac80211/rx.c	2015-06-23 14:54:16.544854055 +0200
@@ -559,7 +559,7 @@ static void ieee80211_parse_qos(struct i
 		/* frame has qos control */
 		tid = *qc & IEEE80211_QOS_CTL_TID_MASK;
 		if (*qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT)
-			status->rx_flags |= IEEE80211_RX_AMSDU;
+			status->rx_flags |= ieee80211_rx_AMSDU;
 
 		seqno_idx = tid;
 		security_idx = tid;
@@ -677,7 +677,7 @@ static int iwl80211_get_cs_keyid(const s
 	u8 keyid;
 
 	fc = hdr->frame_control;
-	hdrlen = ieee80211_hdrlen(fc);
+	hdrlen = ieee80211_hdrlen_dup(fc);
 
 	if (skb->len < hdrlen + cs->hdr_len)
 		return -EINVAL;
@@ -769,7 +769,7 @@ static void ieee80211_release_reorder_fr
 	tid_agg_rx->stored_mpdu_num--;
 	while ((skb = __skb_dequeue(skb_list))) {
 		status = IEEE80211_SKB_RXCB(skb);
-		status->rx_flags |= IEEE80211_RX_DEFERRED_RELEASE;
+		status->rx_flags |= ieee80211_rx_DEFERRED_RELEASE;
 		__skb_queue_tail(frames, skb);
 	}
 
@@ -1014,7 +1014,7 @@ static void ieee80211_rx_reorder_ampdu(s
 		goto dont_reorder;
 
 	/* not actually part of this BA session */
-	if (!(status->rx_flags & IEEE80211_RX_RA_MATCH))
+	if (!(status->rx_flags & ieee80211_rx_RA_MATCH))
 		goto dont_reorder;
 
 	/* new, potentially un-ordered, ampdu frame - process it */
@@ -1028,7 +1028,7 @@ static void ieee80211_rx_reorder_ampdu(s
 	if (sc & IEEE80211_SCTL_FRAG) {
 		skb->pkt_type = IEEE80211_SDATA_QUEUE_TYPE_FRAME;
 		skb_queue_tail(&rx->sdata->skb_queue, skb);
-		ieee80211_queue_work(&local->hw, &rx->sdata->work);
+		ieee80211_queue_work_dup(&local->hw, &rx->sdata->work);
 		return;
 	}
 
@@ -1070,7 +1070,7 @@ ieee80211_rx_h_check_dup(struct ieee8021
 		if (unlikely(ieee80211_has_retry(hdr->frame_control) &&
 			     rx->sta->last_seq_ctrl[rx->seqno_idx] ==
 			     hdr->seq_ctrl)) {
-			if (status->rx_flags & IEEE80211_RX_RA_MATCH) {
+			if (status->rx_flags & ieee80211_rx_RA_MATCH) {
 				rx->local->dot11FrameDuplicateCount++;
 				rx->sta->num_duplicates++;
 			}
@@ -1121,7 +1121,7 @@ ieee80211_rx_h_check(struct ieee80211_rx
 			unsigned int hdrlen;
 			__be16 ethertype;
 
-			hdrlen = ieee80211_hdrlen(hdr->frame_control);
+			hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 
 			if (rx->skb->len < hdrlen + 8)
 				return RX_DROP_MONITOR;
@@ -1132,7 +1132,7 @@ ieee80211_rx_h_check(struct ieee80211_rx
 		}
 
 		if (rx->sdata->vif.type == NL80211_IFTYPE_AP &&
-		    cfg80211_rx_spurious_frame(rx->sdata->dev,
+		    cfg80211_rx_spurious_frame_dup(rx->sdata->dev,
 					       hdr->addr2,
 					       GFP_ATOMIC))
 			return RX_DROP_UNUSABLE;
@@ -1220,7 +1220,7 @@ static void sta_ps_end(struct sta_info *
 	ieee80211_sta_ps_deliver_wakeup(sta);
 }
 
-int ieee80211_sta_ps_transition(struct ieee80211_sta *sta, bool start)
+int ieee80211_sta_ps_transition_dup(struct ieee80211_sta *sta, bool start)
 {
 	struct sta_info *sta_inf = container_of(sta, struct sta_info, sta);
 	bool in_ps;
@@ -1239,7 +1239,7 @@ int ieee80211_sta_ps_transition(struct i
 
 	return 0;
 }
-EXPORT_SYMBOL(ieee80211_sta_ps_transition);
+EXPORT_SYMBOL(ieee80211_sta_ps_transition_dup);
 
 static ieee80211_rx_result debug_noinline
 ieee80211_rx_h_uapsd_and_pspoll(struct ieee80211_rx_data *rx)
@@ -1249,7 +1249,7 @@ ieee80211_rx_h_uapsd_and_pspoll(struct i
 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
 	int tid, ac;
 
-	if (!rx->sta || !(status->rx_flags & IEEE80211_RX_RA_MATCH))
+	if (!rx->sta || !(status->rx_flags & ieee80211_rx_RA_MATCH))
 		return RX_CONTINUE;
 
 	if (sdata->vif.type != NL80211_IFTYPE_AP &&
@@ -1286,7 +1286,7 @@ ieee80211_rx_h_uapsd_and_pspoll(struct i
 
 		return RX_QUEUED;
 	} else if (!ieee80211_has_morefrags(hdr->frame_control) &&
-		   !(status->rx_flags & IEEE80211_RX_DEFERRED_RELEASE) &&
+		   !(status->rx_flags & ieee80211_rx_DEFERRED_RELEASE) &&
 		   ieee80211_has_pm(hdr->frame_control) &&
 		   (ieee80211_is_data_qos(hdr->frame_control) ||
 		    ieee80211_is_qos_nullfunc(hdr->frame_control))) {
@@ -1370,7 +1370,7 @@ ieee80211_rx_h_sta_process(struct ieee80
 		}
 	}
 
-	if (!(status->rx_flags & IEEE80211_RX_RA_MATCH))
+	if (!(status->rx_flags & ieee80211_rx_RA_MATCH))
 		return RX_CONTINUE;
 
 	if (rx->sdata->vif.type == NL80211_IFTYPE_STATION)
@@ -1402,7 +1402,7 @@ ieee80211_rx_h_sta_process(struct ieee80
 	 */
 	if (!(sta->local->hw.flags & IEEE80211_HW_AP_LINK_PS) &&
 	    !ieee80211_has_morefrags(hdr->frame_control) &&
-	    !(status->rx_flags & IEEE80211_RX_DEFERRED_RELEASE) &&
+	    !(status->rx_flags & ieee80211_rx_DEFERRED_RELEASE) &&
 	    (rx->sdata->vif.type == NL80211_IFTYPE_AP ||
 	     rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&
 	    /* PM bit is only checked in frames where it isn't reserved,
@@ -1443,7 +1443,7 @@ ieee80211_rx_h_sta_process(struct ieee80
 		     (rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&
 		      !rx->sdata->u.vlan.sta))) {
 			if (!test_and_set_sta_flag(sta, WLAN_STA_4ADDR_EVENT))
-				cfg80211_rx_unexpected_4addr_frame(
+				cfg80211_rx_unexpected_4addr_frame_dup(
 					rx->sdata->dev, sta->sta.addr,
 					GFP_ATOMIC);
 			return RX_DROP_MONITOR;
@@ -1505,7 +1505,7 @@ ieee80211_rx_h_decrypt(struct ieee80211_
 	 * No point in finding a key and decrypting if the frame is neither
 	 * addressed to us nor a multicast frame.
 	 */
-	if (!(status->rx_flags & IEEE80211_RX_RA_MATCH))
+	if (!(status->rx_flags & ieee80211_rx_RA_MATCH))
 		return RX_CONTINUE;
 
 	/* start without a key */
@@ -1598,7 +1598,7 @@ ieee80211_rx_h_decrypt(struct ieee80211_
 		    (status->flag & RX_FLAG_IV_STRIPPED))
 			return RX_CONTINUE;
 
-		hdrlen = ieee80211_hdrlen(fc);
+		hdrlen = ieee80211_hdrlen_dup(fc);
 
 		if (cs) {
 			keyidx = iwl80211_get_cs_keyid(cs, rx->skb);
@@ -1831,7 +1831,7 @@ ieee80211_rx_h_defragment(struct ieee802
 		memcpy(entry->last_pn, pn, IEEE80211_CCMP_PN_LEN);
 	}
 
-	skb_pull(rx->skb, ieee80211_hdrlen(fc));
+	skb_pull(rx->skb, ieee80211_hdrlen_dup(fc));
 	__skb_queue_tail(&entry->skb_list, rx->skb);
 	entry->last_frag = frag;
 	entry->extra_len += rx->skb->len;
@@ -1857,7 +1857,7 @@ ieee80211_rx_h_defragment(struct ieee802
 
 	/* Complete frame has been reassembled - process it now */
 	status = IEEE80211_SKB_RXCB(rx->skb);
-	status->rx_flags |= IEEE80211_RX_FRAGMENTED;
+	status->rx_flags |= ieee80211_rx_FRAGMENTED;
 
  out:
 	ieee80211_led_rx(rx->local);
@@ -1916,7 +1916,7 @@ static int ieee80211_drop_unencrypted_mg
 			     rx->key)) {
 			if (ieee80211_is_deauth(fc) ||
 			    ieee80211_is_disassoc(fc))
-				cfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,
+				cfg80211_rx_unprot_mlme_mgmt_dup(rx->sdata->dev,
 							     rx->skb->data,
 							     rx->skb->len);
 			return -EACCES;
@@ -1926,7 +1926,7 @@ static int ieee80211_drop_unencrypted_mg
 			     ieee80211_get_mmie_keyidx(rx->skb) < 0)) {
 			if (ieee80211_is_deauth(fc) ||
 			    ieee80211_is_disassoc(fc))
-				cfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,
+				cfg80211_rx_unprot_mlme_mgmt_dup(rx->sdata->dev,
 							     rx->skb->data,
 							     rx->skb->len);
 			return -EACCES;
@@ -1944,7 +1944,7 @@ static int ieee80211_drop_unencrypted_mg
 }
 
 static int
-__ieee80211_data_to_8023(struct ieee80211_rx_data *rx, bool *port_control)
+__ieee80211_data_to_8023_dup(struct ieee80211_rx_data *rx, bool *port_control)
 {
 	struct ieee80211_sub_if_data *sdata = rx->sdata;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
@@ -1970,7 +1970,7 @@ __ieee80211_data_to_8023(struct ieee8021
 	    sdata->vif.type == NL80211_IFTYPE_AP_VLAN && sdata->u.vlan.sta)
 		return -1;
 
-	ret = ieee80211_data_to_8023(rx->skb, sdata->vif.addr, sdata->vif.type);
+	ret = ieee80211_data_to_8023_dup(rx->skb, sdata->vif.addr, sdata->vif.type);
 	if (ret < 0)
 		return ret;
 
@@ -2027,7 +2027,7 @@ ieee80211_deliver_skb(struct ieee80211_r
 	if ((sdata->vif.type == NL80211_IFTYPE_AP ||
 	     sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&
 	    !(sdata->flags & IEEE80211_SDATA_DONT_BRIDGE_PACKETS) &&
-	    (status->rx_flags & IEEE80211_RX_RA_MATCH) &&
+	    (status->rx_flags & ieee80211_rx_RA_MATCH) &&
 	    (sdata->vif.type != NL80211_IFTYPE_AP_VLAN || !sdata->u.vlan.sta)) {
 		if (is_multicast_ether_addr(ehdr->h_dest)) {
 			/*
@@ -2093,7 +2093,7 @@ ieee80211_deliver_skb(struct ieee80211_r
 		/*
 		 * Send to wireless media and increase priority by 256 to
 		 * keep the received priority instead of reclassifying
-		 * the frame (see cfg80211_classify8021d).
+		 * the frame (see cfg80211_classify8021d_dup).
 		 */
 		xmit_skb->priority += 256;
 		xmit_skb->protocol = htons(ETH_P_802_3);
@@ -2119,7 +2119,7 @@ ieee80211_rx_h_amsdu(struct ieee80211_rx
 	if (unlikely(!ieee80211_is_data_present(fc)))
 		return RX_DROP_MONITOR;
 
-	if (!(status->rx_flags & IEEE80211_RX_AMSDU))
+	if (!(status->rx_flags & ieee80211_rx_AMSDU))
 		return RX_CONTINUE;
 
 	if (ieee80211_has_a4(hdr->frame_control) &&
@@ -2140,7 +2140,7 @@ ieee80211_rx_h_amsdu(struct ieee80211_rx
 	if (skb_linearize(skb))
 		return RX_DROP_UNUSABLE;
 
-	ieee80211_amsdu_to_8023s(skb, &frame_list, dev->dev_addr,
+	ieee80211_amsdu_to_8023s_dup(skb, &frame_list, dev->dev_addr,
 				 rx->sdata->vif.type,
 				 rx->local->hw.extra_tx_headroom, true);
 
@@ -2175,7 +2175,7 @@ ieee80211_rx_h_mesh_fwding(struct ieee80
 	u16 q, hdrlen;
 
 	hdr = (struct ieee80211_hdr *) skb->data;
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 
 	/* make sure fixed part of mesh header is there, also checks skb len */
 	if (!pskb_may_pull(rx->skb, hdrlen + 6))
@@ -2185,7 +2185,7 @@ ieee80211_rx_h_mesh_fwding(struct ieee80
 
 	/* make sure full mesh header is there, also checks skb len */
 	if (!pskb_may_pull(rx->skb,
-			   hdrlen + ieee80211_get_mesh_hdrlen(mesh_hdr)))
+			   hdrlen + ieee80211_get_mesh_hdrlen_dup(mesh_hdr)))
 		return RX_DROP_MONITOR;
 
 	/* reload pointers */
@@ -2202,7 +2202,7 @@ ieee80211_rx_h_mesh_fwding(struct ieee80
 		return RX_DROP_MONITOR;
 
 	if (!ieee80211_is_data(hdr->frame_control) ||
-	    !(status->rx_flags & IEEE80211_RX_RA_MATCH))
+	    !(status->rx_flags & ieee80211_rx_RA_MATCH))
 		return RX_CONTINUE;
 
 	if (!mesh_hdr->ttl)
@@ -2243,7 +2243,7 @@ ieee80211_rx_h_mesh_fwding(struct ieee80
 		return RX_CONTINUE;
 
 	q = ieee80211_select_queue_80211(sdata, skb, hdr);
-	if (ieee80211_queue_stopped(&local->hw, q)) {
+	if (ieee80211_queue_stopped_dup(&local->hw, q)) {
 		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_congestion);
 		return RX_DROP_MONITOR;
 	}
@@ -2326,12 +2326,12 @@ ieee80211_rx_h_data(struct ieee80211_rx_
 	    sdata->vif.type == NL80211_IFTYPE_AP) {
 		if (rx->sta &&
 		    !test_and_set_sta_flag(rx->sta, WLAN_STA_4ADDR_EVENT))
-			cfg80211_rx_unexpected_4addr_frame(
+			cfg80211_rx_unexpected_4addr_frame_dup(
 				rx->sdata->dev, rx->sta->sta.addr, GFP_ATOMIC);
 		return RX_DROP_MONITOR;
 	}
 
-	err = __ieee80211_data_to_8023(rx, &port_control);
+	err = __ieee80211_data_to_8023_dup(rx, &port_control);
 	if (unlikely(err))
 		return RX_DROP_UNUSABLE;
 
@@ -2351,7 +2351,7 @@ ieee80211_rx_h_data(struct ieee80211_rx_
 		     tf->action_code == WLAN_TDLS_CHANNEL_SWITCH_RESPONSE)) {
 			rx->skb->pkt_type = IEEE80211_SDATA_QUEUE_TDLS_CHSW;
 			skb_queue_tail(&sdata->skb_queue, rx->skb);
-			ieee80211_queue_work(&rx->local->hw, &sdata->work);
+			ieee80211_queue_work_dup(&rx->local->hw, &sdata->work);
 			if (rx->sta)
 				rx->sta->rx_packets++;
 
@@ -2506,19 +2506,19 @@ ieee80211_rx_h_mgmt_check(struct ieee802
 
 	if (rx->sdata->vif.type == NL80211_IFTYPE_AP &&
 	    ieee80211_is_beacon(mgmt->frame_control) &&
-	    !(rx->flags & IEEE80211_RX_BEACON_REPORTED)) {
+	    !(rx->flags & ieee80211_rx_BEACON_REPORTED)) {
 		int sig = 0;
 
 		if (rx->local->hw.flags & IEEE80211_HW_SIGNAL_DBM)
 			sig = status->signal;
 
-		cfg80211_report_obss_beacon(rx->local->hw.wiphy,
+		cfg80211_report_obss_beacon_dup(rx->local->hw.wiphy,
 					    rx->skb->data, rx->skb->len,
 					    status->freq, sig);
-		rx->flags |= IEEE80211_RX_BEACON_REPORTED;
+		rx->flags |= ieee80211_rx_BEACON_REPORTED;
 	}
 
-	if (!(status->rx_flags & IEEE80211_RX_RA_MATCH))
+	if (!(status->rx_flags & ieee80211_rx_RA_MATCH))
 		return RX_DROP_MONITOR;
 
 	if (ieee80211_drop_unencrypted_mgmt(rx))
@@ -2548,7 +2548,7 @@ ieee80211_rx_h_action(struct ieee80211_r
 	    mgmt->u.action.category != WLAN_CATEGORY_SPECTRUM_MGMT)
 		return RX_DROP_UNUSABLE;
 
-	if (!(status->rx_flags & IEEE80211_RX_RA_MATCH))
+	if (!(status->rx_flags & ieee80211_rx_RA_MATCH))
 		return RX_DROP_UNUSABLE;
 
 	switch (mgmt->u.action.category) {
@@ -2805,7 +2805,7 @@ ieee80211_rx_h_action(struct ieee80211_r
 	return RX_CONTINUE;
 
  invalid:
-	status->rx_flags |= IEEE80211_RX_MALFORMED_ACTION_FRM;
+	status->rx_flags |= ieee80211_rx_MALFORMED_ACTION_FRM;
 	/* will return in the next handlers */
 	return RX_CONTINUE;
 
@@ -2818,7 +2818,7 @@ ieee80211_rx_h_action(struct ieee80211_r
  queue:
 	rx->skb->pkt_type = IEEE80211_SDATA_QUEUE_TYPE_FRAME;
 	skb_queue_tail(&sdata->skb_queue, rx->skb);
-	ieee80211_queue_work(&local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&local->hw, &sdata->work);
 	if (rx->sta)
 		rx->sta->rx_packets++;
 	return RX_QUEUED;
@@ -2831,7 +2831,7 @@ ieee80211_rx_h_userspace_mgmt(struct iee
 	int sig = 0;
 
 	/* skip known-bad action frames and return them in the next handler */
-	if (status->rx_flags & IEEE80211_RX_MALFORMED_ACTION_FRM)
+	if (status->rx_flags & ieee80211_rx_MALFORMED_ACTION_FRM)
 		return RX_CONTINUE;
 
 	/*
@@ -2844,7 +2844,7 @@ ieee80211_rx_h_userspace_mgmt(struct iee
 	if (rx->local->hw.flags & IEEE80211_HW_SIGNAL_DBM)
 		sig = status->signal;
 
-	if (cfg80211_rx_mgmt(&rx->sdata->wdev, status->freq, sig,
+	if (cfg80211_rx_mgmt_dup(&rx->sdata->wdev, status->freq, sig,
 			     rx->skb->data, rx->skb->len, 0)) {
 		if (rx->sta)
 			rx->sta->rx_packets++;
@@ -2877,7 +2877,7 @@ ieee80211_rx_h_action_return(struct ieee
 	 * registration mechanisms, but older ones still use cooked
 	 * monitor interfaces so push all frames there.
 	 */
-	if (!(status->rx_flags & IEEE80211_RX_MALFORMED_ACTION_FRM) &&
+	if (!(status->rx_flags & ieee80211_rx_MALFORMED_ACTION_FRM) &&
 	    (sdata->vif.type == NL80211_IFTYPE_AP ||
 	     sdata->vif.type == NL80211_IFTYPE_AP_VLAN))
 		return RX_DROP_MONITOR;
@@ -2964,14 +2964,14 @@ ieee80211_rx_h_mgmt(struct ieee80211_rx_
 	/* queue up frame and kick off work to process it */
 	rx->skb->pkt_type = IEEE80211_SDATA_QUEUE_TYPE_FRAME;
 	skb_queue_tail(&sdata->skb_queue, rx->skb);
-	ieee80211_queue_work(&rx->local->hw, &sdata->work);
+	ieee80211_queue_work_dup(&rx->local->hw, &sdata->work);
 	if (rx->sta)
 		rx->sta->rx_packets++;
 
 	return RX_QUEUED;
 }
 
-/* TODO: use IEEE80211_RX_FRAGMENTED */
+/* TODO: use ieee80211_rx_FRAGMENTED */
 static void ieee80211_rx_cooked_monitor(struct ieee80211_rx_data *rx,
 					struct ieee80211_rate *rate)
 {
@@ -2986,9 +2986,9 @@ static void ieee80211_rx_cooked_monitor(
 	 * If cooked monitor has been processed already, then
 	 * don't do it again. If not, set the flag.
 	 */
-	if (rx->flags & IEEE80211_RX_CMNTR)
+	if (rx->flags & ieee80211_rx_CMNTR)
 		goto out_free_skb;
-	rx->flags |= IEEE80211_RX_CMNTR;
+	rx->flags |= ieee80211_rx_CMNTR;
 
 	/* If there are no cooked monitor interfaces, just free the SKB */
 	if (!local->cooked_mntrs)
@@ -3215,7 +3215,7 @@ static bool prepare_for_handlers(struct
 			if (!(sdata->dev->flags & IFF_PROMISC) ||
 			    sdata->u.mgd.use_4addr)
 				return false;
-			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+			status->rx_flags &= ~ieee80211_rx_RA_MATCH;
 		}
 		break;
 	case NL80211_IFTYPE_ADHOC:
@@ -3232,7 +3232,7 @@ static bool prepare_for_handlers(struct
 			   !ether_addr_equal(sdata->vif.addr, hdr->addr1)) {
 			if (!(sdata->dev->flags & IFF_PROMISC))
 				return false;
-			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+			status->rx_flags &= ~ieee80211_rx_RA_MATCH;
 		} else if (!rx->sta) {
 			int rate_idx;
 			if (status->flag & (RX_FLAG_HT | RX_FLAG_VHT))
@@ -3259,7 +3259,7 @@ static bool prepare_for_handlers(struct
 			 */
 			if (!(sdata->dev->flags & IFF_PROMISC))
 				return false;
-			rx->flags &= ~IEEE80211_RX_RA_MATCH;
+			rx->flags &= ~ieee80211_rx_RA_MATCH;
 		} else if (!rx->sta) {
 			int rate_idx;
 			if (status->flag & RX_FLAG_HT)
@@ -3276,7 +3276,7 @@ static bool prepare_for_handlers(struct
 			if (!(sdata->dev->flags & IFF_PROMISC))
 				return false;
 
-			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+			status->rx_flags &= ~ieee80211_rx_RA_MATCH;
 		}
 		break;
 	case NL80211_IFTYPE_AP_VLAN:
@@ -3298,7 +3298,7 @@ static bool prepare_for_handlers(struct
 				return true;
 			if (!ieee80211_is_beacon(hdr->frame_control))
 				return false;
-			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+			status->rx_flags &= ~ieee80211_rx_RA_MATCH;
 		} else if (!ieee80211_has_tods(hdr->frame_control)) {
 			/* ignore data frames to TDLS-peers */
 			if (ieee80211_is_data(hdr->frame_control))
@@ -3323,7 +3323,7 @@ static bool prepare_for_handlers(struct
 			return false;
 		if (!ether_addr_equal(sdata->vif.addr, hdr->addr1) &&
 		    !multicast)
-			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+			status->rx_flags &= ~ieee80211_rx_RA_MATCH;
 		break;
 	default:
 		/* should never get here */
@@ -3349,7 +3349,7 @@ static bool ieee80211_prepare_and_rx_han
 	struct ieee80211_hdr *hdr = (void *)skb->data;
 
 	rx->skb = skb;
-	status->rx_flags |= IEEE80211_RX_RA_MATCH;
+	status->rx_flags |= ieee80211_rx_RA_MATCH;
 
 	if (!prepare_for_handlers(rx, hdr))
 		return false;
@@ -3397,12 +3397,12 @@ static void __ieee80211_rx_handle_packet
 
 	if (ieee80211_is_mgmt(fc)) {
 		/* drop frame if too short for header */
-		if (skb->len < ieee80211_hdrlen(fc))
+		if (skb->len < ieee80211_hdrlen_dup(fc))
 			err = -ENOBUFS;
 		else
 			err = skb_linearize(skb);
 	} else {
-		err = !pskb_may_pull(skb, ieee80211_hdrlen(fc));
+		err = !pskb_may_pull(skb, ieee80211_hdrlen_dup(fc));
 	}
 
 	if (err) {
@@ -3488,7 +3488,7 @@ static void __ieee80211_rx_handle_packet
  * This is the receive path handler. It is called by a low level driver when an
  * 802.11 MPDU is received from the hardware.
  */
-void ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb)
+void ieee80211_rx_dup(struct ieee80211_hw *hw, struct sk_buff *skb)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 	struct ieee80211_rate *rate = NULL;
@@ -3595,18 +3595,18 @@ void ieee80211_rx(struct ieee80211_hw *h
  drop:
 	kfree_skb(skb);
 }
-EXPORT_SYMBOL(ieee80211_rx);
+EXPORT_SYMBOL(ieee80211_rx_dup);
 
 /* This is a version of the rx handler that can be called from hard irq
  * context. Post the skb on the queue and schedule the tasklet */
-void ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb)
+void ieee80211_rx_irqsafe_dup(struct ieee80211_hw *hw, struct sk_buff *skb)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
 	BUILD_BUG_ON(sizeof(struct ieee80211_rx_status) > sizeof(skb->cb));
 
-	skb->pkt_type = IEEE80211_RX_MSG;
+	skb->pkt_type = ieee80211_rx_MSG;
 	skb_queue_tail(&local->skb_queue, skb);
 	tasklet_schedule(&local->tasklet);
 }
-EXPORT_SYMBOL(ieee80211_rx_irqsafe);
+EXPORT_SYMBOL(ieee80211_rx_irqsafe_dup);
--- a/net/mac80211/scan.c	2015-06-23 11:07:42.829850723 +0200
+++ b/net/mac80211/scan.c	2015-06-23 14:54:16.597854294 +0200
@@ -35,7 +35,7 @@ void ieee80211_rx_bss_put(struct ieee802
 {
 	if (!bss)
 		return;
-	cfg80211_put_bss(local->hw.wiphy,
+	cfg80211_put_bss_dup(local->hw.wiphy,
 			 container_of((void *)bss, struct cfg80211_bss, priv));
 }
 
@@ -81,7 +81,7 @@ ieee80211_bss_info_update(struct ieee802
 	if (rx_status->flag & RX_FLAG_10MHZ)
 		scan_width = NL80211_BSS_CHAN_WIDTH_10;
 
-	cbss = cfg80211_inform_bss_width_frame(local->hw.wiphy, channel,
+	cbss = cfg80211_inform_bss_width_frame_dup(local->hw.wiphy, channel,
 					       scan_width, mgmt, len, signal,
 					       GFP_ATOMIC);
 	if (!cbss)
@@ -303,7 +303,7 @@ static bool ieee80211_prep_hw_scan(struc
 	return true;
 }
 
-static void __ieee80211_scan_completed(struct ieee80211_hw *hw, bool aborted)
+static void __ieee80211_scan_completed_dup(struct ieee80211_hw *hw, bool aborted)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 	bool hw_scan = local->ops->hw_scan;
@@ -346,7 +346,7 @@ static void __ieee80211_scan_completed(s
 					     lockdep_is_held(&local->mtx));
 
 	if (scan_req != local->int_scan_req)
-		cfg80211_scan_done(scan_req, aborted);
+		cfg80211_scan_done_dup(scan_req, aborted);
 	RCU_INIT_POINTER(local->scan_req, NULL);
 
 	scan_sdata = rcu_dereference_protected(local->scan_sdata,
@@ -374,7 +374,7 @@ static void __ieee80211_scan_completed(s
 		ieee80211_start_next_roc(local);
 }
 
-void ieee80211_scan_completed(struct ieee80211_hw *hw, bool aborted)
+void ieee80211_scan_completed_dup(struct ieee80211_hw *hw, bool aborted)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
@@ -383,9 +383,9 @@ void ieee80211_scan_completed(struct iee
 	set_bit(SCAN_COMPLETED, &local->scanning);
 	if (aborted)
 		set_bit(SCAN_ABORTED, &local->scanning);
-	ieee80211_queue_delayed_work(&local->hw, &local->scan_work, 0);
+	ieee80211_queue_delayed_work_dup(&local->hw, &local->scan_work, 0);
 }
-EXPORT_SYMBOL(ieee80211_scan_completed);
+EXPORT_SYMBOL(ieee80211_scan_completed_dup);
 
 static int ieee80211_start_sw_scan(struct ieee80211_local *local,
 				   struct ieee80211_sub_if_data *sdata)
@@ -423,7 +423,7 @@ static int ieee80211_start_sw_scan(struc
 	/* We need to set power level at maximum rate for scanning. */
 	ieee80211_hw_config(local, 0);
 
-	ieee80211_queue_delayed_work(&local->hw,
+	ieee80211_queue_delayed_work_dup(&local->hw,
 				     &local->scan_work, 0);
 
 	return 0;
@@ -458,7 +458,7 @@ void ieee80211_run_deferred_scan(struct
 					lockdep_is_held(&local->mtx))))
 		return;
 
-	ieee80211_queue_delayed_work(&local->hw, &local->scan_work,
+	ieee80211_queue_delayed_work_dup(&local->hw, &local->scan_work,
 				     round_jiffies_relative(0));
 }
 
@@ -603,7 +603,7 @@ static int __ieee80211_start_scan(struct
 		}
 
 		/* Now, just wait a bit and we are all done! */
-		ieee80211_queue_delayed_work(&local->hw, &local->scan_work,
+		ieee80211_queue_delayed_work_dup(&local->hw, &local->scan_work,
 					     next_delay);
 		return 0;
 	} else {
@@ -900,11 +900,11 @@ void ieee80211_scan_work(struct work_str
 		}
 	} while (next_delay == 0);
 
-	ieee80211_queue_delayed_work(&local->hw, &local->scan_work, next_delay);
+	ieee80211_queue_delayed_work_dup(&local->hw, &local->scan_work, next_delay);
 	goto out;
 
 out_complete:
-	__ieee80211_scan_completed(&local->hw, aborted);
+	__ieee80211_scan_completed_dup(&local->hw, aborted);
 out:
 	mutex_unlock(&local->mtx);
 }
@@ -994,16 +994,16 @@ void ieee80211_scan_cancel(struct ieee80
 	 * yet really started (see __ieee80211_start_scan ).
 	 *
 	 * Regarding hardware scan:
-	 * - we can not call  __ieee80211_scan_completed() as when
+	 * - we can not call  __ieee80211_scan_completed_dup() as when
 	 *   SCAN_HW_SCANNING bit is set this function change
 	 *   local->hw_scan_req to operate on 5G band, what race with
 	 *   driver which can use local->hw_scan_req
 	 *
 	 * - we can not cancel scan_work since driver can schedule it
-	 *   by ieee80211_scan_completed(..., true) to finish scan
+	 *   by ieee80211_scan_completed_dup(..., true) to finish scan
 	 *
 	 * Hence we only call the cancel_hw_scan() callback, but the low-level
-	 * driver is still responsible for calling ieee80211_scan_completed()
+	 * driver is still responsible for calling ieee80211_scan_completed_dup()
 	 * after the scan was completed/aborted.
 	 */
 
@@ -1024,7 +1024,7 @@ void ieee80211_scan_cancel(struct ieee80
 
 	if (test_bit(SCAN_HW_SCANNING, &local->scanning)) {
 		/*
-		 * Make sure that __ieee80211_scan_completed doesn't trigger a
+		 * Make sure that __ieee80211_scan_completed_dup doesn't trigger a
 		 * scan on another band.
 		 */
 		set_bit(SCAN_HW_CANCELLED, &local->scanning);
@@ -1042,7 +1042,7 @@ void ieee80211_scan_cancel(struct ieee80
 	 */
 	cancel_delayed_work(&local->scan_work);
 	/* and clean up */
-	__ieee80211_scan_completed(&local->hw, true);
+	__ieee80211_scan_completed_dup(&local->hw, true);
 out:
 	mutex_unlock(&local->mtx);
 }
@@ -1150,15 +1150,15 @@ out:
 	return ret;
 }
 
-void ieee80211_sched_scan_results(struct ieee80211_hw *hw)
+void ieee80211_sched_scan_results_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
 	trace_api_sched_scan_results(local);
 
-	cfg80211_sched_scan_results(hw->wiphy);
+	cfg80211_sched_scan_results_dup(hw->wiphy);
 }
-EXPORT_SYMBOL(ieee80211_sched_scan_results);
+EXPORT_SYMBOL(ieee80211_sched_scan_results_dup);
 
 void ieee80211_sched_scan_end(struct ieee80211_local *local)
 {
@@ -1176,7 +1176,7 @@ void ieee80211_sched_scan_end(struct iee
 
 	mutex_unlock(&local->mtx);
 
-	cfg80211_sched_scan_stopped(local->hw.wiphy);
+	cfg80211_sched_scan_stopped_dup(local->hw.wiphy);
 }
 
 void ieee80211_sched_scan_stopped_work(struct work_struct *work)
@@ -1188,7 +1188,7 @@ void ieee80211_sched_scan_stopped_work(s
 	ieee80211_sched_scan_end(local);
 }
 
-void ieee80211_sched_scan_stopped(struct ieee80211_hw *hw)
+void ieee80211_sched_scan_stopped_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
@@ -1196,4 +1196,4 @@ void ieee80211_sched_scan_stopped(struct
 
 	schedule_work(&local->sched_scan_stopped_work);
 }
-EXPORT_SYMBOL(ieee80211_sched_scan_stopped);
+EXPORT_SYMBOL(ieee80211_sched_scan_stopped_dup);
--- a/net/mac80211/spectmgmt.c	2015-06-23 11:07:42.829850723 +0200
+++ b/net/mac80211/spectmgmt.c	2015-06-23 14:54:16.640854487 +0200
@@ -53,7 +53,7 @@ int ieee80211_parse_ch_switch_ie(struct
 		wide_bw_chansw_ie = NULL;
 
 	if (elems->ext_chansw_ie) {
-		if (!ieee80211_operating_class_to_band(
+		if (!ieee80211_operating_class_to_band_dup(
 				elems->ext_chansw_ie->new_operating_class,
 				&new_band)) {
 			sdata_info(sdata,
@@ -82,7 +82,7 @@ int ieee80211_parse_ch_switch_ie(struct
 				elems->mesh_chansw_params_ie->mesh_pre_value);
 	}
 
-	new_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);
+	new_freq = ieee80211_channel_to_frequency_dup(new_chan_no, new_band);
 	new_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);
 	if (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {
 		sdata_info(sdata,
@@ -105,19 +105,19 @@ int ieee80211_parse_ch_switch_ie(struct
 	default:
 		/* secondary_channel_offset was present but is invalid */
 	case IEEE80211_HT_PARAM_CHA_SEC_NONE:
-		cfg80211_chandef_create(&csa_ie->chandef, new_chan,
+		cfg80211_chandef_create_dup(&csa_ie->chandef, new_chan,
 					NL80211_CHAN_HT20);
 		break;
 	case IEEE80211_HT_PARAM_CHA_SEC_ABOVE:
-		cfg80211_chandef_create(&csa_ie->chandef, new_chan,
+		cfg80211_chandef_create_dup(&csa_ie->chandef, new_chan,
 					NL80211_CHAN_HT40PLUS);
 		break;
 	case IEEE80211_HT_PARAM_CHA_SEC_BELOW:
-		cfg80211_chandef_create(&csa_ie->chandef, new_chan,
+		cfg80211_chandef_create_dup(&csa_ie->chandef, new_chan,
 					NL80211_CHAN_HT40MINUS);
 		break;
 	case -1:
-		cfg80211_chandef_create(&csa_ie->chandef, new_chan,
+		cfg80211_chandef_create_dup(&csa_ie->chandef, new_chan,
 					NL80211_CHAN_NO_HT);
 		/* keep width for 5/10 MHz channels */
 		switch (sdata->vif.bss_conf.chandef.width) {
@@ -135,7 +135,7 @@ int ieee80211_parse_ch_switch_ie(struct
 	if (wide_bw_chansw_ie) {
 		new_vht_chandef.chan = new_chan;
 		new_vht_chandef.center_freq1 =
-			ieee80211_channel_to_frequency(
+			ieee80211_channel_to_frequency_dup(
 				wide_bw_chansw_ie->new_center_freq_seg0,
 				new_band);
 
@@ -154,7 +154,7 @@ int ieee80211_parse_ch_switch_ie(struct
 		case IEEE80211_VHT_CHANWIDTH_80P80MHZ:
 			/* field is otherwise reserved */
 			new_vht_chandef.center_freq2 =
-				ieee80211_channel_to_frequency(
+				ieee80211_channel_to_frequency_dup(
 					wide_bw_chansw_ie->new_center_freq_seg1,
 					new_band);
 			new_vht_chandef.width = NL80211_CHAN_WIDTH_80P80;
@@ -173,7 +173,7 @@ int ieee80211_parse_ch_switch_ie(struct
 
 	/* if VHT data is there validate & use it */
 	if (new_vht_chandef.chan) {
-		if (!cfg80211_chandef_compatible(&new_vht_chandef,
+		if (!cfg80211_chandef_compatible_dup(&new_vht_chandef,
 						 &csa_ie->chandef)) {
 			sdata_info(sdata,
 				   "BSS %pM: CSA has inconsistent channel data, disconnecting\n",
--- a/net/mac80211/sta_info.c	2015-06-23 11:07:42.830850735 +0200
+++ b/net/mac80211/sta_info.c	2015-06-23 14:54:16.693854725 +0200
@@ -522,7 +522,7 @@ static int sta_info_insert_finish(struct
 	memset(&sinfo, 0, sizeof(sinfo));
 	sinfo.filled = 0;
 	sinfo.generation = local->sta_generation;
-	cfg80211_new_sta(sdata->dev, sta->sta.addr, &sinfo, GFP_KERNEL);
+	cfg80211_new_sta_dup(sdata->dev, sta->sta.addr, &sinfo, GFP_KERNEL);
 
 	sta_dbg(sdata, "Inserted STA %pM\n", sta->sta.addr);
 
@@ -755,7 +755,7 @@ static bool sta_info_cleanup_expire_buff
 		 */
 		if (!skb)
 			break;
-		ieee80211_free_txskb(&local->hw, skb);
+		ieee80211_free_txskb_dup(&local->hw, skb);
 	}
 
 	/*
@@ -784,7 +784,7 @@ static bool sta_info_cleanup_expire_buff
 		local->total_ps_buffered--;
 		ps_dbg(sta->sdata, "Buffered frame expired (STA %pM)\n",
 		       sta->sta.addr);
-		ieee80211_free_txskb(&local->hw, skb);
+		ieee80211_free_txskb_dup(&local->hw, skb);
 	}
 
 	/*
@@ -908,7 +908,7 @@ static void __sta_info_destroy_part2(str
 
 	sta_dbg(sdata, "Removed STA %pM\n", sta->sta.addr);
 
-	cfg80211_del_sta(sdata->dev, sta->sta.addr, GFP_KERNEL);
+	cfg80211_del_sta_dup(sdata->dev, sta->sta.addr, GFP_KERNEL);
 
 	rate_control_remove_sta_debugfs(sta);
 	ieee80211_sta_debugfs_remove(sta);
@@ -1055,7 +1055,7 @@ void ieee80211_sta_expire(struct ieee802
 	mutex_unlock(&local->sta_mtx);
 }
 
-struct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,
+struct ieee80211_sta *ieee80211_find_sta_by_ifaddr_dup(struct ieee80211_hw *hw,
 					       const u8 *addr,
 					       const u8 *localaddr)
 {
@@ -1076,9 +1076,9 @@ struct ieee80211_sta *ieee80211_find_sta
 
 	return NULL;
 }
-EXPORT_SYMBOL_GPL(ieee80211_find_sta_by_ifaddr);
+EXPORT_SYMBOL_GPL(ieee80211_find_sta_by_ifaddr_dup);
 
-struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,
+struct ieee80211_sta *ieee80211_find_sta_dup(struct ieee80211_vif *vif,
 					 const u8 *addr)
 {
 	struct sta_info *sta;
@@ -1095,7 +1095,7 @@ struct ieee80211_sta *ieee80211_find_sta
 
 	return &sta->sta;
 }
-EXPORT_SYMBOL(ieee80211_find_sta);
+EXPORT_SYMBOL(ieee80211_find_sta_dup);
 
 /* powersave support code */
 void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)
@@ -1244,7 +1244,7 @@ static void ieee80211_send_null_response
 	 */
 	info->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER |
 		       IEEE80211_TX_CTL_PS_RESPONSE |
-		       IEEE80211_TX_STATUS_EOSP |
+		       ieee80211_tx_status_EOSP |
 		       IEEE80211_TX_CTL_REQ_TX_STATUS;
 
 	if (call_driver)
@@ -1423,7 +1423,7 @@ ieee80211_sta_ps_deliver_response(struct
 
 			if (reason != IEEE80211_FRAME_RELEASE_UAPSD) {
 				/* for PS-Poll, there's only one frame */
-				info->flags |= IEEE80211_TX_STATUS_EOSP |
+				info->flags |= ieee80211_tx_status_EOSP |
 					       IEEE80211_TX_CTL_REQ_TX_STATUS;
 				break;
 			}
@@ -1447,7 +1447,7 @@ ieee80211_sta_ps_deliver_response(struct
 			if (qoshdr) {
 				*qoshdr |= IEEE80211_QOS_CTL_EOSP;
 
-				info->flags |= IEEE80211_TX_STATUS_EOSP |
+				info->flags |= ieee80211_tx_status_EOSP |
 					       IEEE80211_TX_CTL_REQ_TX_STATUS;
 			} else {
 				/* The standard isn't completely clear on this
@@ -1552,7 +1552,7 @@ void ieee80211_sta_ps_deliver_uapsd(stru
 					  IEEE80211_FRAME_RELEASE_UAPSD);
 }
 
-void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
+void ieee80211_sta_block_awake_dup(struct ieee80211_hw *hw,
 			       struct ieee80211_sta *pubsta, bool block)
 {
 	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
@@ -1570,19 +1570,19 @@ void ieee80211_sta_block_awake(struct ie
 	if (!test_sta_flag(sta, WLAN_STA_PS_STA)) {
 		set_sta_flag(sta, WLAN_STA_PS_DELIVER);
 		clear_sta_flag(sta, WLAN_STA_PS_DRIVER);
-		ieee80211_queue_work(hw, &sta->drv_deliver_wk);
+		ieee80211_queue_work_dup(hw, &sta->drv_deliver_wk);
 	} else if (test_sta_flag(sta, WLAN_STA_PSPOLL) ||
 		   test_sta_flag(sta, WLAN_STA_UAPSD)) {
 		/* must be asleep in this case */
 		clear_sta_flag(sta, WLAN_STA_PS_DRIVER);
-		ieee80211_queue_work(hw, &sta->drv_deliver_wk);
+		ieee80211_queue_work_dup(hw, &sta->drv_deliver_wk);
 	} else {
 		clear_sta_flag(sta, WLAN_STA_PS_DRIVER);
 	}
 }
-EXPORT_SYMBOL(ieee80211_sta_block_awake);
+EXPORT_SYMBOL(ieee80211_sta_block_awake_dup);
 
-void ieee80211_sta_eosp(struct ieee80211_sta *pubsta)
+void ieee80211_sta_eosp_dup(struct ieee80211_sta *pubsta)
 {
 	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
 	struct ieee80211_local *local = sta->local;
@@ -1591,9 +1591,9 @@ void ieee80211_sta_eosp(struct ieee80211
 
 	clear_sta_flag(sta, WLAN_STA_SP);
 }
-EXPORT_SYMBOL(ieee80211_sta_eosp);
+EXPORT_SYMBOL(ieee80211_sta_eosp_dup);
 
-void ieee80211_sta_set_buffered(struct ieee80211_sta *pubsta,
+void ieee80211_sta_set_buffered_dup(struct ieee80211_sta *pubsta,
 				u8 tid, bool buffered)
 {
 	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
@@ -1610,7 +1610,7 @@ void ieee80211_sta_set_buffered(struct i
 
 	sta_info_recalc_tim(sta);
 }
-EXPORT_SYMBOL(ieee80211_sta_set_buffered);
+EXPORT_SYMBOL(ieee80211_sta_set_buffered_dup);
 
 int sta_info_move_state(struct sta_info *sta,
 			enum ieee80211_sta_state new_state)
--- a/net/mac80211/status.c	2015-06-23 11:07:42.830850735 +0200
+++ b/net/mac80211/status.c	2015-06-23 14:54:16.748854972 +0200
@@ -22,27 +22,27 @@
 #include "wme.h"
 
 
-void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,
+void ieee80211_tx_status_irqsafe_dup(struct ieee80211_hw *hw,
 				 struct sk_buff *skb)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	int tmp;
 
-	skb->pkt_type = IEEE80211_TX_STATUS_MSG;
+	skb->pkt_type = ieee80211_tx_status_MSG;
 	skb_queue_tail(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS ?
 		       &local->skb_queue : &local->skb_queue_unreliable, skb);
 	tmp = skb_queue_len(&local->skb_queue) +
 		skb_queue_len(&local->skb_queue_unreliable);
 	while (tmp > IEEE80211_IRQSAFE_QUEUE_LIMIT &&
 	       (skb = skb_dequeue(&local->skb_queue_unreliable))) {
-		ieee80211_free_txskb(hw, skb);
+		ieee80211_free_txskb_dup(hw, skb);
 		tmp--;
 		I802_DEBUG_INC(local->tx_status_drop);
 	}
 	tasklet_schedule(&local->tasklet);
 }
-EXPORT_SYMBOL(ieee80211_tx_status_irqsafe);
+EXPORT_SYMBOL(ieee80211_tx_status_irqsafe_dup);
 
 static void ieee80211_handle_filtered_frame(struct ieee80211_local *local,
 					    struct sta_info *sta,
@@ -161,7 +161,7 @@ static void ieee80211_handle_filtered_fr
 			   "dropped TX filtered frame, queue_len=%d PS=%d @%lu\n",
 			   skb_queue_len(&sta->tx_filtered[ac]),
 			   !!test_sta_flag(sta, WLAN_STA_PS_STA), jiffies);
-	ieee80211_free_txskb(&local->hw, skb);
+	ieee80211_free_txskb_dup(&local->hw, skb);
 }
 
 static void ieee80211_check_pending_bar(struct sta_info *sta, u8 *addr, u8 tid)
@@ -173,7 +173,7 @@ static void ieee80211_check_pending_bar(
 		return;
 
 	tid_tx->bar_pending = false;
-	ieee80211_send_bar(&sta->sdata->vif, addr, tid, tid_tx->failed_bar_ssn);
+	ieee80211_send_bar_dup(&sta->sdata->vif, addr, tid, tid_tx->failed_bar_ssn);
 }
 
 static void ieee80211_frame_acked(struct sta_info *sta, struct sk_buff *skb)
@@ -221,7 +221,7 @@ static void ieee80211_frame_acked(struct
 			 * this variable in managed mode is before association.
 			 */
 			sdata->smps_mode = smps_mode;
-			ieee80211_queue_work(&local->hw, &sdata->recalc_smps);
+			ieee80211_queue_work_dup(&local->hw, &sdata->recalc_smps);
 		} else if (sdata->vif.type == NL80211_IFTYPE_AP ||
 			   sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {
 			sta->known_smps_mode = smps_mode;
@@ -467,7 +467,7 @@ static void ieee80211_report_used_skb(st
 			skb->dev = NULL;
 		} else if (info->flags & IEEE80211_TX_INTFL_MLME_CONN_TX) {
 			unsigned int hdr_size =
-				ieee80211_hdrlen(hdr->frame_control);
+				ieee80211_hdrlen_dup(hdr->frame_control);
 
 			/* Check to see if packet is a TDLS teardown packet */
 			if (ieee80211_is_data(hdr->frame_control) &&
@@ -481,10 +481,10 @@ static void ieee80211_report_used_skb(st
 							     acked);
 		} else if (ieee80211_is_nullfunc(hdr->frame_control) ||
 			   ieee80211_is_qos_nullfunc(hdr->frame_control)) {
-			cfg80211_probe_status(sdata->dev, hdr->addr1,
+			cfg80211_probe_status_dup(sdata->dev, hdr->addr1,
 					      cookie, acked, GFP_ATOMIC);
 		} else {
-			cfg80211_mgmt_tx_status(&sdata->wdev, cookie, skb->data,
+			cfg80211_mgmt_tx_status_dup(&sdata->wdev, cookie, skb->data,
 						skb->len, acked, GFP_ATOMIC);
 		}
 
@@ -616,7 +616,7 @@ static void ieee80211_lost_packet(struct
 			 sta->last_tdls_pkt_time + STA_LOST_TDLS_PKT_TIME)))
 		return;
 
-	cfg80211_cqm_pktloss_notify(sta->sdata->dev, sta->sta.addr,
+	cfg80211_cqm_pktloss_notify_dup(sta->sdata->dev, sta->sta.addr,
 				    sta->lost_packets, GFP_ATOMIC);
 	sta->lost_packets = 0;
 }
@@ -656,7 +656,7 @@ static int ieee80211_tx_get_rates(struct
 	return rates_idx;
 }
 
-void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,
+void ieee80211_tx_status_noskb_dup(struct ieee80211_hw *hw,
 			       struct ieee80211_sta *pubsta,
 			       struct ieee80211_tx_info *info)
 {
@@ -708,9 +708,9 @@ void ieee80211_tx_status_noskb(struct ie
 		local->dot11FailedCount++;
 	}
 }
-EXPORT_SYMBOL(ieee80211_tx_status_noskb);
+EXPORT_SYMBOL(ieee80211_tx_status_noskb_dup);
 
-void ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)
+void ieee80211_tx_status_dup(struct ieee80211_hw *hw, struct sk_buff *skb)
 {
 	struct sk_buff *skb2;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
@@ -743,7 +743,7 @@ void ieee80211_tx_status(struct ieee8021
 
 		shift = ieee80211_vif_get_shift(&sta->sdata->vif);
 
-		if (info->flags & IEEE80211_TX_STATUS_EOSP)
+		if (info->flags & ieee80211_tx_status_EOSP)
 			clear_sta_flag(sta, WLAN_STA_SP);
 
 		acked = !!(info->flags & IEEE80211_TX_STAT_ACK);
@@ -778,7 +778,7 @@ void ieee80211_tx_status(struct ieee8021
 			tid = qc[0] & 0xf;
 			ssn = ((le16_to_cpu(hdr->seq_ctrl) + 0x10)
 						& IEEE80211_SCTL_SEQ);
-			ieee80211_send_bar(&sta->sdata->vif, hdr->addr1,
+			ieee80211_send_bar_dup(&sta->sdata->vif, hdr->addr1,
 					   tid, ssn);
 		}
 
@@ -913,7 +913,7 @@ void ieee80211_tx_status(struct ieee8021
 	/* send frame to monitor interfaces now */
 	rtap_len = ieee80211_tx_radiotap_len(info);
 	if (WARN_ON_ONCE(skb_headroom(skb) < rtap_len)) {
-		pr_err("ieee80211_tx_status: headroom too small\n");
+		pr_err("ieee80211_tx_status_dup: headroom too small\n");
 		dev_kfree_skb(skb);
 		return;
 	}
@@ -956,24 +956,24 @@ void ieee80211_tx_status(struct ieee8021
 	rcu_read_unlock();
 	dev_kfree_skb(skb);
 }
-EXPORT_SYMBOL(ieee80211_tx_status);
+EXPORT_SYMBOL(ieee80211_tx_status_dup);
 
-void ieee80211_report_low_ack(struct ieee80211_sta *pubsta, u32 num_packets)
+void ieee80211_report_low_ack_dup(struct ieee80211_sta *pubsta, u32 num_packets)
 {
 	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
-	cfg80211_cqm_pktloss_notify(sta->sdata->dev, sta->sta.addr,
+	cfg80211_cqm_pktloss_notify_dup(sta->sdata->dev, sta->sta.addr,
 				    num_packets, GFP_ATOMIC);
 }
-EXPORT_SYMBOL(ieee80211_report_low_ack);
+EXPORT_SYMBOL(ieee80211_report_low_ack_dup);
 
-void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb)
+void ieee80211_free_txskb_dup(struct ieee80211_hw *hw, struct sk_buff *skb)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
 	ieee80211_report_used_skb(local, skb, true);
 	dev_kfree_skb_any(skb);
 }
-EXPORT_SYMBOL(ieee80211_free_txskb);
+EXPORT_SYMBOL(ieee80211_free_txskb_dup);
 
 void ieee80211_purge_tx_queue(struct ieee80211_hw *hw,
 			      struct sk_buff_head *skbs)
@@ -981,5 +981,5 @@ void ieee80211_purge_tx_queue(struct iee
 	struct sk_buff *skb;
 
 	while ((skb = __skb_dequeue(skbs)))
-		ieee80211_free_txskb(hw, skb);
+		ieee80211_free_txskb_dup(hw, skb);
 }
--- a/net/mac80211/tdls.c	2015-06-23 11:07:42.830850735 +0200
+++ b/net/mac80211/tdls.c	2015-06-23 14:54:16.800855206 +0200
@@ -70,9 +70,9 @@ ieee80211_tdls_add_subband(struct ieee80
 			/* we will be active on the channel */
 			u32 flags = IEEE80211_CHAN_DISABLED |
 				    IEEE80211_CHAN_NO_IR;
-			cfg80211_chandef_create(&chandef, ch,
+			cfg80211_chandef_create_dup(&chandef, ch,
 						NL80211_CHAN_HT20);
-			if (cfg80211_chandef_usable(sdata->local->hw.wiphy,
+			if (cfg80211_chandef_usable_dup(sdata->local->hw.wiphy,
 						    &chandef, flags)) {
 				ch_cnt++;
 				continue;
@@ -81,7 +81,7 @@ ieee80211_tdls_add_subband(struct ieee80
 
 		if (ch_cnt) {
 			u8 *pos = skb_put(skb, 2);
-			*pos++ = ieee80211_frequency_to_channel(subband_start);
+			*pos++ = ieee80211_frequency_to_channel_dup(subband_start);
 			*pos++ = ch_cnt;
 
 			subband_cnt++;
@@ -283,7 +283,7 @@ ieee80211_tdls_add_setup_start_ies(struc
 			WLAN_EID_SUPPORTED_CHANNELS,
 			WLAN_EID_RSN,
 		};
-		noffset = ieee80211_ie_split(extra_ies, extra_ies_len,
+		noffset = ieee80211_ie_split_dup(extra_ies, extra_ies_len,
 					     before_ext_cap,
 					     ARRAY_SIZE(before_ext_cap),
 					     offset);
@@ -313,7 +313,7 @@ ieee80211_tdls_add_setup_start_ies(struc
 			WLAN_EID_TIMEOUT_INTERVAL,
 			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
 		};
-		noffset = ieee80211_ie_split(extra_ies, extra_ies_len,
+		noffset = ieee80211_ie_split_dup(extra_ies, extra_ies_len,
 					     before_ht_cap,
 					     ARRAY_SIZE(before_ht_cap),
 					     offset);
@@ -394,7 +394,7 @@ ieee80211_tdls_add_setup_cfm_ies(struct
 		static const u8 before_qos[] = {
 			WLAN_EID_RSN,
 		};
-		noffset = ieee80211_ie_split(extra_ies, extra_ies_len,
+		noffset = ieee80211_ie_split_dup(extra_ies, extra_ies_len,
 					     before_qos,
 					     ARRAY_SIZE(before_qos),
 					     offset);
@@ -415,7 +415,7 @@ ieee80211_tdls_add_setup_cfm_ies(struct
 			WLAN_EID_FAST_BSS_TRANSITION,
 			WLAN_EID_TIMEOUT_INTERVAL,
 		};
-		noffset = ieee80211_ie_split(extra_ies, extra_ies_len,
+		noffset = ieee80211_ie_split_dup(extra_ies, extra_ies_len,
 					     before_ht_op,
 					     ARRAY_SIZE(before_ht_op),
 					     offset);
@@ -465,14 +465,14 @@ ieee80211_tdls_add_chan_switch_req_ies(s
 
 	tf = (void *)skb->data;
 	tf->u.chan_switch_req.target_channel =
-		ieee80211_frequency_to_channel(chandef->chan->center_freq);
+		ieee80211_frequency_to_channel_dup(chandef->chan->center_freq);
 	tf->u.chan_switch_req.oper_class = oper_class;
 
 	if (extra_ies_len) {
 		static const u8 before_lnkie[] = {
 			WLAN_EID_SECONDARY_CHANNEL_OFFSET,
 		};
-		noffset = ieee80211_ie_split(extra_ies, extra_ies_len,
+		noffset = ieee80211_ie_split_dup(extra_ies, extra_ies_len,
 					     before_lnkie,
 					     ARRAY_SIZE(before_lnkie),
 					     offset);
@@ -923,7 +923,7 @@ ieee80211_tdls_mgmt_setup(struct wiphy *
 		goto exit;
 
 	memcpy(sdata->u.mgd.tdls_peer, peer, ETH_ALEN);
-	ieee80211_queue_delayed_work(&sdata->local->hw,
+	ieee80211_queue_delayed_work_dup(&sdata->local->hw,
 				     &sdata->u.mgd.tdls_peer_del_work,
 				     TDLS_PEER_SETUP_TIMEOUT);
 
@@ -1116,7 +1116,7 @@ int ieee80211_tdls_oper(struct wiphy *wi
 	return ret;
 }
 
-void ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,
+void ieee80211_tdls_oper_request_dup(struct ieee80211_vif *vif, const u8 *peer,
 				 enum nl80211_tdls_operation oper,
 				 u16 reason_code, gfp_t gfp)
 {
@@ -1128,9 +1128,9 @@ void ieee80211_tdls_oper_request(struct
 		return;
 	}
 
-	cfg80211_tdls_oper_request(sdata->dev, peer, oper, reason_code, gfp);
+	cfg80211_tdls_oper_request_dup(sdata->dev, peer, oper, reason_code, gfp);
 }
-EXPORT_SYMBOL(ieee80211_tdls_oper_request);
+EXPORT_SYMBOL(ieee80211_tdls_oper_request_dup);
 
 static void
 iee80211_tdls_add_ch_switch_timing(u8 *buf, u16 switch_time, u16 switch_timeout)
@@ -1159,7 +1159,7 @@ static const u8 *ieee80211_tdls_find_sw_
 	tf = container_of(skb->data + skb_network_offset(skb),
 			  struct ieee80211_tdls_data, payload_type);
 	ie_start = tf->u.chan_switch_req.variable;
-	return cfg80211_find_ie(WLAN_EID_CHAN_SWITCH_TIMING, ie_start,
+	return cfg80211_find_ie_dup(WLAN_EID_CHAN_SWITCH_TIMING, ie_start,
 				skb->len - (ie_start - skb->data));
 }
 
@@ -1488,7 +1488,7 @@ ieee80211_process_tdls_channel_switch_re
 		band = target_channel < 14 ? IEEE80211_BAND_2GHZ :
 					     IEEE80211_BAND_5GHZ;
 
-	freq = ieee80211_channel_to_frequency(target_channel, band);
+	freq = ieee80211_channel_to_frequency_dup(target_channel, band);
 	if (freq == 0) {
 		tdls_dbg(sdata, "Invalid channel in TDLS chan switch: %d\n",
 			 target_channel);
@@ -1553,7 +1553,7 @@ ieee80211_process_tdls_channel_switch_re
 		}
 	}
 
-	cfg80211_chandef_create(&chandef, chan, chan_type);
+	cfg80211_chandef_create_dup(&chandef, chan, chan_type);
 	params.chandef = &chandef;
 
 	params.switch_time = le16_to_cpu(elems.ch_sw_timing->switch_time);
--- a/net/mac80211/tkip.c	2015-06-23 11:07:42.830850735 +0200
+++ b/net/mac80211/tkip.c	2015-06-23 14:54:16.866855502 +0200
@@ -171,7 +171,7 @@ static void ieee80211_compute_tkip_p1k(s
 		tkip_mixing_phase1(tk, ctx, sdata->vif.addr, iv32);
 }
 
-void ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_p1k_iv_dup(struct ieee80211_key_conf *keyconf,
 			       u32 iv32, u16 *p1k)
 {
 	struct ieee80211_key *key = (struct ieee80211_key *)
@@ -183,9 +183,9 @@ void ieee80211_get_tkip_p1k_iv(struct ie
 	memcpy(p1k, ctx->p1k, sizeof(ctx->p1k));
 	spin_unlock_bh(&key->u.tkip.txlock);
 }
-EXPORT_SYMBOL(ieee80211_get_tkip_p1k_iv);
+EXPORT_SYMBOL(ieee80211_get_tkip_p1k_iv_dup);
 
-void ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_rx_p1k_dup(struct ieee80211_key_conf *keyconf,
 			       const u8 *ta, u32 iv32, u16 *p1k)
 {
 	const u8 *tk = &keyconf->key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];
@@ -194,9 +194,9 @@ void ieee80211_get_tkip_rx_p1k(struct ie
 	tkip_mixing_phase1(tk, &ctx, ta, iv32);
 	memcpy(p1k, ctx.p1k, sizeof(ctx.p1k));
 }
-EXPORT_SYMBOL(ieee80211_get_tkip_rx_p1k);
+EXPORT_SYMBOL(ieee80211_get_tkip_rx_p1k_dup);
 
-void ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_p2k_dup(struct ieee80211_key_conf *keyconf,
 			    struct sk_buff *skb, u8 *p2k)
 {
 	struct ieee80211_key *key = (struct ieee80211_key *)
@@ -204,7 +204,7 @@ void ieee80211_get_tkip_p2k(struct ieee8
 	const u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];
 	struct tkip_ctx *ctx = &key->u.tkip.tx;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	const u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);
+	const u8 *data = (u8 *)hdr + ieee80211_hdrlen_dup(hdr->frame_control);
 	u32 iv32 = get_unaligned_le32(&data[4]);
 	u16 iv16 = data[2] | (data[0] << 8);
 
@@ -213,7 +213,7 @@ void ieee80211_get_tkip_p2k(struct ieee8
 	tkip_mixing_phase2(tk, ctx, iv16, p2k);
 	spin_unlock(&key->u.tkip.txlock);
 }
-EXPORT_SYMBOL(ieee80211_get_tkip_p2k);
+EXPORT_SYMBOL(ieee80211_get_tkip_p2k_dup);
 
 /*
  * Encrypt packet payload with TKIP using @key. @pos is a pointer to the
@@ -229,7 +229,7 @@ int ieee80211_tkip_encrypt_data(struct c
 {
 	u8 rc4key[16];
 
-	ieee80211_get_tkip_p2k(&key->conf, skb, rc4key);
+	ieee80211_get_tkip_p2k_dup(&key->conf, skb, rc4key);
 
 	return ieee80211_wep_encrypt_data(tfm, rc4key, 16,
 					  payload, payload_len);
--- a/net/mac80211/tx.c	2015-06-23 11:07:42.831850747 +0200
+++ b/net/mac80211/tx.c	2015-06-23 14:54:16.919855740 +0200
@@ -249,12 +249,12 @@ ieee80211_tx_h_dynamic_ps(struct ieee802
 		return TX_CONTINUE;
 
 	if (local->hw.conf.flags & IEEE80211_CONF_PS) {
-		ieee80211_stop_queues_by_reason(&local->hw,
+		ieee80211_stop_queues_by_reason_dup(&local->hw,
 						IEEE80211_MAX_QUEUE_MAP,
 						IEEE80211_QUEUE_STOP_REASON_PS,
 						false);
 		ifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;
-		ieee80211_queue_work(&local->hw,
+		ieee80211_queue_work_dup(&local->hw,
 				     &local->dynamic_ps_disable_work);
 	}
 
@@ -376,7 +376,7 @@ static void purge_old_ps_buffers(struct
 			total += skb_queue_len(&sta->ps_tx_buf[ac]);
 			if (skb) {
 				purged++;
-				ieee80211_free_txskb(&local->hw, skb);
+				ieee80211_free_txskb_dup(&local->hw, skb);
 				break;
 			}
 		}
@@ -513,7 +513,7 @@ ieee80211_tx_h_unicast_ps_buf(struct iee
 			ps_dbg(tx->sdata,
 			       "STA %pM TX buffer for AC %d full - dropping oldest frame\n",
 			       sta->sta.addr, ac);
-			ieee80211_free_txskb(&local->hw, old);
+			ieee80211_free_txskb_dup(&local->hw, old);
 		} else
 			tx->local->total_ps_buffered++;
 
@@ -797,7 +797,7 @@ ieee80211_tx_h_sequence(struct ieee80211
 	if (unlikely(ieee80211_is_ctl(hdr->frame_control)))
 		return TX_CONTINUE;
 
-	if (ieee80211_hdrlen(hdr->frame_control) < 24)
+	if (ieee80211_hdrlen_dup(hdr->frame_control) < 24)
 		return TX_CONTINUE;
 
 	if (ieee80211_is_qos_nullfunc(hdr->frame_control))
@@ -929,7 +929,7 @@ ieee80211_tx_h_fragment(struct ieee80211
 	if (WARN_ON(info->flags & IEEE80211_TX_CTL_AMPDU))
 		return TX_DROP;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 
 	/* internal error, why isn't DONTFRAG set? */
 	if (WARN_ON(skb->len + FCS_LEN <= frag_threshold))
@@ -1104,7 +1104,7 @@ static bool ieee80211_tx_prep_agg(struct
 		spin_unlock(&tx->sta->lock);
 
 		if (purge_skb)
-			ieee80211_free_txskb(&tx->local->hw, purge_skb);
+			ieee80211_free_txskb_dup(&tx->local->hw, purge_skb);
 	}
 
 	/* reset session timer */
@@ -1216,7 +1216,7 @@ static bool ieee80211_tx_frags(struct ie
 #ifdef CONFIG_MAC80211_VERBOSE_DEBUG
 		if (WARN_ON_ONCE(q >= local->hw.queues)) {
 			__skb_unlink(skb, skbs);
-			ieee80211_free_txskb(&local->hw, skb);
+			ieee80211_free_txskb_dup(&local->hw, skb);
 			continue;
 		}
 #endif
@@ -1382,7 +1382,7 @@ static int invoke_tx_handlers(struct iee
 	if (unlikely(res == TX_DROP)) {
 		I802_DEBUG_INC(tx->local->tx_handlers_drop);
 		if (tx->skb)
-			ieee80211_free_txskb(&tx->local->hw, tx->skb);
+			ieee80211_free_txskb_dup(&tx->local->hw, tx->skb);
 		else
 			ieee80211_purge_tx_queue(&tx->local->hw, &tx->skbs);
 		return -1;
@@ -1394,7 +1394,7 @@ static int invoke_tx_handlers(struct iee
 	return 0;
 }
 
-bool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,
+bool ieee80211_tx_prepare_skb_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif, struct sk_buff *skb,
 			      int band, struct ieee80211_sta **sta)
 {
@@ -1421,7 +1421,7 @@ bool ieee80211_tx_prepare_skb(struct iee
 
 	return true;
 }
-EXPORT_SYMBOL(ieee80211_tx_prepare_skb);
+EXPORT_SYMBOL(ieee80211_tx_prepare_skb_dup);
 
 /*
  * Returns false if the frame couldn't be transmitted but was queued instead.
@@ -1446,7 +1446,7 @@ static bool ieee80211_tx(struct ieee8021
 	res_prepare = ieee80211_tx_prepare(sdata, &tx, skb);
 
 	if (unlikely(res_prepare == TX_DROP)) {
-		ieee80211_free_txskb(&local->hw, skb);
+		ieee80211_free_txskb_dup(&local->hw, skb);
 		return true;
 	} else if (unlikely(res_prepare == TX_QUEUED)) {
 		return true;
@@ -1516,7 +1516,7 @@ void ieee80211_xmit(struct ieee80211_sub
 	headroom = max_t(int, 0, headroom);
 
 	if (ieee80211_skb_resize(sdata, skb, headroom, may_encrypt)) {
-		ieee80211_free_txskb(&local->hw, skb);
+		ieee80211_free_txskb_dup(&local->hw, skb);
 		return;
 	}
 
@@ -1543,7 +1543,7 @@ static bool ieee80211_parse_tx_radiotap(
 	struct ieee80211_radiotap_header *rthdr =
 		(struct ieee80211_radiotap_header *) skb->data;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	int ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,
+	int ret = ieee80211_radiotap_iterator_init_dup(&iterator, rthdr, skb->len,
 						   NULL);
 	u16 txflags;
 
@@ -1552,12 +1552,12 @@ static bool ieee80211_parse_tx_radiotap(
 
 	/*
 	 * for every radiotap entry that is present
-	 * (ieee80211_radiotap_iterator_next returns -ENOENT when no more
+	 * (ieee80211_radiotap_iterator_next_dup returns -ENOENT when no more
 	 * entries present, or -EINVAL on error)
 	 */
 
 	while (!ret) {
-		ret = ieee80211_radiotap_iterator_next(&iterator);
+		ret = ieee80211_radiotap_iterator_next_dup(&iterator);
 
 		if (ret)
 			continue;
@@ -1667,7 +1667,7 @@ netdev_tx_t ieee80211_monitor_start_xmit
 		goto fail;
 
 	hdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 
 	if (skb->len < len_rthdr + hdrlen)
 		goto fail;
@@ -1677,10 +1677,10 @@ netdev_tx_t ieee80211_monitor_start_xmit
 	 * carrying a rfc1042 header
 	 */
 	if (ieee80211_is_data(hdr->frame_control) &&
-	    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {
+	    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header_dup) + 2) {
 		u8 *payload = (u8 *)hdr + hdrlen;
 
-		if (ether_addr_equal(payload, rfc1042_header))
+		if (ether_addr_equal(payload, rfc1042_header_dup))
 			skb->protocol = cpu_to_be16((payload[6] << 8) |
 						    payload[7]);
 	}
@@ -1750,7 +1750,7 @@ netdev_tx_t ieee80211_monitor_start_xmit
 	 * radar detection by itself. We can do that later by adding a
 	 * monitor flag interfaces used for AP support.
 	 */
-	if (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,
+	if (!cfg80211_reg_can_beacon_dup(local->hw.wiphy, chandef,
 				     sdata->vif.type))
 		goto fail_rcu;
 
@@ -2142,12 +2142,12 @@ static struct sk_buff *ieee80211_build_h
 
 	skip_header_bytes = ETH_HLEN;
 	if (ethertype == ETH_P_AARP || ethertype == ETH_P_IPX) {
-		encaps_data = bridge_tunnel_header;
-		encaps_len = sizeof(bridge_tunnel_header);
+		encaps_data = bridge_tunnel_header_dup;
+		encaps_len = sizeof(bridge_tunnel_header_dup);
 		skip_header_bytes -= 2;
 	} else if (ethertype >= ETH_P_802_3_MIN) {
-		encaps_data = rfc1042_header;
-		encaps_len = sizeof(rfc1042_header);
+		encaps_data = rfc1042_header_dup;
+		encaps_len = sizeof(rfc1042_header_dup);
 		skip_header_bytes -= 2;
 	} else {
 		encaps_data = NULL;
@@ -2180,7 +2180,7 @@ static struct sk_buff *ieee80211_build_h
 		head_need += local->tx_headroom;
 		head_need = max_t(int, 0, head_need);
 		if (ieee80211_skb_resize(sdata, skb, head_need, true)) {
-			ieee80211_free_txskb(&local->hw, skb);
+			ieee80211_free_txskb_dup(&local->hw, skb);
 			skb = NULL;
 			return ERR_PTR(-ENOMEM);
 		}
@@ -2322,7 +2322,7 @@ void ieee80211_clear_tx_pending(struct i
 
 	for (i = 0; i < local->hw.queues; i++) {
 		while ((skb = skb_dequeue(&local->pending[i])) != NULL)
-			ieee80211_free_txskb(&local->hw, skb);
+			ieee80211_free_txskb_dup(&local->hw, skb);
 	}
 }
 
@@ -2393,7 +2393,7 @@ void ieee80211_tx_pending(unsigned long
 			struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 
 			if (WARN_ON(!info->control.vif)) {
-				ieee80211_free_txskb(&local->hw, skb);
+				ieee80211_free_txskb_dup(&local->hw, skb);
 				continue;
 			}
 
@@ -2552,7 +2552,7 @@ static void ieee80211_set_csa(struct iee
 	rcu_read_unlock();
 }
 
-u8 ieee80211_csa_update_counter(struct ieee80211_vif *vif)
+u8 ieee80211_csa_update_counter_dup(struct ieee80211_vif *vif)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct beacon_data *beacon = NULL;
@@ -2580,9 +2580,9 @@ unlock:
 	rcu_read_unlock();
 	return count;
 }
-EXPORT_SYMBOL(ieee80211_csa_update_counter);
+EXPORT_SYMBOL(ieee80211_csa_update_counter_dup);
 
-bool ieee80211_csa_is_complete(struct ieee80211_vif *vif)
+bool ieee80211_csa_is_complete_dup(struct ieee80211_vif *vif)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct beacon_data *beacon = NULL;
@@ -2638,7 +2638,7 @@ bool ieee80211_csa_is_complete(struct ie
 
 	return ret;
 }
-EXPORT_SYMBOL(ieee80211_csa_is_complete);
+EXPORT_SYMBOL(ieee80211_csa_is_complete_dup);
 
 static struct sk_buff *
 __ieee80211_beacon_get(struct ieee80211_hw *hw,
@@ -2674,7 +2674,7 @@ __ieee80211_beacon_get(struct ieee80211_
 		if (beacon) {
 			if (beacon->csa_counter_offsets[0]) {
 				if (!is_template)
-					ieee80211_csa_update_counter(vif);
+					ieee80211_csa_update_counter_dup(vif);
 
 				ieee80211_set_csa(sdata, beacon);
 			}
@@ -2720,7 +2720,7 @@ __ieee80211_beacon_get(struct ieee80211_
 
 		if (beacon->csa_counter_offsets[0]) {
 			if (!is_template)
-				ieee80211_csa_update_counter(vif);
+				ieee80211_csa_update_counter_dup(vif);
 
 			ieee80211_set_csa(sdata, beacon);
 		}
@@ -2750,7 +2750,7 @@ __ieee80211_beacon_get(struct ieee80211_
 				 * for now we leave it consistent with overall
 				 * mac80211's behavior.
 				 */
-				ieee80211_csa_update_counter(vif);
+				ieee80211_csa_update_counter_dup(vif);
 
 			ieee80211_set_csa(sdata, beacon);
 		}
@@ -2830,15 +2830,15 @@ __ieee80211_beacon_get(struct ieee80211_
 }
 
 struct sk_buff *
-ieee80211_beacon_get_template(struct ieee80211_hw *hw,
+ieee80211_beacon_get_template_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif,
 			      struct ieee80211_mutable_offsets *offs)
 {
 	return __ieee80211_beacon_get(hw, vif, offs, true);
 }
-EXPORT_SYMBOL(ieee80211_beacon_get_template);
+EXPORT_SYMBOL(ieee80211_beacon_get_template_dup);
 
-struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_beacon_get_tim_dup(struct ieee80211_hw *hw,
 					 struct ieee80211_vif *vif,
 					 u16 *tim_offset, u16 *tim_length)
 {
@@ -2853,9 +2853,9 @@ struct sk_buff *ieee80211_beacon_get_tim
 
 	return bcn;
 }
-EXPORT_SYMBOL(ieee80211_beacon_get_tim);
+EXPORT_SYMBOL(ieee80211_beacon_get_tim_dup);
 
-struct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_proberesp_get_dup(struct ieee80211_hw *hw,
 					struct ieee80211_vif *vif)
 {
 	struct ieee80211_if_ap *ap = NULL;
@@ -2887,9 +2887,9 @@ out:
 	rcu_read_unlock();
 	return skb;
 }
-EXPORT_SYMBOL(ieee80211_proberesp_get);
+EXPORT_SYMBOL(ieee80211_proberesp_get_dup);
 
-struct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_pspoll_get_dup(struct ieee80211_hw *hw,
 				     struct ieee80211_vif *vif)
 {
 	struct ieee80211_sub_if_data *sdata;
@@ -2925,9 +2925,9 @@ struct sk_buff *ieee80211_pspoll_get(str
 
 	return skb;
 }
-EXPORT_SYMBOL(ieee80211_pspoll_get);
+EXPORT_SYMBOL(ieee80211_pspoll_get_dup);
 
-struct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_nullfunc_get_dup(struct ieee80211_hw *hw,
 				       struct ieee80211_vif *vif)
 {
 	struct ieee80211_hdr_3addr *nullfunc;
@@ -2961,9 +2961,9 @@ struct sk_buff *ieee80211_nullfunc_get(s
 
 	return skb;
 }
-EXPORT_SYMBOL(ieee80211_nullfunc_get);
+EXPORT_SYMBOL(ieee80211_nullfunc_get_dup);
 
-struct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_probereq_get_dup(struct ieee80211_hw *hw,
 				       const u8 *src_addr,
 				       const u8 *ssid, size_t ssid_len,
 				       size_t tailroom)
@@ -3000,9 +3000,9 @@ struct sk_buff *ieee80211_probereq_get(s
 
 	return skb;
 }
-EXPORT_SYMBOL(ieee80211_probereq_get);
+EXPORT_SYMBOL(ieee80211_probereq_get_dup);
 
-void ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+void ieee80211_rts_get_dup(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		       const void *frame, size_t frame_len,
 		       const struct ieee80211_tx_info *frame_txctl,
 		       struct ieee80211_rts *rts)
@@ -3011,14 +3011,14 @@ void ieee80211_rts_get(struct ieee80211_
 
 	rts->frame_control =
 	    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_RTS);
-	rts->duration = ieee80211_rts_duration(hw, vif, frame_len,
+	rts->duration = ieee80211_rts_duration_dup(hw, vif, frame_len,
 					       frame_txctl);
 	memcpy(rts->ra, hdr->addr1, sizeof(rts->ra));
 	memcpy(rts->ta, hdr->addr2, sizeof(rts->ta));
 }
-EXPORT_SYMBOL(ieee80211_rts_get);
+EXPORT_SYMBOL(ieee80211_rts_get_dup);
 
-void ieee80211_ctstoself_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+void ieee80211_ctstoself_get_dup(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			     const void *frame, size_t frame_len,
 			     const struct ieee80211_tx_info *frame_txctl,
 			     struct ieee80211_cts *cts)
@@ -3027,14 +3027,14 @@ void ieee80211_ctstoself_get(struct ieee
 
 	cts->frame_control =
 	    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CTS);
-	cts->duration = ieee80211_ctstoself_duration(hw, vif,
+	cts->duration = ieee80211_ctstoself_duration_dup(hw, vif,
 						     frame_len, frame_txctl);
 	memcpy(cts->ra, hdr->addr1, sizeof(cts->ra));
 }
-EXPORT_SYMBOL(ieee80211_ctstoself_get);
+EXPORT_SYMBOL(ieee80211_ctstoself_get_dup);
 
 struct sk_buff *
-ieee80211_get_buffered_bc(struct ieee80211_hw *hw,
+ieee80211_get_buffered_bc_dup(struct ieee80211_hw *hw,
 			  struct ieee80211_vif *vif)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
@@ -3105,9 +3105,9 @@ ieee80211_get_buffered_bc(struct ieee802
 
 	return skb;
 }
-EXPORT_SYMBOL(ieee80211_get_buffered_bc);
+EXPORT_SYMBOL(ieee80211_get_buffered_bc_dup);
 
-int ieee80211_reserve_tid(struct ieee80211_sta *pubsta, u8 tid)
+int ieee80211_reserve_tid_dup(struct ieee80211_sta *pubsta, u8 tid)
 {
 	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
 	struct ieee80211_sub_if_data *sdata = sta->sdata;
@@ -3150,7 +3150,7 @@ int ieee80211_reserve_tid(struct ieee802
 	/* Tear down BA sessions so we stop aggregating on this TID */
 	if (local->hw.flags & IEEE80211_HW_AMPDU_AGGREGATION) {
 		set_sta_flag(sta, WLAN_STA_BLOCK_BA);
-		__ieee80211_stop_tx_ba_session(sta, tid,
+		__ieee80211_stop_tx_ba_session_dup(sta, tid,
 					       AGG_STOP_LOCAL_REQUEST);
 	}
 
@@ -3169,9 +3169,9 @@ int ieee80211_reserve_tid(struct ieee802
  out:
 	return ret;
 }
-EXPORT_SYMBOL(ieee80211_reserve_tid);
+EXPORT_SYMBOL(ieee80211_reserve_tid_dup);
 
-void ieee80211_unreserve_tid(struct ieee80211_sta *pubsta, u8 tid)
+void ieee80211_unreserve_tid_dup(struct ieee80211_sta *pubsta, u8 tid)
 {
 	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
 	struct ieee80211_sub_if_data *sdata = sta->sdata;
@@ -3196,7 +3196,7 @@ void ieee80211_unreserve_tid(struct ieee
 
 	sta->reserved_tid = IEEE80211_TID_UNRESERVED;
 }
-EXPORT_SYMBOL(ieee80211_unreserve_tid);
+EXPORT_SYMBOL(ieee80211_unreserve_tid_dup);
 
 void __ieee80211_tx_skb_tid_band(struct ieee80211_sub_if_data *sdata,
 				 struct sk_buff *skb, int tid,
--- a/net/mac80211/util.c	2015-06-23 11:07:42.832850758 +0200
+++ b/net/mac80211/util.c	2015-06-23 14:54:16.975855992 +0200
@@ -37,7 +37,7 @@
 /* privid for wiphys to determine whether they belong to us or not */
 const void *const mac80211_wiphy_privid = &mac80211_wiphy_privid;
 
-struct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy)
+struct ieee80211_hw *wiphy_to_ieee80211_hw_dup(struct wiphy *wiphy)
 {
 	struct ieee80211_local *local;
 	BUG_ON(!wiphy);
@@ -45,7 +45,7 @@ struct ieee80211_hw *wiphy_to_ieee80211_
 	local = wiphy_priv(wiphy);
 	return &local->hw;
 }
-EXPORT_SYMBOL(wiphy_to_ieee80211_hw);
+EXPORT_SYMBOL(wiphy_to_ieee80211_hw_dup);
 
 u8 *ieee80211_get_bssid(struct ieee80211_hdr *hdr, size_t len,
 			enum nl80211_iftype type)
@@ -175,7 +175,7 @@ int ieee80211_frame_duration(enum ieee80
 }
 
 /* Exported duration function for driver use */
-__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_generic_frame_duration_dup(struct ieee80211_hw *hw,
 					struct ieee80211_vif *vif,
 					enum ieee80211_band band,
 					size_t frame_len,
@@ -200,9 +200,9 @@ __le16 ieee80211_generic_frame_duration(
 
 	return cpu_to_le16(dur);
 }
-EXPORT_SYMBOL(ieee80211_generic_frame_duration);
+EXPORT_SYMBOL(ieee80211_generic_frame_duration_dup);
 
-__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_rts_duration_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif, size_t frame_len,
 			      const struct ieee80211_tx_info *frame_txctl)
 {
@@ -243,9 +243,9 @@ __le16 ieee80211_rts_duration(struct iee
 
 	return cpu_to_le16(dur);
 }
-EXPORT_SYMBOL(ieee80211_rts_duration);
+EXPORT_SYMBOL(ieee80211_rts_duration_dup);
 
-__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_ctstoself_duration_dup(struct ieee80211_hw *hw,
 				    struct ieee80211_vif *vif,
 				    size_t frame_len,
 				    const struct ieee80211_tx_info *frame_txctl)
@@ -285,7 +285,7 @@ __le16 ieee80211_ctstoself_duration(stru
 
 	return cpu_to_le16(dur);
 }
-EXPORT_SYMBOL(ieee80211_ctstoself_duration);
+EXPORT_SYMBOL(ieee80211_ctstoself_duration_dup);
 
 void ieee80211_propagate_queue_wake(struct ieee80211_local *local, int queue)
 {
@@ -317,7 +317,7 @@ void ieee80211_propagate_queue_wake(stru
 	}
 }
 
-static void __ieee80211_wake_queue(struct ieee80211_hw *hw, int queue,
+static void __ieee80211_wake_queue_dup(struct ieee80211_hw *hw, int queue,
 				   enum queue_stop_reason reason,
 				   bool refcounted)
 {
@@ -359,19 +359,19 @@ void ieee80211_wake_queue_by_reason(stru
 	unsigned long flags;
 
 	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-	__ieee80211_wake_queue(hw, queue, reason, refcounted);
+	__ieee80211_wake_queue_dup(hw, queue, reason, refcounted);
 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
 }
 
-void ieee80211_wake_queue(struct ieee80211_hw *hw, int queue)
+void ieee80211_wake_queue_dup(struct ieee80211_hw *hw, int queue)
 {
 	ieee80211_wake_queue_by_reason(hw, queue,
 				       IEEE80211_QUEUE_STOP_REASON_DRIVER,
 				       false);
 }
-EXPORT_SYMBOL(ieee80211_wake_queue);
+EXPORT_SYMBOL(ieee80211_wake_queue_dup);
 
-static void __ieee80211_stop_queue(struct ieee80211_hw *hw, int queue,
+static void __ieee80211_stop_queue_dup(struct ieee80211_hw *hw, int queue,
 				   enum queue_stop_reason reason,
 				   bool refcounted)
 {
@@ -419,17 +419,17 @@ void ieee80211_stop_queue_by_reason(stru
 	unsigned long flags;
 
 	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-	__ieee80211_stop_queue(hw, queue, reason, refcounted);
+	__ieee80211_stop_queue_dup(hw, queue, reason, refcounted);
 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
 }
 
-void ieee80211_stop_queue(struct ieee80211_hw *hw, int queue)
+void ieee80211_stop_queue_dup(struct ieee80211_hw *hw, int queue)
 {
 	ieee80211_stop_queue_by_reason(hw, queue,
 				       IEEE80211_QUEUE_STOP_REASON_DRIVER,
 				       false);
 }
-EXPORT_SYMBOL(ieee80211_stop_queue);
+EXPORT_SYMBOL(ieee80211_stop_queue_dup);
 
 void ieee80211_add_pending_skb(struct ieee80211_local *local,
 			       struct sk_buff *skb)
@@ -440,15 +440,15 @@ void ieee80211_add_pending_skb(struct ie
 	int queue = info->hw_queue;
 
 	if (WARN_ON(!info->control.vif)) {
-		ieee80211_free_txskb(&local->hw, skb);
+		ieee80211_free_txskb_dup(&local->hw, skb);
 		return;
 	}
 
 	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-	__ieee80211_stop_queue(hw, queue, IEEE80211_QUEUE_STOP_REASON_SKB_ADD,
+	__ieee80211_stop_queue_dup(hw, queue, IEEE80211_QUEUE_STOP_REASON_SKB_ADD,
 			       false);
 	__skb_queue_tail(&local->pending[queue], skb);
-	__ieee80211_wake_queue(hw, queue, IEEE80211_QUEUE_STOP_REASON_SKB_ADD,
+	__ieee80211_wake_queue_dup(hw, queue, IEEE80211_QUEUE_STOP_REASON_SKB_ADD,
 			       false);
 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
 }
@@ -466,13 +466,13 @@ void ieee80211_add_pending_skbs(struct i
 		struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 
 		if (WARN_ON(!info->control.vif)) {
-			ieee80211_free_txskb(&local->hw, skb);
+			ieee80211_free_txskb_dup(&local->hw, skb);
 			continue;
 		}
 
 		queue = info->hw_queue;
 
-		__ieee80211_stop_queue(hw, queue,
+		__ieee80211_stop_queue_dup(hw, queue,
 				IEEE80211_QUEUE_STOP_REASON_SKB_ADD,
 				false);
 
@@ -480,13 +480,13 @@ void ieee80211_add_pending_skbs(struct i
 	}
 
 	for (i = 0; i < hw->queues; i++)
-		__ieee80211_wake_queue(hw, i,
+		__ieee80211_wake_queue_dup(hw, i,
 			IEEE80211_QUEUE_STOP_REASON_SKB_ADD,
 			false);
 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
 }
 
-void ieee80211_stop_queues_by_reason(struct ieee80211_hw *hw,
+void ieee80211_stop_queues_by_reason_dup(struct ieee80211_hw *hw,
 				     unsigned long queues,
 				     enum queue_stop_reason reason,
 				     bool refcounted)
@@ -498,20 +498,20 @@ void ieee80211_stop_queues_by_reason(str
 	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
 
 	for_each_set_bit(i, &queues, hw->queues)
-		__ieee80211_stop_queue(hw, i, reason, refcounted);
+		__ieee80211_stop_queue_dup(hw, i, reason, refcounted);
 
 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
 }
 
-void ieee80211_stop_queues(struct ieee80211_hw *hw)
+void ieee80211_stop_queues_dup(struct ieee80211_hw *hw)
 {
-	ieee80211_stop_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,
+	ieee80211_stop_queues_by_reason_dup(hw, IEEE80211_MAX_QUEUE_MAP,
 					IEEE80211_QUEUE_STOP_REASON_DRIVER,
 					false);
 }
-EXPORT_SYMBOL(ieee80211_stop_queues);
+EXPORT_SYMBOL(ieee80211_stop_queues_dup);
 
-int ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue)
+int ieee80211_queue_stopped_dup(struct ieee80211_hw *hw, int queue)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 	unsigned long flags;
@@ -526,9 +526,9 @@ int ieee80211_queue_stopped(struct ieee8
 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
 	return ret;
 }
-EXPORT_SYMBOL(ieee80211_queue_stopped);
+EXPORT_SYMBOL(ieee80211_queue_stopped_dup);
 
-void ieee80211_wake_queues_by_reason(struct ieee80211_hw *hw,
+void ieee80211_wake_queues_by_reason_dup(struct ieee80211_hw *hw,
 				     unsigned long queues,
 				     enum queue_stop_reason reason,
 				     bool refcounted)
@@ -540,18 +540,18 @@ void ieee80211_wake_queues_by_reason(str
 	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
 
 	for_each_set_bit(i, &queues, hw->queues)
-		__ieee80211_wake_queue(hw, i, reason, refcounted);
+		__ieee80211_wake_queue_dup(hw, i, reason, refcounted);
 
 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
 }
 
-void ieee80211_wake_queues(struct ieee80211_hw *hw)
+void ieee80211_wake_queues_dup(struct ieee80211_hw *hw)
 {
-	ieee80211_wake_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,
+	ieee80211_wake_queues_by_reason_dup(hw, IEEE80211_MAX_QUEUE_MAP,
 					IEEE80211_QUEUE_STOP_REASON_DRIVER,
 					false);
 }
-EXPORT_SYMBOL(ieee80211_wake_queues);
+EXPORT_SYMBOL(ieee80211_wake_queues_dup);
 
 static unsigned int
 ieee80211_get_vif_queues(struct ieee80211_local *local,
@@ -590,13 +590,13 @@ void __ieee80211_flush_queues(struct iee
 	if (!queues || !(local->hw.flags & IEEE80211_HW_QUEUE_CONTROL))
 		queues = ieee80211_get_vif_queues(local, sdata);
 
-	ieee80211_stop_queues_by_reason(&local->hw, queues,
+	ieee80211_stop_queues_by_reason_dup(&local->hw, queues,
 					IEEE80211_QUEUE_STOP_REASON_FLUSH,
 					false);
 
 	drv_flush(local, sdata, queues, false);
 
-	ieee80211_wake_queues_by_reason(&local->hw, queues,
+	ieee80211_wake_queues_by_reason_dup(&local->hw, queues,
 					IEEE80211_QUEUE_STOP_REASON_FLUSH,
 					false);
 }
@@ -611,7 +611,7 @@ void ieee80211_stop_vif_queues(struct ie
 			       struct ieee80211_sub_if_data *sdata,
 			       enum queue_stop_reason reason)
 {
-	ieee80211_stop_queues_by_reason(&local->hw,
+	ieee80211_stop_queues_by_reason_dup(&local->hw,
 					ieee80211_get_vif_queues(local, sdata),
 					reason, true);
 }
@@ -620,7 +620,7 @@ void ieee80211_wake_vif_queues(struct ie
 			       struct ieee80211_sub_if_data *sdata,
 			       enum queue_stop_reason reason)
 {
-	ieee80211_wake_queues_by_reason(&local->hw,
+	ieee80211_wake_queues_by_reason_dup(&local->hw,
 					ieee80211_get_vif_queues(local, sdata),
 					reason, true);
 }
@@ -661,7 +661,7 @@ static void __iterate_active_interfaces(
 		iterator(data, sdata->vif.addr, &sdata->vif);
 }
 
-void ieee80211_iterate_active_interfaces(
+void ieee80211_iterate_active_interfaces_dup(
 	struct ieee80211_hw *hw, u32 iter_flags,
 	void (*iterator)(void *data, u8 *mac,
 			 struct ieee80211_vif *vif),
@@ -673,9 +673,9 @@ void ieee80211_iterate_active_interfaces
 	__iterate_active_interfaces(local, iter_flags, iterator, data);
 	mutex_unlock(&local->iflist_mtx);
 }
-EXPORT_SYMBOL_GPL(ieee80211_iterate_active_interfaces);
+EXPORT_SYMBOL_GPL(ieee80211_iterate_active_interfaces_dup);
 
-void ieee80211_iterate_active_interfaces_atomic(
+void ieee80211_iterate_active_interfaces_atomic_dup(
 	struct ieee80211_hw *hw, u32 iter_flags,
 	void (*iterator)(void *data, u8 *mac,
 			 struct ieee80211_vif *vif),
@@ -687,9 +687,9 @@ void ieee80211_iterate_active_interfaces
 	__iterate_active_interfaces(local, iter_flags, iterator, data);
 	rcu_read_unlock();
 }
-EXPORT_SYMBOL_GPL(ieee80211_iterate_active_interfaces_atomic);
+EXPORT_SYMBOL_GPL(ieee80211_iterate_active_interfaces_atomic_dup);
 
-void ieee80211_iterate_active_interfaces_rtnl(
+void ieee80211_iterate_active_interfaces_rtnl_dup(
 	struct ieee80211_hw *hw, u32 iter_flags,
 	void (*iterator)(void *data, u8 *mac,
 			 struct ieee80211_vif *vif),
@@ -701,7 +701,7 @@ void ieee80211_iterate_active_interfaces
 
 	__iterate_active_interfaces(local, iter_flags, iterator, data);
 }
-EXPORT_SYMBOL_GPL(ieee80211_iterate_active_interfaces_rtnl);
+EXPORT_SYMBOL_GPL(ieee80211_iterate_active_interfaces_rtnl_dup);
 
 static void __iterate_stations(struct ieee80211_local *local,
 			       void (*iterator)(void *data,
@@ -718,7 +718,7 @@ static void __iterate_stations(struct ie
 	}
 }
 
-void ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,
+void ieee80211_iterate_stations_atomic_dup(struct ieee80211_hw *hw,
 			void (*iterator)(void *data,
 					 struct ieee80211_sta *sta),
 			void *data)
@@ -729,9 +729,9 @@ void ieee80211_iterate_stations_atomic(s
 	__iterate_stations(local, iterator, data);
 	rcu_read_unlock();
 }
-EXPORT_SYMBOL_GPL(ieee80211_iterate_stations_atomic);
+EXPORT_SYMBOL_GPL(ieee80211_iterate_stations_atomic_dup);
 
-struct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev)
+struct ieee80211_vif *wdev_to_ieee80211_vif_dup(struct wireless_dev *wdev)
 {
 	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
 
@@ -740,7 +740,7 @@ struct ieee80211_vif *wdev_to_ieee80211_
 		return NULL;
 	return &sdata->vif;
 }
-EXPORT_SYMBOL_GPL(wdev_to_ieee80211_vif);
+EXPORT_SYMBOL_GPL(wdev_to_ieee80211_vif_dup);
 
 /*
  * Nothing should have been stuffed into the workqueue during
@@ -758,7 +758,7 @@ static bool ieee80211_can_queue_work(str
 	return true;
 }
 
-void ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work)
+void ieee80211_queue_work_dup(struct ieee80211_hw *hw, struct work_struct *work)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
@@ -767,9 +767,9 @@ void ieee80211_queue_work(struct ieee802
 
 	queue_work(local->workqueue, work);
 }
-EXPORT_SYMBOL(ieee80211_queue_work);
+EXPORT_SYMBOL(ieee80211_queue_work_dup);
 
-void ieee80211_queue_delayed_work(struct ieee80211_hw *hw,
+void ieee80211_queue_delayed_work_dup(struct ieee80211_hw *hw,
 				  struct delayed_work *dwork,
 				  unsigned long delay)
 {
@@ -780,7 +780,7 @@ void ieee80211_queue_delayed_work(struct
 
 	queue_delayed_work(local->workqueue, dwork, delay);
 }
-EXPORT_SYMBOL(ieee80211_queue_delayed_work);
+EXPORT_SYMBOL(ieee80211_queue_delayed_work_dup);
 
 u32 ieee802_11_parse_elems_crc(const u8 *start, size_t len, bool action,
 			       struct ieee802_11_elems *elems,
@@ -1053,7 +1053,7 @@ u32 ieee802_11_parse_elems_crc(const u8
 			 * the wide bandwidth channel switch element, so
 			 * just parse it out manually.
 			 */
-			ie = cfg80211_find_ie(WLAN_EID_WIDE_BW_CHANNEL_SWITCH,
+			ie = cfg80211_find_ie_dup(WLAN_EID_WIDE_BW_CHANNEL_SWITCH,
 					      pos, elen);
 			if (ie) {
 				if (ie[1] == sizeof(*elems->wide_bw_chansw_ie))
@@ -1378,7 +1378,7 @@ static int ieee80211_build_preq_ies_band
 			WLAN_EID_SUPP_RATES,
 			WLAN_EID_REQUEST,
 		};
-		noffset = ieee80211_ie_split(ie, ie_len,
+		noffset = ieee80211_ie_split_dup(ie, ie_len,
 					     before_extrates,
 					     ARRAY_SIZE(before_extrates),
 					     *offset);
@@ -1404,7 +1404,7 @@ static int ieee80211_build_preq_ies_band
 			goto out_err;
 		*pos++ = WLAN_EID_DS_PARAMS;
 		*pos++ = 1;
-		*pos++ = ieee80211_frequency_to_channel(
+		*pos++ = ieee80211_frequency_to_channel_dup(
 				chandef->chan->center_freq);
 	}
 
@@ -1418,7 +1418,7 @@ static int ieee80211_build_preq_ies_band
 			WLAN_EID_DS_PARAMS,
 			WLAN_EID_SUPPORTED_REGULATORY_CLASSES,
 		};
-		noffset = ieee80211_ie_split(ie, ie_len,
+		noffset = ieee80211_ie_split_dup(ie, ie_len,
 					     before_ht, ARRAY_SIZE(before_ht),
 					     *offset);
 		if (end - pos < noffset - *offset)
@@ -1458,7 +1458,7 @@ static int ieee80211_build_preq_ies_band
 			/* mesh ID can't happen here */
 			/* 60 GHz can't happen here right now */
 		};
-		noffset = ieee80211_ie_split(ie, ie_len,
+		noffset = ieee80211_ie_split_dup(ie, ie_len,
 					     before_vht, ARRAY_SIZE(before_vht),
 					     *offset);
 		if (end - pos < noffset - *offset)
@@ -1558,7 +1558,7 @@ struct sk_buff *ieee80211_build_probe_re
 	else
 		chandef.chan = chan;
 
-	skb = ieee80211_probereq_get(&local->hw, src, ssid, ssid_len,
+	skb = ieee80211_probereq_get_dup(&local->hw, src, ssid, ssid_len,
 				     100 + ie_len);
 	if (!skb)
 		return NULL;
@@ -1701,7 +1701,7 @@ static void ieee80211_handle_reconfig_fa
 		ctx->driver_present = false;
 	mutex_unlock(&local->chanctx_mtx);
 
-	cfg80211_shutdown_all_interfaces(local->hw.wiphy);
+	cfg80211_shutdown_all_interfaces_dup(local->hw.wiphy);
 }
 
 static void ieee80211_assign_chanctx(struct ieee80211_local *local,
@@ -2012,7 +2012,7 @@ int ieee80211_reconfig(struct ieee80211_
 		mutex_unlock(&local->sta_mtx);
 	}
 
-	ieee80211_wake_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,
+	ieee80211_wake_queues_by_reason_dup(hw, IEEE80211_MAX_QUEUE_MAP,
 					IEEE80211_QUEUE_STOP_REASON_SUSPEND,
 					false);
 
@@ -2036,7 +2036,7 @@ int ieee80211_reconfig(struct ieee80211_
 	mutex_unlock(&local->mtx);
 
 	if (sched_scan_stopped)
-		cfg80211_sched_scan_stopped_rtnl(local->hw.wiphy);
+		cfg80211_sched_scan_stopped_rtnl_dup(local->hw.wiphy);
 
 	/*
 	 * If this is for hw restart things are still running.
@@ -2072,7 +2072,7 @@ int ieee80211_reconfig(struct ieee80211_
 	return 0;
 }
 
-void ieee80211_resume_disconnect(struct ieee80211_vif *vif)
+void ieee80211_resume_disconnect_dup(struct ieee80211_vif *vif)
 {
 	struct ieee80211_sub_if_data *sdata;
 	struct ieee80211_local *local;
@@ -2097,7 +2097,7 @@ void ieee80211_resume_disconnect(struct
 		key->flags |= KEY_FLAG_TAINTED;
 	mutex_unlock(&local->key_mtx);
 }
-EXPORT_SYMBOL_GPL(ieee80211_resume_disconnect);
+EXPORT_SYMBOL_GPL(ieee80211_resume_disconnect_dup);
 
 void ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata)
 {
@@ -2172,12 +2172,12 @@ size_t ieee80211_ie_split_ric(const u8 *
 	return pos;
 }
 
-size_t ieee80211_ie_split(const u8 *ies, size_t ielen,
+size_t ieee80211_ie_split_dup(const u8 *ies, size_t ielen,
 			  const u8 *ids, int n_ids, size_t offset)
 {
 	return ieee80211_ie_split_ric(ies, ielen, ids, n_ids, NULL, 0, offset);
 }
-EXPORT_SYMBOL(ieee80211_ie_split);
+EXPORT_SYMBOL(ieee80211_ie_split_dup);
 
 size_t ieee80211_ie_split_vendor(const u8 *ies, size_t ielen, size_t offset)
 {
@@ -2189,7 +2189,7 @@ size_t ieee80211_ie_split_vendor(const u
 	return pos;
 }
 
-static void _ieee80211_enable_rssi_reports(struct ieee80211_sub_if_data *sdata,
+static void _ieee80211_enable_rssi_reports_dup(struct ieee80211_sub_if_data *sdata,
 					    int rssi_min_thold,
 					    int rssi_max_thold)
 {
@@ -2207,7 +2207,7 @@ static void _ieee80211_enable_rssi_repor
 	sdata->u.mgd.rssi_max_thold = rssi_max_thold*16;
 }
 
-void ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,
+void ieee80211_enable_rssi_reports_dup(struct ieee80211_vif *vif,
 				    int rssi_min_thold,
 				    int rssi_max_thold)
 {
@@ -2216,18 +2216,18 @@ void ieee80211_enable_rssi_reports(struc
 	WARN_ON(rssi_min_thold == rssi_max_thold ||
 		rssi_min_thold > rssi_max_thold);
 
-	_ieee80211_enable_rssi_reports(sdata, rssi_min_thold,
+	_ieee80211_enable_rssi_reports_dup(sdata, rssi_min_thold,
 				       rssi_max_thold);
 }
-EXPORT_SYMBOL(ieee80211_enable_rssi_reports);
+EXPORT_SYMBOL(ieee80211_enable_rssi_reports_dup);
 
-void ieee80211_disable_rssi_reports(struct ieee80211_vif *vif)
+void ieee80211_disable_rssi_reports_dup(struct ieee80211_vif *vif)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 
-	_ieee80211_enable_rssi_reports(sdata, 0, 0);
+	_ieee80211_enable_rssi_reports_dup(sdata, 0, 0);
 }
-EXPORT_SYMBOL(ieee80211_disable_rssi_reports);
+EXPORT_SYMBOL(ieee80211_disable_rssi_reports_dup);
 
 u8 *ieee80211_ie_build_ht_cap(u8 *pos, struct ieee80211_sta_ht_cap *ht_cap,
 			      u16 cap)
@@ -2294,7 +2294,7 @@ u8 *ieee80211_ie_build_ht_oper(u8 *pos,
 	*pos++ = WLAN_EID_HT_OPERATION;
 	*pos++ = sizeof(struct ieee80211_ht_operation);
 	ht_oper = (struct ieee80211_ht_operation *)pos;
-	ht_oper->primary_chan = ieee80211_frequency_to_channel(
+	ht_oper->primary_chan = ieee80211_frequency_to_channel_dup(
 					chandef->chan->center_freq);
 	switch (chandef->width) {
 	case NL80211_CHAN_WIDTH_160:
@@ -2333,7 +2333,7 @@ void ieee80211_ht_oper_to_chandef(struct
 	enum nl80211_channel_type channel_type;
 
 	if (!ht_oper) {
-		cfg80211_chandef_create(chandef, control_chan,
+		cfg80211_chandef_create_dup(chandef, control_chan,
 					NL80211_CHAN_NO_HT);
 		return;
 	}
@@ -2352,7 +2352,7 @@ void ieee80211_ht_oper_to_chandef(struct
 		channel_type = NL80211_CHAN_NO_HT;
 	}
 
-	cfg80211_chandef_create(chandef, control_chan, channel_type);
+	cfg80211_chandef_create_dup(chandef, control_chan, channel_type);
 }
 
 int ieee80211_parse_bitrates(struct cfg80211_chan_def *chandef,
@@ -2479,7 +2479,7 @@ int ieee80211_add_ext_srates_ie(struct i
 	return 0;
 }
 
-int ieee80211_ave_rssi(struct ieee80211_vif *vif)
+int ieee80211_ave_rssi_dup(struct ieee80211_vif *vif)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
@@ -2490,7 +2490,7 @@ int ieee80211_ave_rssi(struct ieee80211_
 	}
 	return ifmgd->ave_beacon_signal / 16;
 }
-EXPORT_SYMBOL_GPL(ieee80211_ave_rssi);
+EXPORT_SYMBOL_GPL(ieee80211_ave_rssi_dup);
 
 u8 ieee80211_mcs_to_chains(const struct ieee80211_mcs_info *mcs)
 {
@@ -2570,7 +2570,7 @@ u64 ieee80211_calculate_rx_timestamp(str
 		ri.legacy = DIV_ROUND_UP(bitrate, (1 << shift));
 	}
 
-	rate = cfg80211_calculate_bitrate(&ri);
+	rate = cfg80211_calculate_bitrate_dup(&ri);
 	if (WARN_ONCE(!rate,
 		      "Invalid bitrate: flags=0x%x, idx=%d, vht_nss=%d\n",
 		      status->flag, status->rate_idx, status->vht_nss))
@@ -2602,7 +2602,7 @@ void ieee80211_dfs_cac_cancel(struct iee
 		if (sdata->wdev.cac_started) {
 			chandef = sdata->vif.bss_conf.chandef;
 			ieee80211_vif_release_channel(sdata);
-			cfg80211_cac_event(sdata->dev,
+			cfg80211_cac_event_dup(sdata->dev,
 					   &chandef,
 					   NL80211_RADAR_CAC_ABORTED,
 					   GFP_KERNEL);
@@ -2636,18 +2636,18 @@ void ieee80211_dfs_radar_detected_work(s
 		/* XXX: multi-channel is not supported yet */
 		WARN_ON(1);
 	else
-		cfg80211_radar_event(local->hw.wiphy, &chandef, GFP_KERNEL);
+		cfg80211_radar_event_dup(local->hw.wiphy, &chandef, GFP_KERNEL);
 }
 
-void ieee80211_radar_detected(struct ieee80211_hw *hw)
+void ieee80211_radar_detected_dup(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
 
 	trace_api_radar_detected(local);
 
-	ieee80211_queue_work(hw, &local->radar_detected_work);
+	ieee80211_queue_work_dup(hw, &local->radar_detected_work);
 }
-EXPORT_SYMBOL(ieee80211_radar_detected);
+EXPORT_SYMBOL(ieee80211_radar_detected_dup);
 
 u32 ieee80211_chandef_downgrade(struct cfg80211_chan_def *c)
 {
@@ -2704,7 +2704,7 @@ u32 ieee80211_chandef_downgrade(struct c
 		break;
 	}
 
-	WARN_ON_ONCE(!cfg80211_chandef_valid(c));
+	WARN_ON_ONCE(!cfg80211_chandef_valid_dup(c));
 
 	return ret;
 }
@@ -2777,7 +2777,7 @@ int ieee80211_send_action_csa(struct iee
 	*pos++ = 3;						/* IE length */
 	*pos++ = csa_settings->block_tx ? 1 : 0;		/* CSA mode */
 	freq = csa_settings->chandef.chan->center_freq;
-	*pos++ = ieee80211_frequency_to_channel(freq);		/* channel */
+	*pos++ = ieee80211_frequency_to_channel_dup(freq);		/* channel */
 	*pos++ = csa_settings->count;				/* count */
 
 	if (csa_settings->chandef.width == NL80211_CHAN_WIDTH_40) {
@@ -2957,7 +2957,7 @@ ieee80211_get_noa_absent_time(struct iee
 	return offset;
 }
 
-void ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf)
+void ieee80211_update_p2p_noa_dup(struct ieee80211_noa_data *data, u32 tsf)
 {
 	u32 next_offset = BIT(31) - 1;
 	int i;
@@ -2986,9 +2986,9 @@ void ieee80211_update_p2p_noa(struct iee
 
 	data->next_tsf = tsf + next_offset;
 }
-EXPORT_SYMBOL(ieee80211_update_p2p_noa);
+EXPORT_SYMBOL(ieee80211_update_p2p_noa_dup);
 
-int ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,
+int ieee80211_parse_p2p_noa_dup(const struct ieee80211_p2p_noa_attr *attr,
 			    struct ieee80211_noa_data *data, u32 tsf)
 {
 	int ret = 0;
@@ -3016,11 +3016,11 @@ int ieee80211_parse_p2p_noa(const struct
 	}
 
 	if (ret)
-		ieee80211_update_p2p_noa(data, tsf);
+		ieee80211_update_p2p_noa_dup(data, tsf);
 
 	return ret;
 }
-EXPORT_SYMBOL(ieee80211_parse_p2p_noa);
+EXPORT_SYMBOL(ieee80211_parse_p2p_noa_dup);
 
 void ieee80211_recalc_dtim(struct ieee80211_local *local,
 			   struct ieee80211_sub_if_data *sdata)
@@ -3141,7 +3141,7 @@ int ieee80211_check_combinations(struct
 			continue;
 		}
 		if (chandef && chanmode == IEEE80211_CHANCTX_SHARED &&
-		    cfg80211_chandef_compatible(chandef,
+		    cfg80211_chandef_compatible_dup(chandef,
 						&ctx->conf.def))
 			continue;
 		num_different_channels++;
@@ -3164,7 +3164,7 @@ int ieee80211_check_combinations(struct
 	if (total == 1 && !radar_detect)
 		return 0;
 
-	return cfg80211_check_combinations(local->hw.wiphy,
+	return cfg80211_check_combinations_dup(local->hw.wiphy,
 					   num_different_channels,
 					   radar_detect, num);
 }
@@ -3203,7 +3203,7 @@ int ieee80211_max_num_channels(struct ie
 	list_for_each_entry_rcu(sdata, &local->interfaces, list)
 		num[sdata->wdev.iftype]++;
 
-	err = cfg80211_iter_combinations(local->hw.wiphy,
+	err = cfg80211_iter_combinations_dup(local->hw.wiphy,
 					 num_different_channels, radar_detect,
 					 num, ieee80211_iter_max_chans,
 					 &max_num_different_channels);
--- a/net/mac80211/wep.c	2015-06-23 11:07:42.832850758 +0200
+++ b/net/mac80211/wep.c	2015-06-23 14:54:17.020856194 +0200
@@ -102,7 +102,7 @@ static u8 *ieee80211_wep_add_iv(struct i
 		    skb_headroom(skb) < IEEE80211_WEP_IV_LEN))
 		return NULL;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 	newhdr = skb_push(skb, IEEE80211_WEP_IV_LEN);
 	memmove(newhdr, newhdr + IEEE80211_WEP_IV_LEN, hdrlen);
 
@@ -123,7 +123,7 @@ static void ieee80211_wep_remove_iv(stru
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	unsigned int hdrlen;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 	memmove(skb->data + IEEE80211_WEP_IV_LEN, skb->data, hdrlen);
 	skb_pull(skb, IEEE80211_WEP_IV_LEN);
 }
@@ -235,7 +235,7 @@ static int ieee80211_wep_decrypt(struct
 	if (!ieee80211_has_protected(hdr->frame_control))
 		return -1;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 	if (skb->len < hdrlen + IEEE80211_WEP_IV_LEN + IEEE80211_WEP_ICV_LEN)
 		return -1;
 
@@ -286,7 +286,7 @@ ieee80211_crypto_wep_decrypt(struct ieee
 		if (ieee80211_wep_decrypt(rx->local, rx->skb, rx->key))
 			return RX_DROP_UNUSABLE;
 	} else if (!(status->flag & RX_FLAG_IV_STRIPPED)) {
-		if (!pskb_may_pull(rx->skb, ieee80211_hdrlen(fc) +
+		if (!pskb_may_pull(rx->skb, ieee80211_hdrlen_dup(fc) +
 					    IEEE80211_WEP_IV_LEN))
 			return RX_DROP_UNUSABLE;
 		ieee80211_wep_remove_iv(rx->local, rx->skb, rx->key);
--- a/net/mac80211/wme.c	2015-06-23 11:07:42.832850758 +0200
+++ b/net/mac80211/wme.c	2015-06-23 14:54:17.120856643 +0200
@@ -215,7 +215,7 @@ u16 ieee80211_select_queue(struct ieee80
 	/* use the data classifier to determine what 802.1d tag the
 	 * data frame has */
 	qos_map = rcu_dereference(sdata->qos_map);
-	skb->priority = cfg80211_classify8021d(skb, qos_map ?
+	skb->priority = cfg80211_classify8021d_dup(skb, qos_map ?
 					       &qos_map->qos_map : NULL);
 
  downgrade:
--- a/net/mac80211/work.c	2015-06-23 11:07:42.832850758 +0200
+++ b/net/mac80211/work.c	2015-06-23 14:54:17.173856881 +0200
@@ -74,7 +74,7 @@ ieee80211_remain_on_channel_timeout(stru
 	if (!wk->started) {
 		wk->timeout = jiffies + msecs_to_jiffies(wk->remain.duration);
 
-		cfg80211_ready_on_channel(wk->sdata->dev, (unsigned long) wk,
+		cfg80211_ready_on_channel_dup(wk->sdata->dev, (unsigned long) wk,
 					  wk->chan, wk->chan_type,
 					  wk->remain.duration, GFP_KERNEL);
 
@@ -110,7 +110,7 @@ static void ieee80211_work_timer(unsigne
 	if (local->quiescing)
 		return;
 
-	ieee80211_queue_work(&local->hw, &local->work_work);
+	ieee80211_queue_work_dup(&local->hw, &local->work_work);
 }
 
 static void ieee80211_work_work(struct work_struct *work)
@@ -123,7 +123,7 @@ static void ieee80211_work_work(struct w
 	bool remain_off_channel = false;
 
 	/*
-	 * ieee80211_queue_work() should have picked up most cases,
+	 * ieee80211_queue_work_dup() should have picked up most cases,
 	 * here we'll pick the rest.
 	 */
 	if (WARN(local->suspended, "work scheduled while going to suspend\n"))
@@ -263,7 +263,7 @@ void ieee80211_add_work(struct ieee80211
 	list_add_tail(&wk->list, &local->work_list);
 	mutex_unlock(&local->mtx);
 
-	ieee80211_queue_work(&local->hw, &local->work_work);
+	ieee80211_queue_work_dup(&local->hw, &local->work_work);
 }
 
 void ieee80211_work_init(struct ieee80211_local *local)
@@ -311,7 +311,7 @@ static enum work_done_result ieee80211_r
 	/*
 	 * We are done serving the remain-on-channel command.
 	 */
-	cfg80211_remain_on_channel_expired(wk->sdata->dev, (unsigned long) wk,
+	cfg80211_remain_on_channel_expired_dup(wk->sdata->dev, (unsigned long) wk,
 					   wk->chan, wk->chan_type,
 					   GFP_KERNEL);
 
@@ -364,7 +364,7 @@ int ieee80211_wk_cancel_remain_on_channe
 	if (!found)
 		return -ENOENT;
 
-	ieee80211_queue_work(&local->hw, &local->work_work);
+	ieee80211_queue_work_dup(&local->hw, &local->work_work);
 
 	return 0;
 }
--- a/net/mac80211/wpa.c	2015-06-23 11:07:42.832850758 +0200
+++ b/net/mac80211/wpa.c	2015-06-23 14:54:17.222857101 +0200
@@ -40,7 +40,7 @@ ieee80211_tx_h_michael_mic_add(struct ie
 	    skb->len < 24 || !ieee80211_is_data_present(hdr->frame_control))
 		return TX_CONTINUE;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 	if (skb->len < hdrlen)
 		return TX_DROP;
 
@@ -138,7 +138,7 @@ ieee80211_rx_h_michael_mic_verify(struct
 	if (status->flag & RX_FLAG_MMIC_ERROR)
 		goto mic_fail;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 	if (skb->len < hdrlen + MICHAEL_MIC_LEN)
 		return RX_DROP_UNUSABLE;
 
@@ -195,7 +195,7 @@ static int tkip_encrypt_skb(struct ieee8
 		return 0;
 	}
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 	len = skb->len - hdrlen;
 
 	if (info->control.hw_key)
@@ -261,7 +261,7 @@ ieee80211_crypto_tkip_decrypt(struct iee
 	struct sk_buff *skb = rx->skb;
 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 
 	if (!ieee80211_is_data(hdr->frame_control))
 		return RX_CONTINUE;
@@ -323,7 +323,7 @@ static void ccmp_special_blocks(struct s
 		mask_fc &= ~cpu_to_le16(0x0070);
 	mask_fc |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 	len_a = hdrlen - 2;
 	a4_included = ieee80211_has_a4(hdr->frame_control);
 
@@ -418,7 +418,7 @@ static int ccmp_encrypt_skb(struct ieee8
 		return 0;
 	}
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 	len = skb->len - hdrlen;
 
 	if (info->control.hw_key)
@@ -493,7 +493,7 @@ ieee80211_crypto_ccmp_decrypt(struct iee
 	int data_len;
 	int queue;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 
 	if (!ieee80211_is_data(hdr->frame_control) &&
 	    !ieee80211_is_robust_mgmt_frame(skb))
@@ -567,7 +567,7 @@ ieee80211_crypto_cs_encrypt(struct ieee8
 		     pskb_expand_head(skb, cs->hdr_len, 0, GFP_ATOMIC)))
 		return TX_DROP;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 
 	pos = skb_push(skb, cs->hdr_len);
 	memmove(pos, pos + cs->hdr_len, hdrlen);
@@ -596,7 +596,7 @@ ieee80211_crypto_cs_decrypt(struct ieee8
 	struct ieee80211_key *key = rx->key;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
 	const struct ieee80211_cipher_scheme *cs = NULL;
-	int hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	int hdrlen = ieee80211_hdrlen_dup(hdr->frame_control);
 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
 	int data_len;
 	u8 *rx_pn;
--- a/include/linux/nl80211.h	2015-06-23 11:07:42.625848362 +0200
+++ b/include/linux/nl80211.h	2015-06-23 16:42:01.688814709 +0200
@@ -4382,7 +4382,7 @@ enum nl80211_crit_proto_id {
 /**
  * enum nl80211_rxmgmt_flags - flags for received management frame.
  *
- * Used by cfg80211_rx_mgmt()
+ * Used by cfg80211_rx_mgmt_dup()
  *
  * @NL80211_RXMGMT_FLAG_ANSWERED: frame was answered by device/driver.
  */
--- a/include/net/cfg80211-wext.h	2015-06-23 11:07:42.664848813 +0200
+++ b/include/net/cfg80211-wext.h	2015-06-23 16:42:01.806816115 +0200
@@ -20,35 +20,35 @@
  * These are used only by drivers that aren't yet fully
  * converted to cfg80211.
  */
-int cfg80211_wext_giwname(struct net_device *dev,
+int cfg80211_wext_giwname_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  char *name, char *extra);
-int cfg80211_wext_siwmode(struct net_device *dev, struct iw_request_info *info,
+int cfg80211_wext_siwmode_dup(struct net_device *dev, struct iw_request_info *info,
 			  u32 *mode, char *extra);
-int cfg80211_wext_giwmode(struct net_device *dev, struct iw_request_info *info,
+int cfg80211_wext_giwmode_dup(struct net_device *dev, struct iw_request_info *info,
 			  u32 *mode, char *extra);
-int cfg80211_wext_siwscan(struct net_device *dev,
+int cfg80211_wext_siwscan_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  union iwreq_data *wrqu, char *extra);
-int cfg80211_wext_giwscan(struct net_device *dev,
+int cfg80211_wext_giwscan_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_point *data, char *extra);
-int cfg80211_wext_giwrange(struct net_device *dev,
+int cfg80211_wext_giwrange_dup(struct net_device *dev,
 			   struct iw_request_info *info,
 			   struct iw_point *data, char *extra);
-int cfg80211_wext_siwrts(struct net_device *dev,
+int cfg80211_wext_siwrts_dup(struct net_device *dev,
 			 struct iw_request_info *info,
 			 struct iw_param *rts, char *extra);
-int cfg80211_wext_giwrts(struct net_device *dev,
+int cfg80211_wext_giwrts_dup(struct net_device *dev,
 			 struct iw_request_info *info,
 			 struct iw_param *rts, char *extra);
-int cfg80211_wext_siwfrag(struct net_device *dev,
+int cfg80211_wext_siwfrag_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_param *frag, char *extra);
-int cfg80211_wext_giwfrag(struct net_device *dev,
+int cfg80211_wext_giwfrag_dup(struct net_device *dev,
 			  struct iw_request_info *info,
 			  struct iw_param *frag, char *extra);
-int cfg80211_wext_giwretry(struct net_device *dev,
+int cfg80211_wext_giwretry_dup(struct net_device *dev,
 			   struct iw_request_info *info,
 			   struct iw_param *retry, char *extra);
 
--- a/include/net/cfg80211.h	2015-06-23 11:07:42.665848825 +0200
+++ b/include/net/cfg80211.h	2015-06-23 16:42:01.843816555 +0200
@@ -393,14 +393,14 @@ cfg80211_get_chandef_type(const struct c
 }
 
 /**
- * cfg80211_chandef_create - create channel definition using channel type
+ * cfg80211_chandef_create_dup - create channel definition using channel type
  * @chandef: the channel definition struct to fill
  * @channel: the control channel
  * @chantype: the channel type
  *
  * Given a channel type, create a channel definition.
  */
-void cfg80211_chandef_create(struct cfg80211_chan_def *chandef,
+void cfg80211_chandef_create_dup(struct cfg80211_chan_def *chandef,
 			     struct ieee80211_channel *channel,
 			     enum nl80211_channel_type chantype);
 
@@ -423,7 +423,7 @@ cfg80211_chandef_identical(const struct
 }
 
 /**
- * cfg80211_chandef_compatible - check if two channel definitions are compatible
+ * cfg80211_chandef_compatible_dup - check if two channel definitions are compatible
  * @chandef1: first channel definition
  * @chandef2: second channel definition
  *
@@ -431,36 +431,36 @@ cfg80211_chandef_identical(const struct
  * chandef1 or chandef2 otherwise.
  */
 const struct cfg80211_chan_def *
-cfg80211_chandef_compatible(const struct cfg80211_chan_def *chandef1,
+cfg80211_chandef_compatible_dup(const struct cfg80211_chan_def *chandef1,
 			    const struct cfg80211_chan_def *chandef2);
 
 /**
- * cfg80211_chandef_valid - check if a channel definition is valid
+ * cfg80211_chandef_valid_dup - check if a channel definition is valid
  * @chandef: the channel definition to check
  * Return: %true if the channel definition is valid. %false otherwise.
  */
-bool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef);
+bool cfg80211_chandef_valid_dup(const struct cfg80211_chan_def *chandef);
 
 /**
- * cfg80211_chandef_usable - check if secondary channels can be used
+ * cfg80211_chandef_usable_dup - check if secondary channels can be used
  * @wiphy: the wiphy to validate against
  * @chandef: the channel definition to check
  * @prohibited_flags: the regulatory channel flags that must not be set
  * Return: %true if secondary channels are usable. %false otherwise.
  */
-bool cfg80211_chandef_usable(struct wiphy *wiphy,
+bool cfg80211_chandef_usable_dup(struct wiphy *wiphy,
 			     const struct cfg80211_chan_def *chandef,
 			     u32 prohibited_flags);
 
 /**
- * cfg80211_chandef_dfs_required - checks if radar detection is required
+ * cfg80211_chandef_dfs_required_dup - checks if radar detection is required
  * @wiphy: the wiphy to validate against
  * @chandef: the channel definition to check
  * @iftype: the interface type as specified in &enum nl80211_iftype
  * Returns:
  *	1 if radar detection is required, 0 if it is not, < 0 on error
  */
-int cfg80211_chandef_dfs_required(struct wiphy *wiphy,
+int cfg80211_chandef_dfs_required_dup(struct wiphy *wiphy,
 				  const struct cfg80211_chan_def *chandef,
 				  enum nl80211_iftype iftype);
 
@@ -849,7 +849,7 @@ enum cfg80211_station_type {
 };
 
 /**
- * cfg80211_check_station_change - validate parameter changes
+ * cfg80211_check_station_change_dup - validate parameter changes
  * @wiphy: the wiphy this operates on
  * @params: the new parameters for a station
  * @statype: the type of station being modified
@@ -860,7 +860,7 @@ enum cfg80211_station_type {
  * not will return an error code. Note that it may modify the parameters for
  * backward compatibility reasons, so don't use them before calling this.
  */
-int cfg80211_check_station_change(struct wiphy *wiphy,
+int cfg80211_check_station_change_dup(struct wiphy *wiphy,
 				  struct station_parameters *params,
 				  enum cfg80211_station_type statype);
 
@@ -1046,7 +1046,7 @@ struct sta_bss_parameters {
  * @assoc_req_ies: IEs from (Re)Association Request.
  *	This is used only when in AP mode with drivers that do not use
  *	user space MLME/SME implementation. The information is provided for
- *	the cfg80211_new_sta() calls to notify user space of the IEs.
+ *	the cfg80211_new_sta_dup() calls to notify user space of the IEs.
  * @assoc_req_ies_len: Length of assoc_req_ies buffer in octets.
  * @sta_flags: station flags mask & values
  * @beacon_loss_count: Number of times beacon loss event has triggered.
@@ -1108,7 +1108,7 @@ struct station_info {
 };
 
 /**
- * cfg80211_get_station - retrieve information about a given station
+ * cfg80211_get_station_dup - retrieve information about a given station
  * @dev: the device where the station is supposed to be connected to
  * @mac_addr: the mac address of the station of interest
  * @sinfo: pointer to the structure to fill with the information
@@ -1117,7 +1117,7 @@ struct station_info {
  * otherwise returns a negative error code and the content of sinfo has to be
  * considered undefined.
  */
-int cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,
+int cfg80211_get_station_dup(struct net_device *dev, const u8 *mac_addr,
 			 struct station_info *sinfo);
 
 /**
@@ -1630,7 +1630,7 @@ struct cfg80211_bss {
 };
 
 /**
- * ieee80211_bss_get_ie - find IE with given ID
+ * ieee80211_bss_get_ie_dup - find IE with given ID
  * @bss: the bss to search
  * @ie: the IE ID
  *
@@ -1638,7 +1638,7 @@ struct cfg80211_bss {
  * rcu_read_lock() must be held when calling this function.
  * Return: %NULL if not found.
  */
-const u8 *ieee80211_bss_get_ie(struct cfg80211_bss *bss, u8 ie);
+const u8 *ieee80211_bss_get_ie_dup(struct cfg80211_bss *bss, u8 ie);
 
 
 /**
@@ -1690,7 +1690,7 @@ enum cfg80211_assoc_req_flags {
  * (re)association.
  * @bss: The BSS to associate with. If the call is successful the driver is
  *	given a reference that it must give back to cfg80211_send_rx_assoc()
- *	or to cfg80211_assoc_timeout(). To ensure proper refcounting, new
+ *	or to cfg80211_assoc_timeout_dup(). To ensure proper refcounting, new
  *	association requests while already associating must be rejected.
  * @ie: Extra IEs to add to (Re)Association Request frame or %NULL
  * @ie_len: Length of ie buffer in octets
@@ -2235,7 +2235,7 @@ struct cfg80211_qos_map {
  *	validated in cfg80211, in particular the auth/assoc/authorized flags
  *	might come to the driver in invalid combinations -- make sure to check
  *	them, also against the existing state! Drivers must call
- *	cfg80211_check_station_change() to validate the information.
+ *	cfg80211_check_station_change_dup() to validate the information.
  * @get_station: get station information for the station identified by @mac
  * @dump_station: dump station callback -- resume dump at index @idx
  *
@@ -2271,7 +2271,7 @@ struct cfg80211_qos_map {
  *	be stored for when a monitor interface becomes active.
  *
  * @scan: Request to do a scan. If returning zero, the scan request is given
- *	the driver, and will be valid until passed to cfg80211_scan_done().
+ *	the driver, and will be valid until passed to cfg80211_scan_done_dup().
  *	For scan results, call cfg80211_inform_bss(); you can call this outside
  *	the scan/scan_done bracket too.
  *
@@ -2285,15 +2285,15 @@ struct cfg80211_qos_map {
  *	(invoked with the wireless_dev mutex held)
  *
  * @connect: Connect to the ESS with the specified parameters. When connected,
- *	call cfg80211_connect_result() with status code %WLAN_STATUS_SUCCESS.
- *	If the connection fails for some reason, call cfg80211_connect_result()
+ *	call cfg80211_connect_result_dup() with status code %WLAN_STATUS_SUCCESS.
+ *	If the connection fails for some reason, call cfg80211_connect_result_dup()
  *	with the status from the AP.
  *	(invoked with the wireless_dev mutex held)
  * @disconnect: Disconnect from the BSS/ESS.
  *	(invoked with the wireless_dev mutex held)
  *
  * @join_ibss: Join the specified IBSS (or create if necessary). Once done, call
- *	cfg80211_ibss_joined(), also call that function when changing BSSID due
+ *	cfg80211_ibss_joined_dup(), also call that function when changing BSSID due
  *	to a merge.
  *	(invoked with the wireless_dev mutex held)
  * @leave_ibss: Leave the IBSS.
@@ -2326,7 +2326,7 @@ struct cfg80211_qos_map {
  *	channel for the specified duration to complete an off-channel
  *	operation (e.g., public action frame exchange). When the driver is
  *	ready on the requested channel, it must indicate this with an event
- *	notification by calling cfg80211_ready_on_channel().
+ *	notification by calling cfg80211_ready_on_channel_dup().
  * @cancel_remain_on_channel: Cancel an on-going remain-on-channel operation.
  *	This allows the operation to be terminated prior to timeout based on
  *	the duration value.
@@ -2359,7 +2359,7 @@ struct cfg80211_qos_map {
  *	call must stop the scheduled scan and be ready for starting a new one
  *	before it returns, i.e. @sched_scan_start may be called immediately
  *	after that again and should not fail in that case. The driver should
- *	not call cfg80211_sched_scan_stopped() for a requested stop (when this
+ *	not call cfg80211_sched_scan_stopped_dup() for a requested stop (when this
  *	method returns 0.)
  *
  * @mgmt_frame_register: Notify driver that a management frame type was
@@ -2377,7 +2377,7 @@ struct cfg80211_qos_map {
  * @tdls_oper: Perform a high-level TDLS operation (e.g. TDLS link setup).
  *
  * @probe_client: probe an associated client, must return a cookie that it
- *	later passes to cfg80211_probe_status().
+ *	later passes to cfg80211_probe_status_dup().
  *
  * @set_noack_map: Set the NoAck Map for the TIDs.
  *
@@ -2411,7 +2411,7 @@ struct cfg80211_qos_map {
  * @channel_switch: initiate channel-switch procedure (with CSA). Driver is
  *	responsible for veryfing if the switch is possible. Since this is
  *	inherently tricky driver may decide to disconnect an interface later
- *	with cfg80211_stop_iface(). This doesn't mean driver can accept
+ *	with cfg80211_stop_iface_dup(). This doesn't mean driver can accept
  *	everything. It should do it's best to verify requests and reject them
  *	as soon as possible.
  *
@@ -2743,7 +2743,7 @@ struct cfg80211_ops {
  * @WIPHY_FLAG_HAVE_AP_SME: device integrates AP SME
  * @WIPHY_FLAG_REPORTS_OBSS: the device will report beacons from other BSSes
  *	when there are virtual interfaces in AP mode by calling
- *	cfg80211_report_obss_beacon().
+ *	cfg80211_report_obss_beacon_dup().
  * @WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD: When operating as an AP, the device
  *	responds to probe-requests in hardware.
  * @WIPHY_FLAG_OFFCHAN_TX: Device supports direct off-channel TX.
@@ -2976,10 +2976,10 @@ struct wiphy_vendor_command {
 /**
  * struct wiphy - wireless hardware description
  * @reg_notifier: the driver's regulatory notification callback,
- *	note that if your driver uses wiphy_apply_custom_regulatory()
+ *	note that if your driver uses wiphy_apply_custom_regulatory_dup()
  *	the reg_notifier's request can be passed as NULL
  * @regd: the driver's regulatory domain, if one was requested via
- * 	the regulatory_hint() API. This can be used by the driver
+ * 	the regulatory_hint_dup() API. This can be used by the driver
  *	on the reg_notifier() if it chooses to ignore future
  *	regulatory domain changes caused by other drivers.
  * @signal_type: signal type reported in &struct cfg80211_bss.
@@ -3298,7 +3298,7 @@ static inline const char *wiphy_name(con
 }
 
 /**
- * wiphy_new_nm - create a new wiphy for use with cfg80211
+ * wiphy_new_nm_dup - create a new wiphy for use with cfg80211
  *
  * @ops: The configuration operations for this device
  * @sizeof_priv: The size of the private area to allocate
@@ -3311,7 +3311,7 @@ static inline const char *wiphy_name(con
  * Return: A pointer to the new wiphy. This pointer must be
  * assigned to each netdev's ieee80211_ptr for proper operation.
  */
-struct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,
+struct wiphy *wiphy_new_nm_dup(const struct cfg80211_ops *ops, int sizeof_priv,
 			   const char *requested_name);
 
 /**
@@ -3329,20 +3329,20 @@ struct wiphy *wiphy_new_nm(const struct
 static inline struct wiphy *wiphy_new(const struct cfg80211_ops *ops,
 				      int sizeof_priv)
 {
-	return wiphy_new_nm(ops, sizeof_priv, NULL);
+	return wiphy_new_nm_dup(ops, sizeof_priv, NULL);
 }
 
 /**
- * wiphy_register - register a wiphy with cfg80211
+ * wiphy_register_dup - register a wiphy with cfg80211
  *
  * @wiphy: The wiphy to register.
  *
  * Return: A non-negative wiphy index or a negative error code.
  */
-int wiphy_register(struct wiphy *wiphy);
+int wiphy_register_dup(struct wiphy *wiphy);
 
 /**
- * wiphy_unregister - deregister a wiphy from cfg80211
+ * wiphy_unregister_dup - deregister a wiphy from cfg80211
  *
  * @wiphy: The wiphy to unregister.
  *
@@ -3350,14 +3350,14 @@ int wiphy_register(struct wiphy *wiphy);
  * pointer, but the call may sleep to wait for an outstanding
  * request that is being handled.
  */
-void wiphy_unregister(struct wiphy *wiphy);
+void wiphy_unregister_dup(struct wiphy *wiphy);
 
 /**
- * wiphy_free - free wiphy
+ * wiphy_free_dup - free wiphy
  *
  * @wiphy: The wiphy to free
  */
-void wiphy_free(struct wiphy *wiphy);
+void wiphy_free_dup(struct wiphy *wiphy);
 
 /* internal structs */
 struct cfg80211_conn;
@@ -3512,19 +3512,19 @@ static inline void *wdev_priv(struct wir
  */
 
 /**
- * ieee80211_channel_to_frequency - convert channel number to frequency
+ * ieee80211_channel_to_frequency_dup - convert channel number to frequency
  * @chan: channel number
  * @band: band, necessary due to channel number overlap
  * Return: The corresponding frequency (in MHz), or 0 if the conversion failed.
  */
-int ieee80211_channel_to_frequency(int chan, enum ieee80211_band band);
+int ieee80211_channel_to_frequency_dup(int chan, enum ieee80211_band band);
 
 /**
- * ieee80211_frequency_to_channel - convert frequency to channel number
+ * ieee80211_frequency_to_channel_dup - convert frequency to channel number
  * @freq: center frequency
  * Return: The corresponding channel, or 0 if the conversion failed.
  */
-int ieee80211_frequency_to_channel(int freq);
+int ieee80211_frequency_to_channel_dup(int freq);
 
 /*
  * Name indirection necessary because the ieee80211 code also has
@@ -3533,7 +3533,7 @@ int ieee80211_frequency_to_channel(int f
  * to include both header files you'll (rightfully!) get a symbol
  * clash.
  */
-struct ieee80211_channel *__ieee80211_get_channel(struct wiphy *wiphy,
+struct ieee80211_channel *__ieee80211_get_channel_dup(struct wiphy *wiphy,
 						  int freq);
 /**
  * ieee80211_get_channel - get channel struct from wiphy for specified frequency
@@ -3544,11 +3544,11 @@ struct ieee80211_channel *__ieee80211_ge
 static inline struct ieee80211_channel *
 ieee80211_get_channel(struct wiphy *wiphy, int freq)
 {
-	return __ieee80211_get_channel(wiphy, freq);
+	return __ieee80211_get_channel_dup(wiphy, freq);
 }
 
 /**
- * ieee80211_get_response_rate - get basic rate for a given rate
+ * ieee80211_get_response_rate_dup - get basic rate for a given rate
  *
  * @sband: the band to look for rates in
  * @basic_rates: bitmap of basic rates
@@ -3560,18 +3560,18 @@ ieee80211_get_channel(struct wiphy *wiph
  * rates in the band's bitrate table.
  */
 struct ieee80211_rate *
-ieee80211_get_response_rate(struct ieee80211_supported_band *sband,
+ieee80211_get_response_rate_dup(struct ieee80211_supported_band *sband,
 			    u32 basic_rates, int bitrate);
 
 /**
- * ieee80211_mandatory_rates - get mandatory rates for a given band
+ * ieee80211_mandatory_rates_dup - get mandatory rates for a given band
  * @sband: the band to look for rates in
  * @scan_width: width of the control channel
  *
  * This function returns a bitmap of the mandatory rates for the given
  * band, bits are set according to the rate position in the bitrates array.
  */
-u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,
+u32 ieee80211_mandatory_rates_dup(struct ieee80211_supported_band *sband,
 			      enum nl80211_bss_scan_width scan_width);
 
 /*
@@ -3600,10 +3600,10 @@ struct ieee80211_radiotap_vendor_namespa
 /**
  * struct ieee80211_radiotap_iterator - tracks walk thru present radiotap args
  * @this_arg_index: index of current arg, valid after each successful call
- *	to ieee80211_radiotap_iterator_next()
+ *	to ieee80211_radiotap_iterator_next_dup()
  * @this_arg: pointer to current radiotap arg; it is valid after each
- *	call to ieee80211_radiotap_iterator_next() but also after
- *	ieee80211_radiotap_iterator_init() where it will point to
+ *	call to ieee80211_radiotap_iterator_next_dup() but also after
+ *	ieee80211_radiotap_iterator_init_dup() where it will point to
  *	the beginning of the actual data portion
  * @this_arg_size: length of the current arg, for convenience
  * @current_namespace: pointer to the current namespace definition
@@ -3647,20 +3647,20 @@ struct ieee80211_radiotap_iterator {
 };
 
 int
-ieee80211_radiotap_iterator_init(struct ieee80211_radiotap_iterator *iterator,
+ieee80211_radiotap_iterator_init_dup(struct ieee80211_radiotap_iterator *iterator,
 				 struct ieee80211_radiotap_header *radiotap_header,
 				 int max_length,
 				 const struct ieee80211_radiotap_vendor_namespaces *vns);
 
 int
-ieee80211_radiotap_iterator_next(struct ieee80211_radiotap_iterator *iterator);
+ieee80211_radiotap_iterator_next_dup(struct ieee80211_radiotap_iterator *iterator);
 
 
-extern const unsigned char rfc1042_header[6];
-extern const unsigned char bridge_tunnel_header[6];
+extern const unsigned char rfc1042_header_dup[6];
+extern const unsigned char bridge_tunnel_header_dup[6];
 
 /**
- * ieee80211_get_hdrlen_from_skb - get header length from data
+ * ieee80211_get_hdrlen_from_skb_dup - get header length from data
  *
  * @skb: the frame
  *
@@ -3671,23 +3671,23 @@ extern const unsigned char bridge_tunnel
  * headers). Or 0 if the data in the sk_buff is too short to contain a valid
  * 802.11 header.
  */
-unsigned int ieee80211_get_hdrlen_from_skb(const struct sk_buff *skb);
+unsigned int ieee80211_get_hdrlen_from_skb_dup(const struct sk_buff *skb);
 
 /**
- * ieee80211_hdrlen - get header length in bytes from frame control
+ * ieee80211_hdrlen_dup - get header length in bytes from frame control
  * @fc: frame control field in little-endian format
  * Return: The header length in bytes.
  */
-unsigned int __attribute_const__ ieee80211_hdrlen(__le16 fc);
+unsigned int __attribute_const__ ieee80211_hdrlen_dup(__le16 fc);
 
 /**
- * ieee80211_get_mesh_hdrlen - get mesh extension header length
+ * ieee80211_get_mesh_hdrlen_dup - get mesh extension header length
  * @meshhdr: the mesh extension header, only the flags field
  *	(first byte) will be accessed
  * Return: The length of the extension header, which is always at
  * least 6 bytes and at most 18 if address 5 and 6 are present.
  */
-unsigned int ieee80211_get_mesh_hdrlen(struct ieee80211s_hdr *meshhdr);
+unsigned int ieee80211_get_mesh_hdrlen_dup(struct ieee80211s_hdr *meshhdr);
 
 /**
  * DOC: Data path helpers
@@ -3698,17 +3698,17 @@ unsigned int ieee80211_get_mesh_hdrlen(s
  */
 
 /**
- * ieee80211_data_to_8023 - convert an 802.11 data frame to 802.3
+ * ieee80211_data_to_8023_dup - convert an 802.11 data frame to 802.3
  * @skb: the 802.11 data frame
  * @addr: the device MAC address
  * @iftype: the virtual interface type
  * Return: 0 on success. Non-zero on error.
  */
-int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
+int ieee80211_data_to_8023_dup(struct sk_buff *skb, const u8 *addr,
 			   enum nl80211_iftype iftype);
 
 /**
- * ieee80211_data_from_8023 - convert an 802.3 frame to 802.11
+ * ieee80211_data_from_8023_dup - convert an 802.3 frame to 802.11
  * @skb: the 802.3 frame
  * @addr: the device MAC address
  * @iftype: the virtual interface type
@@ -3716,12 +3716,12 @@ int ieee80211_data_to_8023(struct sk_buf
  * @qos: build 802.11 QoS data frame
  * Return: 0 on success, or a negative error code.
  */
-int ieee80211_data_from_8023(struct sk_buff *skb, const u8 *addr,
+int ieee80211_data_from_8023_dup(struct sk_buff *skb, const u8 *addr,
 			     enum nl80211_iftype iftype, const u8 *bssid,
 			     bool qos);
 
 /**
- * ieee80211_amsdu_to_8023s - decode an IEEE 802.11n A-MSDU frame
+ * ieee80211_amsdu_to_8023s_dup - decode an IEEE 802.11n A-MSDU frame
  *
  * Decode an IEEE 802.11n A-MSDU frame and convert it to a list of
  * 802.3 frames. The @list will be empty if the decode fails. The
@@ -3735,22 +3735,22 @@ int ieee80211_data_from_8023(struct sk_b
  * @extra_headroom: The hardware extra headroom for SKBs in the @list.
  * @has_80211_header: Set it true if SKB is with IEEE 802.11 header.
  */
-void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
+void ieee80211_amsdu_to_8023s_dup(struct sk_buff *skb, struct sk_buff_head *list,
 			      const u8 *addr, enum nl80211_iftype iftype,
 			      const unsigned int extra_headroom,
 			      bool has_80211_header);
 
 /**
- * cfg80211_classify8021d - determine the 802.1p/1d tag for a data frame
+ * cfg80211_classify8021d_dup - determine the 802.1p/1d tag for a data frame
  * @skb: the data frame
  * @qos_map: Interworking QoS mapping or %NULL if not in use
  * Return: The 802.1p/1d tag.
  */
-unsigned int cfg80211_classify8021d(struct sk_buff *skb,
+unsigned int cfg80211_classify8021d_dup(struct sk_buff *skb,
 				    struct cfg80211_qos_map *qos_map);
 
 /**
- * cfg80211_find_ie - find information element in data
+ * cfg80211_find_ie_dup - find information element in data
  *
  * @eid: element ID
  * @ies: data consisting of IEs
@@ -3764,10 +3764,10 @@ unsigned int cfg80211_classify8021d(stru
  * Note: There are no checks on the element length other than
  * having to fit into the given data.
  */
-const u8 *cfg80211_find_ie(u8 eid, const u8 *ies, int len);
+const u8 *cfg80211_find_ie_dup(u8 eid, const u8 *ies, int len);
 
 /**
- * cfg80211_find_vendor_ie - find vendor specific information element in data
+ * cfg80211_find_vendor_ie_dup - find vendor specific information element in data
  *
  * @oui: vendor OUI
  * @oui_type: vendor-specific OUI type
@@ -3782,7 +3782,7 @@ const u8 *cfg80211_find_ie(u8 eid, const
  * Note: There are no checks on the element length other than having to fit into
  * the given data.
  */
-const u8 *cfg80211_find_vendor_ie(unsigned int oui, u8 oui_type,
+const u8 *cfg80211_find_vendor_ie_dup(unsigned int oui, u8 oui_type,
 				  const u8 *ies, int len);
 
 /**
@@ -3792,7 +3792,7 @@ const u8 *cfg80211_find_vendor_ie(unsign
  */
 
 /**
- * regulatory_hint - driver hint to the wireless core a regulatory domain
+ * regulatory_hint_dup - driver hint to the wireless core a regulatory domain
  * @wiphy: the wireless device giving the hint (used only for reporting
  *	conflicts)
  * @alpha2: the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
@@ -3808,18 +3808,18 @@ const u8 *cfg80211_find_vendor_ie(unsign
  * for a regulatory domain structure for the respective country.
  *
  * The wiphy must have been registered to cfg80211 prior to this call.
- * For cfg80211 drivers this means you must first use wiphy_register(),
- * for mac80211 drivers you must first use ieee80211_register_hw().
+ * For cfg80211 drivers this means you must first use wiphy_register_dup(),
+ * for mac80211 drivers you must first use ieee80211_register_hw_dup().
  *
  * Drivers should check the return value, its possible you can get
  * an -ENOMEM.
  *
  * Return: 0 on success. -ENOMEM.
  */
-int regulatory_hint(struct wiphy *wiphy, const char *alpha2);
+int regulatory_hint_dup(struct wiphy *wiphy, const char *alpha2);
 
 /**
- * wiphy_apply_custom_regulatory - apply a custom driver regulatory domain
+ * wiphy_apply_custom_regulatory_dup - apply a custom driver regulatory domain
  * @wiphy: the wireless device we want to process the regulatory domain on
  * @regd: the custom regulatory domain to use for this wiphy
  *
@@ -3833,11 +3833,11 @@ int regulatory_hint(struct wiphy *wiphy,
  * REGULATORY_CUSTOM_REG or cfg80211 will set it for the wiphy
  * that called this helper.
  */
-void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
+void wiphy_apply_custom_regulatory_dup(struct wiphy *wiphy,
 				   const struct ieee80211_regdomain *regd);
 
 /**
- * freq_reg_info - get regulatory information for the given frequency
+ * freq_reg_info_dup - get regulatory information for the given frequency
  * @wiphy: the wiphy for which we want to process this rule for
  * @center_freq: Frequency in KHz for which we want regulatory information for
  *
@@ -3854,17 +3854,17 @@ void wiphy_apply_custom_regulatory(struc
  * See freq_in_rule_band() for our current definition of a band -- this is
  * purely subjective and right now it's 802.11 specific.
  */
-const struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,
+const struct ieee80211_reg_rule *freq_reg_info_dup(struct wiphy *wiphy,
 					       u32 center_freq);
 
 /**
- * reg_initiator_name - map regulatory request initiator enum to name
+ * reg_initiator_name_dup - map regulatory request initiator enum to name
  * @initiator: the regulatory request initiator
  *
  * You can use this to map the regulatory request initiator enum to a
  * proper string representation.
  */
-const char *reg_initiator_name(enum nl80211_reg_initiator initiator);
+const char *reg_initiator_name_dup(enum nl80211_reg_initiator initiator);
 
 /*
  * callbacks for asynchronous cfg80211 methods, notification
@@ -3872,23 +3872,23 @@ const char *reg_initiator_name(enum nl80
  */
 
 /**
- * cfg80211_scan_done - notify that scan finished
+ * cfg80211_scan_done_dup - notify that scan finished
  *
  * @request: the corresponding scan request
  * @aborted: set to true if the scan was aborted for any reason,
  *	userspace will be notified of that
  */
-void cfg80211_scan_done(struct cfg80211_scan_request *request, bool aborted);
+void cfg80211_scan_done_dup(struct cfg80211_scan_request *request, bool aborted);
 
 /**
- * cfg80211_sched_scan_results - notify that new scan results are available
+ * cfg80211_sched_scan_results_dup - notify that new scan results are available
  *
  * @wiphy: the wiphy which got scheduled scan results
  */
-void cfg80211_sched_scan_results(struct wiphy *wiphy);
+void cfg80211_sched_scan_results_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_sched_scan_stopped - notify that the scheduled scan has stopped
+ * cfg80211_sched_scan_stopped_dup - notify that the scheduled scan has stopped
  *
  * @wiphy: the wiphy on which the scheduled scan stopped
  *
@@ -3896,10 +3896,10 @@ void cfg80211_sched_scan_results(struct
  * scheduled scan had to be stopped, for whatever reason.  The driver
  * is then called back via the sched_scan_stop operation when done.
  */
-void cfg80211_sched_scan_stopped(struct wiphy *wiphy);
+void cfg80211_sched_scan_stopped_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_sched_scan_stopped_rtnl - notify that the scheduled scan has stopped
+ * cfg80211_sched_scan_stopped_rtnl_dup - notify that the scheduled scan has stopped
  *
  * @wiphy: the wiphy on which the scheduled scan stopped
  *
@@ -3908,10 +3908,10 @@ void cfg80211_sched_scan_stopped(struct
  * is then called back via the sched_scan_stop operation when done.
  * This function should be called with rtnl locked.
  */
-void cfg80211_sched_scan_stopped_rtnl(struct wiphy *wiphy);
+void cfg80211_sched_scan_stopped_rtnl_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_inform_bss_width_frame - inform cfg80211 of a received BSS frame
+ * cfg80211_inform_bss_width_frame_dup - inform cfg80211 of a received BSS frame
  *
  * @wiphy: the wiphy reporting the BSS
  * @rx_channel: The channel the frame was received on
@@ -3924,11 +3924,11 @@ void cfg80211_sched_scan_stopped_rtnl(st
  * This informs cfg80211 that BSS information was found and
  * the BSS should be updated/added.
  *
- * Return: A referenced struct, must be released with cfg80211_put_bss()!
+ * Return: A referenced struct, must be released with cfg80211_put_bss_dup()!
  * Or %NULL on error.
  */
 struct cfg80211_bss * __must_check
-cfg80211_inform_bss_width_frame(struct wiphy *wiphy,
+cfg80211_inform_bss_width_frame_dup(struct wiphy *wiphy,
 				struct ieee80211_channel *rx_channel,
 				enum nl80211_bss_scan_width scan_width,
 				struct ieee80211_mgmt *mgmt, size_t len,
@@ -3940,7 +3940,7 @@ cfg80211_inform_bss_frame(struct wiphy *
 			  struct ieee80211_mgmt *mgmt, size_t len,
 			  s32 signal, gfp_t gfp)
 {
-	return cfg80211_inform_bss_width_frame(wiphy, rx_channel,
+	return cfg80211_inform_bss_width_frame_dup(wiphy, rx_channel,
 					       NL80211_BSS_CHAN_WIDTH_20,
 					       mgmt, len, signal, gfp);
 }
@@ -3959,7 +3959,7 @@ enum cfg80211_bss_frame_type {
 };
 
 /**
- * cfg80211_inform_bss_width - inform cfg80211 of a new BSS
+ * cfg80211_inform_bss_width_dup - inform cfg80211 of a new BSS
  *
  * @wiphy: the wiphy reporting the BSS
  * @rx_channel: The channel the frame was received on
@@ -3977,11 +3977,11 @@ enum cfg80211_bss_frame_type {
  * This informs cfg80211 that BSS information was found and
  * the BSS should be updated/added.
  *
- * Return: A referenced struct, must be released with cfg80211_put_bss()!
+ * Return: A referenced struct, must be released with cfg80211_put_bss_dup()!
  * Or %NULL on error.
  */
 struct cfg80211_bss * __must_check
-cfg80211_inform_bss_width(struct wiphy *wiphy,
+cfg80211_inform_bss_width_dup(struct wiphy *wiphy,
 			  struct ieee80211_channel *rx_channel,
 			  enum nl80211_bss_scan_width scan_width,
 			  enum cfg80211_bss_frame_type ftype,
@@ -3997,14 +3997,14 @@ cfg80211_inform_bss(struct wiphy *wiphy,
 		    u16 beacon_interval, const u8 *ie, size_t ielen,
 		    s32 signal, gfp_t gfp)
 {
-	return cfg80211_inform_bss_width(wiphy, rx_channel,
+	return cfg80211_inform_bss_width_dup(wiphy, rx_channel,
 					 NL80211_BSS_CHAN_WIDTH_20, ftype,
 					 bssid, tsf, capability,
 					 beacon_interval, ie, ielen, signal,
 					 gfp);
 }
 
-struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,
+struct cfg80211_bss *cfg80211_get_bss_dup(struct wiphy *wiphy,
 				      struct ieee80211_channel *channel,
 				      const u8 *bssid,
 				      const u8 *ssid, size_t ssid_len,
@@ -4014,30 +4014,30 @@ cfg80211_get_ibss(struct wiphy *wiphy,
 		  struct ieee80211_channel *channel,
 		  const u8 *ssid, size_t ssid_len)
 {
-	return cfg80211_get_bss(wiphy, channel, NULL, ssid, ssid_len,
+	return cfg80211_get_bss_dup(wiphy, channel, NULL, ssid, ssid_len,
 				WLAN_CAPABILITY_IBSS, WLAN_CAPABILITY_IBSS);
 }
 
 /**
- * cfg80211_ref_bss - reference BSS struct
+ * cfg80211_ref_bss_dup - reference BSS struct
  * @wiphy: the wiphy this BSS struct belongs to
  * @bss: the BSS struct to reference
  *
  * Increments the refcount of the given BSS struct.
  */
-void cfg80211_ref_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+void cfg80211_ref_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *bss);
 
 /**
- * cfg80211_put_bss - unref BSS struct
+ * cfg80211_put_bss_dup - unref BSS struct
  * @wiphy: the wiphy this BSS struct belongs to
  * @bss: the BSS struct
  *
  * Decrements the refcount of the given BSS struct.
  */
-void cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+void cfg80211_put_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *bss);
 
 /**
- * cfg80211_unlink_bss - unlink BSS from internal data structures
+ * cfg80211_unlink_bss_dup - unlink BSS from internal data structures
  * @wiphy: the wiphy
  * @bss: the bss to remove
  *
@@ -4046,7 +4046,7 @@ void cfg80211_put_bss(struct wiphy *wiph
  * function when you detect a BSS is gone. Normally BSSes will also time
  * out, so it is not necessary to use this function at all.
  */
-void cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
+void cfg80211_unlink_bss_dup(struct wiphy *wiphy, struct cfg80211_bss *bss);
 
 static inline enum nl80211_bss_scan_width
 cfg80211_chandef_to_scan_width(const struct cfg80211_chan_def *chandef)
@@ -4062,7 +4062,7 @@ cfg80211_chandef_to_scan_width(const str
 }
 
 /**
- * cfg80211_rx_mlme_mgmt - notification of processed MLME management frame
+ * cfg80211_rx_mlme_mgmt_dup - notification of processed MLME management frame
  * @dev: network device
  * @buf: authentication frame (header + body)
  * @len: length of the frame data
@@ -4070,30 +4070,30 @@ cfg80211_chandef_to_scan_width(const str
  * This function is called whenever an authentication, disassociation or
  * deauthentication frame has been received and processed in station mode.
  * After being asked to authenticate via cfg80211_ops::auth() the driver must
- * call either this function or cfg80211_auth_timeout().
+ * call either this function or cfg80211_auth_timeout_dup().
  * After being asked to associate via cfg80211_ops::assoc() the driver must
- * call either this function or cfg80211_auth_timeout().
+ * call either this function or cfg80211_auth_timeout_dup().
  * While connected, the driver must calls this for received and processed
  * disassociation and deauthentication frames. If the frame couldn't be used
  * because it was unprotected, the driver must call the function
- * cfg80211_rx_unprot_mlme_mgmt() instead.
+ * cfg80211_rx_unprot_mlme_mgmt_dup() instead.
  *
  * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
+void cfg80211_rx_mlme_mgmt_dup(struct net_device *dev, const u8 *buf, size_t len);
 
 /**
- * cfg80211_auth_timeout - notification of timed out authentication
+ * cfg80211_auth_timeout_dup - notification of timed out authentication
  * @dev: network device
  * @addr: The MAC address of the device with which the authentication timed out
  *
  * This function may sleep. The caller must hold the corresponding wdev's
  * mutex.
  */
-void cfg80211_auth_timeout(struct net_device *dev, const u8 *addr);
+void cfg80211_auth_timeout_dup(struct net_device *dev, const u8 *addr);
 
 /**
- * cfg80211_rx_assoc_resp - notification of processed association response
+ * cfg80211_rx_assoc_resp_dup - notification of processed association response
  * @dev: network device
  * @bss: the BSS that association was requested with, ownership of the pointer
  *	moves to cfg80211 in this call
@@ -4102,26 +4102,26 @@ void cfg80211_auth_timeout(struct net_de
  * @uapsd_queues: bitmap of ACs configured to uapsd. -1 if n/a.
  *
  * After being asked to associate via cfg80211_ops::assoc() the driver must
- * call either this function or cfg80211_auth_timeout().
+ * call either this function or cfg80211_auth_timeout_dup().
  *
  * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_rx_assoc_resp(struct net_device *dev,
+void cfg80211_rx_assoc_resp_dup(struct net_device *dev,
 			    struct cfg80211_bss *bss,
 			    const u8 *buf, size_t len,
 			    int uapsd_queues);
 
 /**
- * cfg80211_assoc_timeout - notification of timed out association
+ * cfg80211_assoc_timeout_dup - notification of timed out association
  * @dev: network device
  * @bss: The BSS entry with which association timed out.
  *
  * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss);
+void cfg80211_assoc_timeout_dup(struct net_device *dev, struct cfg80211_bss *bss);
 
 /**
- * cfg80211_tx_mlme_mgmt - notification of transmitted deauth/disassoc frame
+ * cfg80211_tx_mlme_mgmt_dup - notification of transmitted deauth/disassoc frame
  * @dev: network device
  * @buf: 802.11 frame (header + body)
  * @len: length of the frame data
@@ -4131,10 +4131,10 @@ void cfg80211_assoc_timeout(struct net_d
  * locally generated ones. This function may sleep. The caller must hold the
  * corresponding wdev's mutex.
  */
-void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
+void cfg80211_tx_mlme_mgmt_dup(struct net_device *dev, const u8 *buf, size_t len);
 
 /**
- * cfg80211_rx_unprot_mlme_mgmt - notification of unprotected mlme mgmt frame
+ * cfg80211_rx_unprot_mlme_mgmt_dup - notification of unprotected mlme mgmt frame
  * @dev: network device
  * @buf: deauthentication frame (header + body)
  * @len: length of the frame data
@@ -4143,11 +4143,11 @@ void cfg80211_tx_mlme_mgmt(struct net_de
  * frame has been dropped in station mode because of MFP being used but the
  * frame was not protected. This function may sleep.
  */
-void cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev,
+void cfg80211_rx_unprot_mlme_mgmt_dup(struct net_device *dev,
 				  const u8 *buf, size_t len);
 
 /**
- * cfg80211_michael_mic_failure - notification of Michael MIC failure (TKIP)
+ * cfg80211_michael_mic_failure_dup - notification of Michael MIC failure (TKIP)
  * @dev: network device
  * @addr: The source MAC address of the frame
  * @key_type: The key type that the received frame used
@@ -4159,12 +4159,12 @@ void cfg80211_rx_unprot_mlme_mgmt(struct
  * received frame. This matches with MLME-MICHAELMICFAILURE.indication()
  * primitive.
  */
-void cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,
+void cfg80211_michael_mic_failure_dup(struct net_device *dev, const u8 *addr,
 				  enum nl80211_key_type key_type, int key_id,
 				  const u8 *tsc, gfp_t gfp);
 
 /**
- * cfg80211_ibss_joined - notify cfg80211 that device joined an IBSS
+ * cfg80211_ibss_joined_dup - notify cfg80211 that device joined an IBSS
  *
  * @dev: network device
  * @bssid: the BSSID of the IBSS joined
@@ -4178,7 +4178,7 @@ void cfg80211_michael_mic_failure(struct
  * with the locally generated beacon -- this guarantees that there is
  * always a scan result for this IBSS. cfg80211 will handle the rest.
  */
-void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+void cfg80211_ibss_joined_dup(struct net_device *dev, const u8 *bssid,
 			  struct ieee80211_channel *channel, gfp_t gfp);
 
 /**
@@ -4194,7 +4194,7 @@ void cfg80211_ibss_joined(struct net_dev
  * detected, most likely via a beacon or, less likely, via a probe response.
  * cfg80211 then sends a notification to userspace.
  */
-void cfg80211_notify_new_peer_candidate(struct net_device *dev,
+void cfg80211_notify_new_peer_candidate_dup(struct net_device *dev,
 		const u8 *macaddr, const u8 *ie, u8 ie_len, gfp_t gfp);
 
 /**
@@ -4212,23 +4212,23 @@ void cfg80211_notify_new_peer_candidate(
  */
 
 /**
- * wiphy_rfkill_set_hw_state - notify cfg80211 about hw block state
+ * wiphy_rfkill_set_hw_state_dup - notify cfg80211 about hw block state
  * @wiphy: the wiphy
  * @blocked: block status
  */
-void wiphy_rfkill_set_hw_state(struct wiphy *wiphy, bool blocked);
+void wiphy_rfkill_set_hw_state_dup(struct wiphy *wiphy, bool blocked);
 
 /**
- * wiphy_rfkill_start_polling - start polling rfkill
+ * wiphy_rfkill_start_polling_dup - start polling rfkill
  * @wiphy: the wiphy
  */
-void wiphy_rfkill_start_polling(struct wiphy *wiphy);
+void wiphy_rfkill_start_polling_dup(struct wiphy *wiphy);
 
 /**
- * wiphy_rfkill_stop_polling - stop polling rfkill
+ * wiphy_rfkill_stop_polling_dup - stop polling rfkill
  * @wiphy: the wiphy
  */
-void wiphy_rfkill_stop_polling(struct wiphy *wiphy);
+void wiphy_rfkill_stop_polling_dup(struct wiphy *wiphy);
 
 /**
  * DOC: Vendor commands
@@ -4250,18 +4250,18 @@ void wiphy_rfkill_stop_polling(struct wi
  * managers etc. need.
  */
 
-struct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,
+struct sk_buff *__cfg80211_alloc_reply_skb_dup(struct wiphy *wiphy,
 					   enum nl80211_commands cmd,
 					   enum nl80211_attrs attr,
 					   int approxlen);
 
-struct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,
+struct sk_buff *__cfg80211_alloc_event_skb_dup(struct wiphy *wiphy,
 					   enum nl80211_commands cmd,
 					   enum nl80211_attrs attr,
 					   int vendor_event_idx,
 					   int approxlen, gfp_t gfp);
 
-void __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp);
+void __cfg80211_send_event_skb_dup(struct sk_buff *skb, gfp_t gfp);
 
 /**
  * cfg80211_vendor_cmd_alloc_reply_skb - allocate vendor command reply
@@ -4281,7 +4281,7 @@ void __cfg80211_send_event_skb(struct sk
  * which can then read that data out of the vendor data attribute.
  * You must not modify the skb in any other way.
  *
- * When done, call cfg80211_vendor_cmd_reply() with the skb and return
+ * When done, call cfg80211_vendor_cmd_reply_dup() with the skb and return
  * its error code as the result of the doit() operation.
  *
  * Return: An allocated and pre-filled skb. %NULL if any errors happen.
@@ -4289,12 +4289,12 @@ void __cfg80211_send_event_skb(struct sk
 static inline struct sk_buff *
 cfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
 {
-	return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_VENDOR,
+	return __cfg80211_alloc_reply_skb_dup(wiphy, NL80211_CMD_VENDOR,
 					  NL80211_ATTR_VENDOR_DATA, approxlen);
 }
 
 /**
- * cfg80211_vendor_cmd_reply - send the reply skb
+ * cfg80211_vendor_cmd_reply_dup - send the reply skb
  * @skb: The skb, must have been allocated with
  *	cfg80211_vendor_cmd_alloc_reply_skb()
  *
@@ -4305,7 +4305,7 @@ cfg80211_vendor_cmd_alloc_reply_skb(stru
  *
  * Return: An error code or 0 on success.
  */
-int cfg80211_vendor_cmd_reply(struct sk_buff *skb);
+int cfg80211_vendor_cmd_reply_dup(struct sk_buff *skb);
 
 /**
  * cfg80211_vendor_event_alloc - allocate vendor-specific event skb
@@ -4327,7 +4327,7 @@ static inline struct sk_buff *
 cfg80211_vendor_event_alloc(struct wiphy *wiphy, int approxlen,
 			    int event_idx, gfp_t gfp)
 {
-	return __cfg80211_alloc_event_skb(wiphy, NL80211_CMD_VENDOR,
+	return __cfg80211_alloc_event_skb_dup(wiphy, NL80211_CMD_VENDOR,
 					  NL80211_ATTR_VENDOR_DATA,
 					  event_idx, approxlen, gfp);
 }
@@ -4342,7 +4342,7 @@ cfg80211_vendor_event_alloc(struct wiphy
  */
 static inline void cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp)
 {
-	__cfg80211_send_event_skb(skb, gfp);
+	__cfg80211_send_event_skb_dup(skb, gfp);
 }
 
 #ifdef CONFIG_NL80211_TESTMODE
@@ -4383,7 +4383,7 @@ static inline void cfg80211_vendor_event
 static inline struct sk_buff *
 cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
 {
-	return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_TESTMODE,
+	return __cfg80211_alloc_reply_skb_dup(wiphy, NL80211_CMD_TESTMODE,
 					  NL80211_ATTR_TESTDATA, approxlen);
 }
 
@@ -4401,7 +4401,7 @@ cfg80211_testmode_alloc_reply_skb(struct
  */
 static inline int cfg80211_testmode_reply(struct sk_buff *skb)
 {
-	return cfg80211_vendor_cmd_reply(skb);
+	return cfg80211_vendor_cmd_reply_dup(skb);
 }
 
 /**
@@ -4428,7 +4428,7 @@ static inline int cfg80211_testmode_repl
 static inline struct sk_buff *
 cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy, int approxlen, gfp_t gfp)
 {
-	return __cfg80211_alloc_event_skb(wiphy, NL80211_CMD_TESTMODE,
+	return __cfg80211_alloc_event_skb_dup(wiphy, NL80211_CMD_TESTMODE,
 					  NL80211_ATTR_TESTDATA, -1,
 					  approxlen, gfp);
 }
@@ -4445,7 +4445,7 @@ cfg80211_testmode_alloc_event_skb(struct
  */
 static inline void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)
 {
-	__cfg80211_send_event_skb(skb, gfp);
+	__cfg80211_send_event_skb_dup(skb, gfp);
 }
 
 #define CFG80211_TESTMODE_CMD(cmd)	.testmode_cmd = (cmd),
@@ -4456,7 +4456,7 @@ static inline void cfg80211_testmode_eve
 #endif
 
 /**
- * cfg80211_connect_result - notify cfg80211 of connection result
+ * cfg80211_connect_result_dup - notify cfg80211 of connection result
  *
  * @dev: network device
  * @bssid: the BSSID of the AP
@@ -4472,13 +4472,13 @@ static inline void cfg80211_testmode_eve
  * It should be called by the underlying driver whenever connect() has
  * succeeded.
  */
-void cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
+void cfg80211_connect_result_dup(struct net_device *dev, const u8 *bssid,
 			     const u8 *req_ie, size_t req_ie_len,
 			     const u8 *resp_ie, size_t resp_ie_len,
 			     u16 status, gfp_t gfp);
 
 /**
- * cfg80211_roamed - notify cfg80211 of roaming
+ * cfg80211_roamed_dup - notify cfg80211 of roaming
  *
  * @dev: network device
  * @channel: the channel of the new AP
@@ -4492,14 +4492,14 @@ void cfg80211_connect_result(struct net_
  * It should be called by the underlying driver whenever it roamed
  * from one AP to another while connected.
  */
-void cfg80211_roamed(struct net_device *dev,
+void cfg80211_roamed_dup(struct net_device *dev,
 		     struct ieee80211_channel *channel,
 		     const u8 *bssid,
 		     const u8 *req_ie, size_t req_ie_len,
 		     const u8 *resp_ie, size_t resp_ie_len, gfp_t gfp);
 
 /**
- * cfg80211_roamed_bss - notify cfg80211 of roaming
+ * cfg80211_roamed_bss_dup - notify cfg80211 of roaming
  *
  * @dev: network device
  * @bss: entry of bss to which STA got roamed
@@ -4515,17 +4515,17 @@ void cfg80211_roamed(struct net_device *
  * while connected. Drivers which have roaming implemented in firmware
  * may use this function to avoid a race in bss entry timeout where the bss
  * entry of the new AP is seen in the driver, but gets timed out by the time
- * it is accessed in __cfg80211_roamed() due to delay in scheduling
+ * it is accessed in __cfg80211_roamed_dup() due to delay in scheduling
  * rdev->event_work. In case of any failures, the reference is released
- * either in cfg80211_roamed_bss() or in __cfg80211_romed(), Otherwise,
+ * either in cfg80211_roamed_bss_dup() or in __cfg80211_romed(), Otherwise,
  * it will be released while diconneting from the current bss.
  */
-void cfg80211_roamed_bss(struct net_device *dev, struct cfg80211_bss *bss,
+void cfg80211_roamed_bss_dup(struct net_device *dev, struct cfg80211_bss *bss,
 			 const u8 *req_ie, size_t req_ie_len,
 			 const u8 *resp_ie, size_t resp_ie_len, gfp_t gfp);
 
 /**
- * cfg80211_disconnected - notify cfg80211 that connection was dropped
+ * cfg80211_disconnected_dup - notify cfg80211 that connection was dropped
  *
  * @dev: network device
  * @ie: information elements of the deauth/disassoc frame (may be %NULL)
@@ -4536,11 +4536,11 @@ void cfg80211_roamed_bss(struct net_devi
  * After it calls this function, the driver should enter an idle state
  * and not try to connect to any AP any more.
  */
-void cfg80211_disconnected(struct net_device *dev, u16 reason,
+void cfg80211_disconnected_dup(struct net_device *dev, u16 reason,
 			   const u8 *ie, size_t ie_len, gfp_t gfp);
 
 /**
- * cfg80211_ready_on_channel - notification of remain_on_channel start
+ * cfg80211_ready_on_channel_dup - notification of remain_on_channel start
  * @wdev: wireless device
  * @cookie: the request cookie
  * @chan: The current channel (from remain_on_channel request)
@@ -4548,44 +4548,44 @@ void cfg80211_disconnected(struct net_de
  *	channel
  * @gfp: allocation flags
  */
-void cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_ready_on_channel_dup(struct wireless_dev *wdev, u64 cookie,
 			       struct ieee80211_channel *chan,
 			       unsigned int duration, gfp_t gfp);
 
 /**
- * cfg80211_remain_on_channel_expired - remain_on_channel duration expired
+ * cfg80211_remain_on_channel_expired_dup - remain_on_channel duration expired
  * @wdev: wireless device
  * @cookie: the request cookie
  * @chan: The current channel (from remain_on_channel request)
  * @gfp: allocation flags
  */
-void cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_remain_on_channel_expired_dup(struct wireless_dev *wdev, u64 cookie,
 					struct ieee80211_channel *chan,
 					gfp_t gfp);
 
 
 /**
- * cfg80211_new_sta - notify userspace about station
+ * cfg80211_new_sta_dup - notify userspace about station
  *
  * @dev: the netdev
  * @mac_addr: the station's address
  * @sinfo: the station information
  * @gfp: allocation flags
  */
-void cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,
+void cfg80211_new_sta_dup(struct net_device *dev, const u8 *mac_addr,
 		      struct station_info *sinfo, gfp_t gfp);
 
 /**
- * cfg80211_del_sta - notify userspace about deletion of a station
+ * cfg80211_del_sta_dup - notify userspace about deletion of a station
  *
  * @dev: the netdev
  * @mac_addr: the station's address
  * @gfp: allocation flags
  */
-void cfg80211_del_sta(struct net_device *dev, const u8 *mac_addr, gfp_t gfp);
+void cfg80211_del_sta_dup(struct net_device *dev, const u8 *mac_addr, gfp_t gfp);
 
 /**
- * cfg80211_conn_failed - connection request failed notification
+ * cfg80211_conn_failed_dup - connection request failed notification
  *
  * @dev: the netdev
  * @mac_addr: the station's address
@@ -4599,12 +4599,12 @@ void cfg80211_del_sta(struct net_device
  * The reason for connection failure can be any of the value from
  * nl80211_connect_failed_reason enum
  */
-void cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,
+void cfg80211_conn_failed_dup(struct net_device *dev, const u8 *mac_addr,
 			  enum nl80211_connect_failed_reason reason,
 			  gfp_t gfp);
 
 /**
- * cfg80211_rx_mgmt - notification of received, unprocessed management frame
+ * cfg80211_rx_mgmt_dup - notification of received, unprocessed management frame
  * @wdev: wireless device receiving the frame
  * @freq: Frequency on which the frame was received in MHz
  * @sig_dbm: signal strength in mBm, or 0 if unknown
@@ -4620,11 +4620,11 @@ void cfg80211_conn_failed(struct net_dev
  * action frames; %false otherwise, in which case for action frames the
  * driver is responsible for rejecting the frame.
  */
-bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq, int sig_dbm,
+bool cfg80211_rx_mgmt_dup(struct wireless_dev *wdev, int freq, int sig_dbm,
 		      const u8 *buf, size_t len, u32 flags);
 
 /**
- * cfg80211_mgmt_tx_status - notification of TX status for management frame
+ * cfg80211_mgmt_tx_status_dup - notification of TX status for management frame
  * @wdev: wireless device receiving the frame
  * @cookie: Cookie returned by cfg80211_ops::mgmt_tx()
  * @buf: Management frame (header + body)
@@ -4636,12 +4636,12 @@ bool cfg80211_rx_mgmt(struct wireless_de
  * transmitted with cfg80211_ops::mgmt_tx() to report the TX status of the
  * transmission attempt.
  */
-void cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,
+void cfg80211_mgmt_tx_status_dup(struct wireless_dev *wdev, u64 cookie,
 			     const u8 *buf, size_t len, bool ack, gfp_t gfp);
 
 
 /**
- * cfg80211_cqm_rssi_notify - connection quality monitoring rssi event
+ * cfg80211_cqm_rssi_notify_dup - connection quality monitoring rssi event
  * @dev: network device
  * @rssi_event: the triggered RSSI event
  * @gfp: context flags
@@ -4649,12 +4649,12 @@ void cfg80211_mgmt_tx_status(struct wire
  * This function is called when a configured connection quality monitoring
  * rssi threshold reached event occurs.
  */
-void cfg80211_cqm_rssi_notify(struct net_device *dev,
+void cfg80211_cqm_rssi_notify_dup(struct net_device *dev,
 			      enum nl80211_cqm_rssi_threshold_event rssi_event,
 			      gfp_t gfp);
 
 /**
- * cfg80211_cqm_pktloss_notify - notify userspace about packetloss to peer
+ * cfg80211_cqm_pktloss_notify_dup - notify userspace about packetloss to peer
  * @dev: network device
  * @peer: peer's MAC address
  * @num_packets: how many packets were lost -- should be a fixed threshold
@@ -4662,11 +4662,11 @@ void cfg80211_cqm_rssi_notify(struct net
  *	threshold (to account for temporary interference)
  * @gfp: context flags
  */
-void cfg80211_cqm_pktloss_notify(struct net_device *dev,
+void cfg80211_cqm_pktloss_notify_dup(struct net_device *dev,
 				 const u8 *peer, u32 num_packets, gfp_t gfp);
 
 /**
- * cfg80211_cqm_txe_notify - TX error rate event
+ * cfg80211_cqm_txe_notify_dup - TX error rate event
  * @dev: network device
  * @peer: peer's MAC address
  * @num_packets: how many packets were lost
@@ -4677,31 +4677,31 @@ void cfg80211_cqm_pktloss_notify(struct
  * Notify userspace when configured % TX failures over number of packets in a
  * given interval is exceeded.
  */
-void cfg80211_cqm_txe_notify(struct net_device *dev, const u8 *peer,
+void cfg80211_cqm_txe_notify_dup(struct net_device *dev, const u8 *peer,
 			     u32 num_packets, u32 rate, u32 intvl, gfp_t gfp);
 
 /**
- * cfg80211_cqm_beacon_loss_notify - beacon loss event
+ * cfg80211_cqm_beacon_loss_notify_dup - beacon loss event
  * @dev: network device
  * @gfp: context flags
  *
  * Notify userspace about beacon loss from the connected AP.
  */
-void cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp);
+void cfg80211_cqm_beacon_loss_notify_dup(struct net_device *dev, gfp_t gfp);
 
 /**
- * cfg80211_radar_event - radar detection event
+ * cfg80211_radar_event_dup - radar detection event
  * @wiphy: the wiphy
  * @chandef: chandef for the current channel
  * @gfp: context flags
  *
  * This function is called when a radar is detected on the current chanenl.
  */
-void cfg80211_radar_event(struct wiphy *wiphy,
+void cfg80211_radar_event_dup(struct wiphy *wiphy,
 			  struct cfg80211_chan_def *chandef, gfp_t gfp);
 
 /**
- * cfg80211_cac_event - Channel availability check (CAC) event
+ * cfg80211_cac_event_dup - Channel availability check (CAC) event
  * @netdev: network device
  * @chandef: chandef for the current channel
  * @event: type of event
@@ -4711,34 +4711,34 @@ void cfg80211_radar_event(struct wiphy *
  * or aborted. This must be called to notify the completion of a CAC process,
  * also by full-MAC drivers.
  */
-void cfg80211_cac_event(struct net_device *netdev,
+void cfg80211_cac_event_dup(struct net_device *netdev,
 			const struct cfg80211_chan_def *chandef,
 			enum nl80211_radar_event event, gfp_t gfp);
 
 
 /**
- * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying
+ * cfg80211_gtk_rekey_notify_dup - notify userspace about driver rekeying
  * @dev: network device
  * @bssid: BSSID of AP (to avoid races)
  * @replay_ctr: new replay counter
  * @gfp: allocation flags
  */
-void cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,
+void cfg80211_gtk_rekey_notify_dup(struct net_device *dev, const u8 *bssid,
 			       const u8 *replay_ctr, gfp_t gfp);
 
 /**
- * cfg80211_pmksa_candidate_notify - notify about PMKSA caching candidate
+ * cfg80211_pmksa_candidate_notify_dup - notify about PMKSA caching candidate
  * @dev: network device
  * @index: candidate index (the smaller the index, the higher the priority)
  * @bssid: BSSID of AP
  * @preauth: Whether AP advertises support for RSN pre-authentication
  * @gfp: allocation flags
  */
-void cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,
+void cfg80211_pmksa_candidate_notify_dup(struct net_device *dev, int index,
 				     const u8 *bssid, bool preauth, gfp_t gfp);
 
 /**
- * cfg80211_rx_spurious_frame - inform userspace about a spurious frame
+ * cfg80211_rx_spurious_frame_dup - inform userspace about a spurious frame
  * @dev: The device the frame matched to
  * @addr: the transmitter address
  * @gfp: context flags
@@ -4749,11 +4749,11 @@ void cfg80211_pmksa_candidate_notify(str
  * Return: %true if the frame was passed to userspace (or this failed
  * for a reason other than not having a subscription.)
  */
-bool cfg80211_rx_spurious_frame(struct net_device *dev,
+bool cfg80211_rx_spurious_frame_dup(struct net_device *dev,
 				const u8 *addr, gfp_t gfp);
 
 /**
- * cfg80211_rx_unexpected_4addr_frame - inform about unexpected WDS frame
+ * cfg80211_rx_unexpected_4addr_frame_dup - inform about unexpected WDS frame
  * @dev: The device the frame matched to
  * @addr: the transmitter address
  * @gfp: context flags
@@ -4765,22 +4765,22 @@ bool cfg80211_rx_spurious_frame(struct n
  * Return: %true if the frame was passed to userspace (or this failed
  * for a reason other than not having a subscription.)
  */
-bool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,
+bool cfg80211_rx_unexpected_4addr_frame_dup(struct net_device *dev,
 					const u8 *addr, gfp_t gfp);
 
 /**
- * cfg80211_probe_status - notify userspace about probe status
+ * cfg80211_probe_status_dup - notify userspace about probe status
  * @dev: the device the probe was sent on
  * @addr: the address of the peer
  * @cookie: the cookie filled in @probe_client previously
  * @acked: indicates whether probe was acked or not
  * @gfp: allocation flags
  */
-void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
+void cfg80211_probe_status_dup(struct net_device *dev, const u8 *addr,
 			   u64 cookie, bool acked, gfp_t gfp);
 
 /**
- * cfg80211_report_obss_beacon - report beacon from other APs
+ * cfg80211_report_obss_beacon_dup - report beacon from other APs
  * @wiphy: The wiphy that received the beacon
  * @frame: the frame
  * @len: length of the frame
@@ -4791,12 +4791,12 @@ void cfg80211_probe_status(struct net_de
  * received. It is not useful to call this when there is no
  * netdev that is in AP/GO mode.
  */
-void cfg80211_report_obss_beacon(struct wiphy *wiphy,
+void cfg80211_report_obss_beacon_dup(struct wiphy *wiphy,
 				 const u8 *frame, size_t len,
 				 int freq, int sig_dbm);
 
 /**
- * cfg80211_reg_can_beacon - check if beaconing is allowed
+ * cfg80211_reg_can_beacon_dup - check if beaconing is allowed
  * @wiphy: the wiphy
  * @chandef: the channel definition
  * @iftype: interface type
@@ -4804,23 +4804,23 @@ void cfg80211_report_obss_beacon(struct
  * Return: %true if there is no secondary channel or the secondary channel(s)
  * can be used for beaconing (i.e. is not a radar channel etc.)
  */
-bool cfg80211_reg_can_beacon(struct wiphy *wiphy,
+bool cfg80211_reg_can_beacon_dup(struct wiphy *wiphy,
 			     struct cfg80211_chan_def *chandef,
 			     enum nl80211_iftype iftype);
 
 /*
- * cfg80211_ch_switch_notify - update wdev channel and notify userspace
+ * cfg80211_ch_switch_notify_dup - update wdev channel and notify userspace
  * @dev: the device which switched channels
  * @chandef: the new channel definition
  *
  * Caller must acquire wdev_lock, therefore must only be called from sleepable
  * driver context!
  */
-void cfg80211_ch_switch_notify(struct net_device *dev,
+void cfg80211_ch_switch_notify_dup(struct net_device *dev,
 			       struct cfg80211_chan_def *chandef);
 
 /*
- * cfg80211_ch_switch_started_notify - notify channel switch start
+ * cfg80211_ch_switch_started_notify_dup - notify channel switch start
  * @dev: the device on which the channel switch started
  * @chandef: the future channel definition
  * @count: the number of TBTTs until the channel switch happens
@@ -4829,23 +4829,23 @@ void cfg80211_ch_switch_notify(struct ne
  * started, so that it can take appropriate actions (eg. starting
  * channel switch on other vifs), if necessary.
  */
-void cfg80211_ch_switch_started_notify(struct net_device *dev,
+void cfg80211_ch_switch_started_notify_dup(struct net_device *dev,
 				       struct cfg80211_chan_def *chandef,
 				       u8 count);
 
 /**
- * ieee80211_operating_class_to_band - convert operating class to band
+ * ieee80211_operating_class_to_band_dup - convert operating class to band
  *
  * @operating_class: the operating class to convert
  * @band: band pointer to fill
  *
  * Returns %true if the conversion was successful, %false otherwise.
  */
-bool ieee80211_operating_class_to_band(u8 operating_class,
+bool ieee80211_operating_class_to_band_dup(u8 operating_class,
 				       enum ieee80211_band *band);
 
 /*
- * cfg80211_tdls_oper_request - request userspace to perform TDLS operation
+ * cfg80211_tdls_oper_request_dup - request userspace to perform TDLS operation
  * @dev: the device on which the operation is requested
  * @peer: the MAC address of the peer device
  * @oper: the requested TDLS operation (NL80211_TDLS_SETUP or
@@ -4859,20 +4859,20 @@ bool ieee80211_operating_class_to_band(u
  * if it can automatically determine when a TDLS link could be useful (e.g.,
  * based on traffic and signal strength for a peer).
  */
-void cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,
+void cfg80211_tdls_oper_request_dup(struct net_device *dev, const u8 *peer,
 				enum nl80211_tdls_operation oper,
 				u16 reason_code, gfp_t gfp);
 
 /*
- * cfg80211_calculate_bitrate - calculate actual bitrate (in 100Kbps units)
+ * cfg80211_calculate_bitrate_dup - calculate actual bitrate (in 100Kbps units)
  * @rate: given rate_info to calculate bitrate from
  *
  * return 0 if MCS index >= 32
  */
-u32 cfg80211_calculate_bitrate(struct rate_info *rate);
+u32 cfg80211_calculate_bitrate_dup(struct rate_info *rate);
 
 /**
- * cfg80211_unregister_wdev - remove the given wdev
+ * cfg80211_unregister_wdev_dup - remove the given wdev
  * @wdev: struct wireless_dev to remove
  *
  * Call this function only for wdevs that have no netdev assigned,
@@ -4885,10 +4885,10 @@ u32 cfg80211_calculate_bitrate(struct ra
  *
  * Requires the RTNL to be held.
  */
-void cfg80211_unregister_wdev(struct wireless_dev *wdev);
+void cfg80211_unregister_wdev_dup(struct wireless_dev *wdev);
 
 /**
- * struct cfg80211_ft_event - FT Information Elements
+ * struct cfg80211_ft_event_dup - FT Information Elements
  * @ies: FT IEs
  * @ies_len: length of the FT IE in bytes
  * @target_ap: target AP's MAC address
@@ -4904,15 +4904,15 @@ struct cfg80211_ft_event_params {
 };
 
 /**
- * cfg80211_ft_event - notify userspace about FT IE and RIC IE
+ * cfg80211_ft_event_dup - notify userspace about FT IE and RIC IE
  * @netdev: network device
  * @ft_event: IE information
  */
-void cfg80211_ft_event(struct net_device *netdev,
+void cfg80211_ft_event_dup(struct net_device *netdev,
 		       struct cfg80211_ft_event_params *ft_event);
 
 /**
- * cfg80211_get_p2p_attr - find and copy a P2P attribute from IE buffer
+ * cfg80211_get_p2p_attr_dup - find and copy a P2P attribute from IE buffer
  * @ies: the input IE buffer
  * @len: the input length
  * @attr: the attribute ID to find
@@ -4927,12 +4927,12 @@ void cfg80211_ft_event(struct net_device
  * malformed or the attribute can't be found (respectively), or the
  * length of the found attribute (which can be zero).
  */
-int cfg80211_get_p2p_attr(const u8 *ies, unsigned int len,
+int cfg80211_get_p2p_attr_dup(const u8 *ies, unsigned int len,
 			  enum ieee80211_p2p_attr_id attr,
 			  u8 *buf, unsigned int bufsize);
 
 /**
- * cfg80211_report_wowlan_wakeup - report wakeup from WoWLAN
+ * cfg80211_report_wowlan_wakeup_dup - report wakeup from WoWLAN
  * @wdev: the wireless device reporting the wakeup
  * @wakeup: the wakeup report
  * @gfp: allocation flags
@@ -4942,12 +4942,12 @@ int cfg80211_get_p2p_attr(const u8 *ies,
  * pass %NULL as the @wakeup parameter to advertise that something
  * else caused the wakeup.
  */
-void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
+void cfg80211_report_wowlan_wakeup_dup(struct wireless_dev *wdev,
 				   struct cfg80211_wowlan_wakeup *wakeup,
 				   gfp_t gfp);
 
 /**
- * cfg80211_crit_proto_stopped() - indicate critical protocol stopped by driver.
+ * cfg80211_crit_proto_stopped_dup() - indicate critical protocol stopped by driver.
  *
  * @wdev: the wireless device for which critical protocol is stopped.
  * @gfp: allocation flags
@@ -4956,18 +4956,18 @@ void cfg80211_report_wowlan_wakeup(struc
  * operation back to normal. One reason could be that the duration given
  * by .crit_proto_start() has expired.
  */
-void cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp);
+void cfg80211_crit_proto_stopped_dup(struct wireless_dev *wdev, gfp_t gfp);
 
 /**
- * ieee80211_get_num_supported_channels - get number of channels device has
+ * ieee80211_get_num_supported_channels_dup - get number of channels device has
  * @wiphy: the wiphy
  *
  * Return: the number of channels supported by the device.
  */
-unsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy);
+unsigned int ieee80211_get_num_supported_channels_dup(struct wiphy *wiphy);
 
 /**
- * cfg80211_check_combinations - check interface combinations
+ * cfg80211_check_combinations_dup - check interface combinations
  *
  * @wiphy: the wiphy
  * @num_different_channels: the number of different channels we want
@@ -4983,13 +4983,13 @@ unsigned int ieee80211_get_num_supported
  * combination of interfaces and their types are allowed according to
  * the interface combinations.
  */
-int cfg80211_check_combinations(struct wiphy *wiphy,
+int cfg80211_check_combinations_dup(struct wiphy *wiphy,
 				const int num_different_channels,
 				const u8 radar_detect,
 				const int iftype_num[NUM_NL80211_IFTYPES]);
 
 /**
- * cfg80211_iter_combinations - iterate over matching combinations
+ * cfg80211_iter_combinations_dup - iterate over matching combinations
  *
  * @wiphy: the wiphy
  * @num_different_channels: the number of different channels we want
@@ -5007,7 +5007,7 @@ int cfg80211_check_combinations(struct w
  * combinations it fits in at a given moment, e.g. for channel switching
  * purposes.
  */
-int cfg80211_iter_combinations(struct wiphy *wiphy,
+int cfg80211_iter_combinations_dup(struct wiphy *wiphy,
 			       const int num_different_channels,
 			       const u8 radar_detect,
 			       const int iftype_num[NUM_NL80211_IFTYPES],
@@ -5016,7 +5016,7 @@ int cfg80211_iter_combinations(struct wi
 			       void *data);
 
 /*
- * cfg80211_stop_iface - trigger interface disconnection
+ * cfg80211_stop_iface_dup - trigger interface disconnection
  *
  * @wiphy: the wiphy
  * @wdev: wireless device
@@ -5027,11 +5027,11 @@ int cfg80211_iter_combinations(struct wi
  *
  * Note: This doesn't need any locks and is asynchronous.
  */
-void cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,
+void cfg80211_stop_iface_dup(struct wiphy *wiphy, struct wireless_dev *wdev,
 			 gfp_t gfp);
 
 /**
- * cfg80211_shutdown_all_interfaces - shut down all interfaces for a wiphy
+ * cfg80211_shutdown_all_interfaces_dup - shut down all interfaces for a wiphy
  * @wiphy: the wiphy to shut down
  *
  * This function shuts down all interfaces belonging to this wiphy by
@@ -5042,7 +5042,7 @@ void cfg80211_stop_iface(struct wiphy *w
  * Callers must hold the RTNL and be able to deal with callbacks into
  * the driver while the function is running.
  */
-void cfg80211_shutdown_all_interfaces(struct wiphy *wiphy);
+void cfg80211_shutdown_all_interfaces_dup(struct wiphy *wiphy);
 
 
 /* ethtool helper */
@@ -5046,7 +5046,7 @@ void cfg80211_shutdown_all_interfaces(struct wiphy *wiphy);
 
 
 /* ethtool helper */
-void cfg80211_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info);
+void cfg80211_get_drvinfo_dup(struct net_device *dev, struct ethtool_drvinfo *info);
 
 /* Logging, debugging and troubleshooting/diagnostic helpers. */
 
--- a/include/net/iw_handler.h	2015-06-23 11:07:42.670848883 +0200
+++ b/include/net/iw_handler.h	2015-06-23 16:42:01.921817484 +0200
@@ -216,7 +216,7 @@
  * --------
  *	- Move event definition in <linux/wireless.h>
  *	- Add Wireless Event support :
- *		o wireless_send_event() prototype
+ *		o wireless_send_event_dup() prototype
  *		o iwe_stream_add_event/point() inline functions
  * V3 to V4
  * --------
@@ -440,7 +440,7 @@ extern int dev_get_wireless_info(char *
 /* Second : functions that may be called by driver modules */
 
 /* Send a single event to user space */
-extern void wireless_send_event(struct net_device *	dev,
+extern void wireless_send_event_dup(struct net_device *	dev,
 				unsigned int		cmd,
 				union iwreq_data *	wrqu,
 				const char *		extra);
@@ -449,27 +449,27 @@ extern void wireless_send_event(struct n
  * More on that later... */
 
 /* Standard handler for SIOCSIWSPY */
-extern int iw_handler_set_spy(struct net_device *	dev,
+extern int iw_handler_set_spy_dup(struct net_device *	dev,
 			      struct iw_request_info *	info,
 			      union iwreq_data *	wrqu,
 			      char *			extra);
 /* Standard handler for SIOCGIWSPY */
-extern int iw_handler_get_spy(struct net_device *	dev,
+extern int iw_handler_get_spy_dup(struct net_device *	dev,
 			      struct iw_request_info *	info,
 			      union iwreq_data *	wrqu,
 			      char *			extra);
 /* Standard handler for SIOCSIWTHRSPY */
-extern int iw_handler_set_thrspy(struct net_device *	dev,
+extern int iw_handler_set_thrspy_dup(struct net_device *	dev,
 				 struct iw_request_info *info,
 				 union iwreq_data *	wrqu,
 				 char *			extra);
 /* Standard handler for SIOCGIWTHRSPY */
-extern int iw_handler_get_thrspy(struct net_device *	dev,
+extern int iw_handler_get_thrspy_dup(struct net_device *	dev,
 				 struct iw_request_info *info,
 				 union iwreq_data *	wrqu,
 				 char *			extra);
 /* Driver call to update spy records */
-extern void wireless_spy_update(struct net_device *	dev,
+extern void wireless_spy_update_dup(struct net_device *	dev,
 				unsigned char *		address,
 				struct iw_quality *	wstats);
 
--- a/include/net/lib80211.h	2015-06-23 11:07:42.670848883 +0200
+++ b/include/net/lib80211.h	2015-06-23 16:42:01.961817961 +0200
@@ -114,13 +114,13 @@ struct lib80211_crypt_info {
 	int crypt_quiesced;
 };
 
-int lib80211_crypt_info_init(struct lib80211_crypt_info *info, char *name,
+int lib80211_crypt_info_init_dup(struct lib80211_crypt_info *info, char *name,
                                 spinlock_t *lock);
-void lib80211_crypt_info_free(struct lib80211_crypt_info *info);
-int lib80211_register_crypto_ops(struct lib80211_crypto_ops *ops);
-int lib80211_unregister_crypto_ops(struct lib80211_crypto_ops *ops);
-struct lib80211_crypto_ops *lib80211_get_crypto_ops(const char *name);
-void lib80211_crypt_delayed_deinit(struct lib80211_crypt_info *info,
+void lib80211_crypt_info_free_dup(struct lib80211_crypt_info *info);
+int lib80211_register_crypto_ops_dup(struct lib80211_crypto_ops *ops);
+int lib80211_unregister_crypto_ops_dup(struct lib80211_crypto_ops *ops);
+struct lib80211_crypto_ops *lib80211_get_crypto_ops_dup(const char *name);
+void lib80211_crypt_delayed_deinit_dup(struct lib80211_crypt_info *info,
 				    struct lib80211_crypt_data **crypt);
 
 #endif /* LIB80211_H */
--- a/include/net/mac80211.h	2015-06-23 11:07:42.672848906 +0200
+++ b/include/net/mac80211.h	2015-06-23 16:42:02.005818485 +0200
@@ -36,7 +36,7 @@ struct inet6_dev;
 /**
  * DOC: Calling mac80211 from interrupts
  *
- * Only ieee80211_tx_status_irqsafe() and ieee80211_rx_irqsafe() can be
+ * Only ieee80211_tx_status_irqsafe_dup() and ieee80211_rx_irqsafe_dup() can be
  * called in hardware interrupt context. The low-level driver must not call any
  * other functions in hardware interrupt context. If there is a need for such
  * call, the low-level driver should first ACK the interrupt and perform the
@@ -566,7 +566,7 @@ struct ieee80211_bss_conf {
  * @IEEE80211_TX_CTL_NO_CCK_RATE: This frame will be sent at non CCK rate.
  *	This flag is actually used for management frame especially for P2P
  *	frames not being sent at CCK rate in 2GHz band.
- * @IEEE80211_TX_STATUS_EOSP: This packet marks the end of service period,
+ * @ieee80211_tx_status_EOSP: This packet marks the end of service period,
  *	when its status is reported the service period ends. For frames in
  *	an SP that mac80211 transmits, it is already set; for driver frames
  *	the driver may set this flag. It is also used to do the same for
@@ -611,7 +611,7 @@ enum mac80211_tx_info_flags {
 	IEEE80211_TX_CTL_TX_OFFCHAN		= BIT(25),
 	IEEE80211_TX_INTFL_TKIP_MIC_FAILURE	= BIT(26),
 	IEEE80211_TX_CTL_NO_CCK_RATE		= BIT(27),
-	IEEE80211_TX_STATUS_EOSP		= BIT(28),
+	ieee80211_tx_status_EOSP		= BIT(28),
 	IEEE80211_TX_CTL_USE_MINRATE		= BIT(29),
 	IEEE80211_TX_CTL_DONTFRAG		= BIT(30),
 	IEEE80211_TX_CTL_PS_RESPONSE		= BIT(31),
@@ -642,7 +642,7 @@ enum mac80211_tx_control_flags {
 	IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |	      \
 	IEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_NO_PS_BUFFER |    \
 	IEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |		      \
-	IEEE80211_TX_CTL_STBC | IEEE80211_TX_STATUS_EOSP)
+	IEEE80211_TX_CTL_STBC | ieee80211_tx_status_EOSP)
 
 /**
  * enum mac80211_rate_control_flags - per-rate flags set by the
@@ -664,7 +664,7 @@ enum mac80211_tx_control_flags {
  * @IEEE80211_TX_RC_80_MHZ_WIDTH: Indicates 80 MHz transmission
  * @IEEE80211_TX_RC_160_MHZ_WIDTH: Indicates 160 MHz transmission
  *	(80+80 isn't supported yet)
- * @IEEE80211_TX_RC_DUP_DATA: The frame should be transmitted on both of the
+ * @IEEE80211_TX_RC_DATA: The frame should be transmitted on both of the
  *	adjacent 20 MHz channels, if the current channel type is
  *	NL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.
  * @IEEE80211_TX_RC_SHORT_GI: Short Guard interval should be used for this rate.
@@ -678,7 +678,7 @@ enum mac80211_rate_control_flags {
 	IEEE80211_TX_RC_MCS			= BIT(3),
 	IEEE80211_TX_RC_GREEN_FIELD		= BIT(4),
 	IEEE80211_TX_RC_40_MHZ_WIDTH		= BIT(5),
-	IEEE80211_TX_RC_DUP_DATA		= BIT(6),
+	IEEE80211_TX_RC_DATA		= BIT(6),
 	IEEE80211_TX_RC_SHORT_GI		= BIT(7),
 	IEEE80211_TX_RC_VHT_MCS			= BIT(8),
 	IEEE80211_TX_RC_80_MHZ_WIDTH		= BIT(9),
@@ -1327,7 +1327,7 @@ static inline bool ieee80211_vif_is_mesh
 }
 
 /**
- * wdev_to_ieee80211_vif - return a vif struct from a wdev
+ * wdev_to_ieee80211_vif_dup - return a vif struct from a wdev
  * @wdev: the wdev to get the vif for
  *
  * This can be used by mac80211 drivers with direct cfg80211 APIs
@@ -1337,7 +1337,7 @@ static inline bool ieee80211_vif_is_mesh
  * associated with a vif that the driver knows about (e.g. monitor
  * or AP_VLAN interfaces.)
  */
-struct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev);
+struct ieee80211_vif *wdev_to_ieee80211_vif_dup(struct wireless_dev *wdev);
 
 /**
  * enum ieee80211_key_flags - key flags
@@ -1618,7 +1618,7 @@ struct ieee80211_tx_control {
  *	rely on the host system for such buffering. This option is used
  *	to configure the IEEE 802.11 upper layer to buffer broadcast and
  *	multicast frames when there are power saving stations so that
- *	the driver can fetch them with ieee80211_get_buffered_bc().
+ *	the driver can fetch them with ieee80211_get_buffered_bc_dup().
  *
  * @IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE:
  *	Hardware is not capable of short slot operation on the 2.4 GHz band.
@@ -1795,7 +1795,7 @@ enum ieee80211_hw_flags {
  *
  * @rate_control_algorithm: rate control algorithm for this hardware.
  *	If unset (NULL), the default algorithm will be used. Must be
- *	set before calling ieee80211_register_hw().
+ *	set before calling ieee80211_register_hw_dup().
  *
  * @vif_data_size: size (in bytes) of the drv_priv data area
  *	within &struct ieee80211_vif.
@@ -1920,7 +1920,7 @@ struct ieee80211_tdls_ch_sw_params {
 };
 
 /**
- * wiphy_to_ieee80211_hw - return a mac80211 driver hw struct from a wiphy
+ * wiphy_to_ieee80211_hw_dup - return a mac80211 driver hw struct from a wiphy
  *
  * @wiphy: the &struct wiphy which we want to query
  *
@@ -1932,7 +1932,7 @@ struct ieee80211_tdls_ch_sw_params {
  *
  * Return: The mac80211 driver hw struct of @wiphy.
  */
-struct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy);
+struct ieee80211_hw *wiphy_to_ieee80211_hw_dup(struct wiphy *wiphy);
 
 /**
  * SET_IEEE80211_DEV - set device for 802.11 hardware
@@ -1984,14 +1984,14 @@ ieee80211_get_alt_retry_rate(const struc
 }
 
 /**
- * ieee80211_free_txskb - free TX skb
+ * ieee80211_free_txskb_dup - free TX skb
  * @hw: the hardware
  * @skb: the skb
  *
  * Free a transmit skb. Use this funtion when some failure
  * to transmit happened and thus status cannot be reported.
  */
-void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
+void ieee80211_free_txskb_dup(struct ieee80211_hw *hw, struct sk_buff *skb);
 
 /**
  * DOC: Hardware crypto acceleration
@@ -2119,11 +2119,11 @@ void ieee80211_free_txskb(struct ieee802
  * interface capability. The driver needs to enable beacon filter support
  * whenever power save is enabled, that is %IEEE80211_CONF_PS is set. When
  * power save is enabled, the stack will not check for beacon loss and the
- * driver needs to notify about loss of beacons with ieee80211_beacon_loss().
+ * driver needs to notify about loss of beacons with ieee80211_beacon_loss_dup().
  *
  * The time (or number of beacons missed) until the firmware notifies the
  * driver of a beacon loss event (which in turn causes the driver to call
- * ieee80211_beacon_loss()) should be configurable and will be controlled
+ * ieee80211_beacon_loss_dup()) should be configurable and will be controlled
  * by mac80211 and the roaming algorithm in the future.
  *
  * Since there may be constantly changing information elements that nothing
@@ -2246,7 +2246,7 @@ void ieee80211_free_txskb(struct ieee802
  * driver implementation: %IEEE80211_HW_AP_LINK_PS. If this flag is set,
  * mac80211 expects the driver to handle most of the state machine for
  * powersaving clients and will ignore the PM bit in incoming frames.
- * Drivers then use ieee80211_sta_ps_transition() to inform mac80211 of
+ * Drivers then use ieee80211_sta_ps_transition_dup() to inform mac80211 of
  * stations' powersave transitions. In this mode, mac80211 also doesn't
  * handle PS-Poll/uAPSD.
  *
@@ -2270,7 +2270,7 @@ void ieee80211_free_txskb(struct ieee802
  * callback; this callback is optional. mac80211 will then transmit
  * the frames as usual and set the %IEEE80211_TX_CTL_NO_PS_BUFFER
  * on each frame. The last frame in the service period (or the only
- * response to a PS-Poll) also has %IEEE80211_TX_STATUS_EOSP set to
+ * response to a PS-Poll) also has %ieee80211_tx_status_EOSP set to
  * indicate that it ends the service period; as this frame must have
  * TX status report it also sets %IEEE80211_TX_CTL_REQ_TX_STATUS.
  * When TX status is reported for this frame, the service period is
@@ -2286,13 +2286,13 @@ void ieee80211_free_txskb(struct ieee802
  * processing of the EOSP. The cause is that allowing frames to be
  * transmitted to a certain station is out-of-band communication to
  * the device. To allow this problem to be solved, the driver can
- * call ieee80211_sta_block_awake() if frames are buffered when it
+ * call ieee80211_sta_block_awake_dup() if frames are buffered when it
  * is notified that the station went to sleep. When all these frames
  * have been filtered (see above), it must call the function again
  * to indicate that the station is no longer blocked.
  *
  * If the driver buffers frames in the driver for aggregation in any
- * way, it must use the ieee80211_sta_set_buffered() call when it is
+ * way, it must use the ieee80211_sta_set_buffered_dup() call when it is
  * notified of the station going to sleep to inform mac80211 of any
  * TIDs that have frames buffered. Note that when a station wakes up
  * this information is reset (hence the requirement to call it when
@@ -2311,14 +2311,14 @@ void ieee80211_free_txskb(struct ieee802
  * filter those response frames except in the case of frames that
  * are buffered in the driver -- those must remain buffered to avoid
  * reordering. Because it is possible that no frames are released
- * in this case, the driver must call ieee80211_sta_eosp()
+ * in this case, the driver must call ieee80211_sta_eosp_dup()
  * to indicate to mac80211 that the service period ended anyway.
  *
  * Finally, if frames from multiple TIDs are released from mac80211
  * but the driver might reorder them, it must clear & set the flags
- * appropriately (only the last frame may have %IEEE80211_TX_STATUS_EOSP)
+ * appropriately (only the last frame may have %ieee80211_tx_status_EOSP)
  * and also take care of the EOSP and MORE_DATA bits in the frame.
- * The driver may also use ieee80211_sta_eosp() in this case.
+ * The driver may also use ieee80211_sta_eosp_dup() in this case.
  *
  * Note that if the driver ever buffers frames other than QoS-data
  * frames, it must take care to never send a non-QoS-data frame as
@@ -2348,7 +2348,7 @@ void ieee80211_free_txskb(struct ieee802
  * if necessary will queue the frame on the right software queue that mirrors
  * the hardware queue.
  * Additionally, the driver has to then use these HW queue IDs for the queue
- * management functions (ieee80211_stop_queue() et al.)
+ * management functions (ieee80211_stop_queue_dup() et al.)
  *
  * The driver is free to set up the queue mappings as needed, multiple virtual
  * interfaces may map to the same hardware queues if needed. The setup has to
@@ -2439,7 +2439,7 @@ enum ieee80211_filter_flags {
  *
  * Note that drivers MUST be able to deal with a TX aggregation
  * session being stopped even before they OK'ed starting it by
- * calling ieee80211_start_tx_ba_cb_irqsafe, because the peer
+ * calling ieee80211_start_tx_ba_cb_irqsafe_dup, because the peer
  * might receive the addBA frame and send a delBA right away!
  *
  * @IEEE80211_AMPDU_RX_START: start RX aggregation
@@ -2448,13 +2448,13 @@ enum ieee80211_filter_flags {
  * @IEEE80211_AMPDU_TX_OPERATIONAL: TX aggregation has become operational
  * @IEEE80211_AMPDU_TX_STOP_CONT: stop TX aggregation but continue transmitting
  *	queued packets, now unaggregated. After all packets are transmitted the
- *	driver has to call ieee80211_stop_tx_ba_cb_irqsafe().
+ *	driver has to call ieee80211_stop_tx_ba_cb_irqsafe_dup().
  * @IEEE80211_AMPDU_TX_STOP_FLUSH: stop TX aggregation and flush all packets,
  *	called when the station is removed. There's no need or reason to call
- *	ieee80211_stop_tx_ba_cb_irqsafe() in this case as mac80211 assumes the
+ *	ieee80211_stop_tx_ba_cb_irqsafe_dup() in this case as mac80211 assumes the
  *	session is gone and removes the station.
  * @IEEE80211_AMPDU_TX_STOP_FLUSH_CONT: called when TX aggregation is stopped
- *	but the driver hasn't called ieee80211_stop_tx_ba_cb_irqsafe() yet and
+ *	but the driver hasn't called ieee80211_stop_tx_ba_cb_irqsafe_dup() yet and
  *	now the connection is dropped and the station will be removed. Drivers
  *	should clean up and drop remaining packets when this is called.
  */
@@ -2652,7 +2652,7 @@ enum ieee80211_reconfig_type {
  *	host is suspended, it can assign this callback to retrieve the data
  *	necessary to do GTK rekeying, this is the KEK, KCK and replay counter.
  *	After rekeying was done it should (for example during resume) notify
- *	userspace of the new replay counter using ieee80211_gtk_rekey_notify().
+ *	userspace of the new replay counter using ieee80211_gtk_rekey_notify_dup().
  *
  * @set_default_unicast_key: Set the default (unicast) key index, useful for
  *	WEP when the device sends data packets autonomously, e.g. for ARP
@@ -2667,7 +2667,7 @@ enum ieee80211_reconfig_type {
  *	entire IEs after the SSID, so that drivers need not look at these
  *	at all but just send them after the SSID -- mac80211 includes the
  *	(extended) supported rates and HT information (where applicable).
- *	When the scan finishes, ieee80211_scan_completed() must be called;
+ *	When the scan finishes, ieee80211_scan_completed_dup() must be called;
  *	note that it also must be called when the scan cannot finish due to
  *	any error unless this callback returned a negative error code.
  *	The callback can sleep.
@@ -2675,18 +2675,18 @@ enum ieee80211_reconfig_type {
  * @cancel_hw_scan: Ask the low-level tp cancel the active hw scan.
  *	The driver should ask the hardware to cancel the scan (if possible),
  *	but the scan will be completed only after the driver will call
- *	ieee80211_scan_completed().
+ *	ieee80211_scan_completed_dup().
  *	This callback is needed for wowlan, to prevent enqueueing a new
  *	scan_work after the low-level driver was already suspended.
  *	The callback can sleep.
  *
  * @sched_scan_start: Ask the hardware to start scanning repeatedly at
  *	specific intervals.  The driver must call the
- *	ieee80211_sched_scan_results() function whenever it finds results.
+ *	ieee80211_sched_scan_results_dup() function whenever it finds results.
  *	This process will continue until sched_scan_stop is called.
  *
  * @sched_scan_stop: Tell the hardware to stop an ongoing scheduled scan.
- *	In this case, ieee80211_sched_scan_stopped() must not be called.
+ *	In this case, ieee80211_sched_scan_stopped_dup() must not be called.
  *
  * @sw_scan_start: Notifier function that is called just before a software scan
  *	is started. Can be NULL, if the driver doesn't need this notification.
@@ -2822,7 +2822,7 @@ enum ieee80211_reconfig_type {
  *
  * @rfkill_poll: Poll rfkill hardware state. If you need this, you also
  *	need to set wiphy->rfkill_poll to %true before registration,
- *	and need to call wiphy_rfkill_set_hw_state() in the callback.
+ *	and need to call wiphy_rfkill_set_hw_state_dup() in the callback.
  *	The callback can sleep.
  *
  * @set_coverage_class: Set slot time for given coverage class as specified
@@ -2845,7 +2845,7 @@ enum ieee80211_reconfig_type {
  *
  * @channel_switch: Drivers that need (or want) to offload the channel
  *	switch operation for CSAs received from the AP may implement this
- *	callback. They must then call ieee80211_chswitch_done() to indicate
+ *	callback. They must then call ieee80211_chswitch_done_dup() to indicate
  *	completion of the channel switch.
  *
  * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.
@@ -2856,12 +2856,12 @@ enum ieee80211_reconfig_type {
  * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).
  *
  * @remain_on_channel: Starts an off-channel period on the given channel, must
- *	call back to ieee80211_ready_on_channel() when on that channel. Note
+ *	call back to ieee80211_ready_on_channel_dup() when on that channel. Note
  *	that normal channel traffic is not stopped as this is intended for hw
  *	offload. Frames to transmit on the off-channel channel are transmitted
  *	normally except for the %IEEE80211_TX_CTL_TX_OFFCHAN flag. When the
  *	duration (which will always be non-zero) expires, the driver must call
- *	ieee80211_remain_on_channel_expired().
+ *	ieee80211_remain_on_channel_expired_dup().
  *	Note that this callback may be called while the device is in IDLE and
  *	must be accepted in this case.
  *	This callback may sleep.
@@ -2895,7 +2895,7 @@ enum ieee80211_reconfig_type {
  *	from, for PS-poll it will always have only a single bit set.
  *	In the case this is used for a PS-poll initiated release, the
  *	@num_frames parameter will always be 1 so code can be shared. In
- *	this case the driver must also set %IEEE80211_TX_STATUS_EOSP flag
+ *	this case the driver must also set %ieee80211_tx_status_EOSP flag
  *	on the TX status (and must report TX status) so that the PS-poll
  *	period is properly ended. This is used to avoid sending multiple
  *	responses for a retried PS-poll frame.
@@ -2903,20 +2903,20 @@ enum ieee80211_reconfig_type {
  *	bigger than one, but the driver may send fewer frames (it must send
  *	at least one, however). In this case it is also responsible for
  *	setting the EOSP flag in the QoS header of the frames. Also, when the
- *	service period ends, the driver must set %IEEE80211_TX_STATUS_EOSP
+ *	service period ends, the driver must set %ieee80211_tx_status_EOSP
  *	on the last frame in the SP. Alternatively, it may call the function
- *	ieee80211_sta_eosp() to inform mac80211 of the end of the SP.
+ *	ieee80211_sta_eosp_dup() to inform mac80211 of the end of the SP.
  *	This callback must be atomic.
  * @allow_buffered_frames: Prepare device to allow the given number of frames
  *	to go out to the given station. The frames will be sent by mac80211
  *	via the usual TX path after this call. The TX information for frames
  *	released will also have the %IEEE80211_TX_CTL_NO_PS_BUFFER flag set
- *	and the last one will also have %IEEE80211_TX_STATUS_EOSP set. In case
+ *	and the last one will also have %ieee80211_tx_status_EOSP set. In case
  *	frames from multiple TIDs are released and the driver might reorder
- *	them between the TIDs, it must set the %IEEE80211_TX_STATUS_EOSP flag
+ *	them between the TIDs, it must set the %ieee80211_tx_status_EOSP flag
  *	on the last frame and clear it on all others and also handle the EOSP
  *	bit in the QoS header correctly. Alternatively, it can also call the
- *	ieee80211_sta_eosp() function.
+ *	ieee80211_sta_eosp_dup() function.
  *	The @tids parameter is a bitmap and tells the driver which TIDs the
  *	frames will be on; it will at most have two bits set.
  *	This callback must be atomic.
@@ -2975,7 +2975,7 @@ enum ieee80211_reconfig_type {
  *	disabled/enabled via @bss_info_changed.
  * @stop_ap: Stop operation on the AP interface.
  *
- * @reconfig_complete: Called after a call to ieee80211_restart_hw() and
+ * @reconfig_complete: Called after a call to ieee80211_restart_hw_dup() and
  *	during resume, when the reconfiguration has completed.
  *	This can help the driver implement the reconfiguration step (and
  *	indicate mac80211 is ready to receive frames).
@@ -2989,10 +2989,10 @@ enum ieee80211_reconfig_type {
  *	Beacons are modified to include CSA or ECSA IEs before calling this
  *	function. The corresponding count fields in these IEs must be
  *	decremented, and when they reach 1 the driver must call
- *	ieee80211_csa_finish(). Drivers which use ieee80211_beacon_get()
+ *	ieee80211_csa_finish_dup(). Drivers which use ieee80211_beacon_get()
  *	get the csa counter decremented by mac80211, but must check if it is
- *	1 using ieee80211_csa_is_complete() after the beacon has been
- *	transmitted and then call ieee80211_csa_finish().
+ *	1 using ieee80211_csa_is_complete_dup() after the beacon has been
+ *	transmitted and then call ieee80211_csa_finish_dup().
  *	If the CSA count starts as zero or 1, this function will not be called,
  *	since there won't be any time to beacon before the switch anyway.
  * @pre_channel_switch: This is an optional callback that is called
@@ -3267,7 +3267,7 @@ struct ieee80211_ops {
 };
 
 /**
- * ieee80211_alloc_hw_nm - Allocate a new hardware device
+ * ieee80211_alloc_hw_nm_dup - Allocate a new hardware device
  *
  * This must be called once for each hardware device. The returned pointer
  * must be used to refer to this device when calling other functions.
@@ -3282,7 +3282,7 @@ struct ieee80211_ops {
  *
  * Return: A pointer to the new hardware device, or %NULL on error.
  */
-struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
+struct ieee80211_hw *ieee80211_alloc_hw_nm_dup(size_t priv_data_len,
 					   const struct ieee80211_ops *ops,
 					   const char *requested_name);
 
@@ -3304,11 +3304,11 @@ static inline
 struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,
 					const struct ieee80211_ops *ops)
 {
-	return ieee80211_alloc_hw_nm(priv_data_len, ops, NULL);
+	return ieee80211_alloc_hw_nm_dup(priv_data_len, ops, NULL);
 }
 
 /**
- * ieee80211_register_hw - Register hardware device
+ * ieee80211_register_hw_dup - Register hardware device
  *
  * You must call this function before any other functions in
  * mac80211. Note that before a hardware can be registered, you
@@ -3318,7 +3318,7 @@ struct ieee80211_hw *ieee80211_alloc_hw(
  *
  * Return: 0 on success. An error code otherwise.
  */
-int ieee80211_register_hw(struct ieee80211_hw *hw);
+int ieee80211_register_hw_dup(struct ieee80211_hw *hw);
 
 /**
  * struct ieee80211_tpt_blink - throughput blink description
@@ -3345,11 +3345,11 @@ enum ieee80211_tpt_led_trigger_flags {
 };
 
 #ifdef CONFIG_MAC80211_LEDS
-char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);
-char *__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,
+char *__ieee80211_get_tx_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_get_rx_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_get_assoc_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_get_radio_led_name_dup(struct ieee80211_hw *hw);
+char *__ieee80211_create_tpt_led_trigger_dup(struct ieee80211_hw *hw,
 					 unsigned int flags,
 					 const struct ieee80211_tpt_blink *blink_table,
 					 unsigned int blink_table_len);
@@ -3369,7 +3369,7 @@ char *__ieee80211_create_tpt_led_trigger
 static inline char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_tx_led_name(hw);
+	return __ieee80211_get_tx_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3390,7 +3390,7 @@ static inline char *ieee80211_get_tx_led
 static inline char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_rx_led_name(hw);
+	return __ieee80211_get_rx_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3411,7 +3411,7 @@ static inline char *ieee80211_get_rx_led
 static inline char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_assoc_led_name(hw);
+	return __ieee80211_get_assoc_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3432,7 +3432,7 @@ static inline char *ieee80211_get_assoc_
 static inline char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_get_radio_led_name(hw);
+	return __ieee80211_get_radio_led_name_dup(hw);
 #else
 	return NULL;
 #endif
@@ -3448,7 +3448,7 @@ static inline char *ieee80211_get_radio_
  * Return: %NULL (in case of error, or if no LED triggers are
  * configured) or the name of the new trigger.
  *
- * Note: This function must be called before ieee80211_register_hw().
+ * Note: This function must be called before ieee80211_register_hw_dup().
  */
 static inline char *
 ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,
@@ -3456,7 +3456,7 @@ ieee80211_create_tpt_led_trigger(struct
 				 unsigned int blink_table_len)
 {
 #ifdef CONFIG_MAC80211_LEDS
-	return __ieee80211_create_tpt_led_trigger(hw, flags, blink_table,
+	return __ieee80211_create_tpt_led_trigger_dup(hw, flags, blink_table,
 						  blink_table_len);
 #else
 	return NULL;
@@ -3464,28 +3464,28 @@ ieee80211_create_tpt_led_trigger(struct
 }
 
 /**
- * ieee80211_unregister_hw - Unregister a hardware device
+ * ieee80211_unregister_hw_dup - Unregister a hardware device
  *
  * This function instructs mac80211 to free allocated resources
  * and unregister netdevices from the networking subsystem.
  *
  * @hw: the hardware to unregister
  */
-void ieee80211_unregister_hw(struct ieee80211_hw *hw);
+void ieee80211_unregister_hw_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_free_hw - free hardware descriptor
+ * ieee80211_free_hw_dup - free hardware descriptor
  *
  * This function frees everything that was allocated, including the
- * private data for the driver. You must call ieee80211_unregister_hw()
+ * private data for the driver. You must call ieee80211_unregister_hw_dup()
  * before calling this function.
  *
  * @hw: the hardware to free
  */
-void ieee80211_free_hw(struct ieee80211_hw *hw);
+void ieee80211_free_hw_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_restart_hw - restart hardware completely
+ * ieee80211_restart_hw_dup - restart hardware completely
  *
  * Call this function when the hardware was restarted for some reason
  * (hardware error, ...) and the driver is unable to restore its state
@@ -3496,10 +3496,10 @@ void ieee80211_free_hw(struct ieee80211_
  *
  * @hw: the hardware to restart
  */
-void ieee80211_restart_hw(struct ieee80211_hw *hw);
+void ieee80211_restart_hw_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_napi_add - initialize mac80211 NAPI context
+ * ieee80211_napi_add_dup - initialize mac80211 NAPI context
  * @hw: the hardware to initialize the NAPI context on
  * @napi: the NAPI context to initialize
  * @napi_dev: dummy NAPI netdevice, here to not waste the space if the
@@ -3509,13 +3509,13 @@ void ieee80211_restart_hw(struct ieee802
  *
  * See also netif_napi_add().
  */
-void ieee80211_napi_add(struct ieee80211_hw *hw, struct napi_struct *napi,
+void ieee80211_napi_add_dup(struct ieee80211_hw *hw, struct napi_struct *napi,
 			struct net_device *napi_dev,
 			int (*poll)(struct napi_struct *, int),
 			int weight);
 
 /**
- * ieee80211_rx - receive frame
+ * ieee80211_rx_dup - receive frame
  *
  * Use this function to hand received frames to mac80211. The receive
  * buffer in @skb must start with an IEEE 802.11 header. In case of a
@@ -3525,41 +3525,41 @@ void ieee80211_napi_add(struct ieee80211
  *
  * This function may not be called in IRQ context. Calls to this function
  * for a single hardware must be synchronized against each other. Calls to
- * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be
+ * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe_dup() may not be
  * mixed for a single hardware. Must not run concurrently with
- * ieee80211_tx_status() or ieee80211_tx_status_ni().
+ * ieee80211_tx_status_dup() or ieee80211_tx_status_ni().
  *
  * In process context use instead ieee80211_rx_ni().
  *
  * @hw: the hardware this frame came in on
  * @skb: the buffer to receive, owned by mac80211 after this call
  */
-void ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb);
+void ieee80211_rx_dup(struct ieee80211_hw *hw, struct sk_buff *skb);
 
 /**
- * ieee80211_rx_irqsafe - receive frame
+ * ieee80211_rx_irqsafe_dup - receive frame
  *
- * Like ieee80211_rx() but can be called in IRQ context
+ * Like ieee80211_rx_dup() but can be called in IRQ context
  * (internally defers to a tasklet.)
  *
- * Calls to this function, ieee80211_rx() or ieee80211_rx_ni() may not
+ * Calls to this function, ieee80211_rx_dup() or ieee80211_rx_ni() may not
  * be mixed for a single hardware.Must not run concurrently with
- * ieee80211_tx_status() or ieee80211_tx_status_ni().
+ * ieee80211_tx_status_dup() or ieee80211_tx_status_ni().
  *
  * @hw: the hardware this frame came in on
  * @skb: the buffer to receive, owned by mac80211 after this call
  */
-void ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb);
+void ieee80211_rx_irqsafe_dup(struct ieee80211_hw *hw, struct sk_buff *skb);
 
 /**
  * ieee80211_rx_ni - receive frame (in process context)
  *
- * Like ieee80211_rx() but can be called in process context
+ * Like ieee80211_rx_dup() but can be called in process context
  * (internally disables bottom halves).
  *
- * Calls to this function, ieee80211_rx() and ieee80211_rx_irqsafe() may
+ * Calls to this function, ieee80211_rx_dup() and ieee80211_rx_irqsafe_dup() may
  * not be mixed for a single hardware. Must not run concurrently with
- * ieee80211_tx_status() or ieee80211_tx_status_ni().
+ * ieee80211_tx_status_dup() or ieee80211_tx_status_ni().
  *
  * @hw: the hardware this frame came in on
  * @skb: the buffer to receive, owned by mac80211 after this call
@@ -3568,12 +3568,12 @@ static inline void ieee80211_rx_ni(struc
 				   struct sk_buff *skb)
 {
 	local_bh_disable();
-	ieee80211_rx(hw, skb);
+	ieee80211_rx_dup(hw, skb);
 	local_bh_enable();
 }
 
 /**
- * ieee80211_sta_ps_transition - PS transition for connected sta
+ * ieee80211_sta_ps_transition_dup - PS transition for connected sta
  *
  * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS
  * flag set, use this function to inform mac80211 about a connected station
@@ -3589,20 +3589,20 @@ static inline void ieee80211_rx_ni(struc
  *
  * Return: 0 on success. -EINVAL when the requested PS mode is already set.
  */
-int ieee80211_sta_ps_transition(struct ieee80211_sta *sta, bool start);
+int ieee80211_sta_ps_transition_dup(struct ieee80211_sta *sta, bool start);
 
 /**
  * ieee80211_sta_ps_transition_ni - PS transition for connected sta
  *                                  (in process context)
  *
- * Like ieee80211_sta_ps_transition() but can be called in process context
+ * Like ieee80211_sta_ps_transition_dup() but can be called in process context
  * (internally disables bottom halves). Concurrent call restriction still
  * applies.
  *
  * @sta: currently connected sta
  * @start: start or stop PS
  *
- * Return: Like ieee80211_sta_ps_transition().
+ * Return: Like ieee80211_sta_ps_transition_dup().
  */
 static inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,
 						  bool start)
@@ -3610,7 +3610,7 @@ static inline int ieee80211_sta_ps_trans
 	int ret;
 
 	local_bh_disable();
-	ret = ieee80211_sta_ps_transition(sta, start);
+	ret = ieee80211_sta_ps_transition_dup(sta, start);
 	local_bh_enable();
 
 	return ret;
@@ -3620,10 +3620,10 @@ static inline int ieee80211_sta_ps_trans
  * The TX headroom reserved by mac80211 for its own tx_status functions.
  * This is enough for the radiotap header.
  */
-#define IEEE80211_TX_STATUS_HEADROOM	14
+#define ieee80211_tx_status_HEADROOM	14
 
 /**
- * ieee80211_sta_set_buffered - inform mac80211 about driver-buffered frames
+ * ieee80211_sta_set_buffered_dup - inform mac80211 about driver-buffered frames
  * @sta: &struct ieee80211_sta pointer for the sleeping station
  * @tid: the TID that has buffered frames
  * @buffered: indicates whether or not frames are buffered for this TID
@@ -3650,11 +3650,11 @@ static inline int ieee80211_sta_ps_trans
  * TID to the AC as required instead of keeping track in all drivers that
  * use this API.
  */
-void ieee80211_sta_set_buffered(struct ieee80211_sta *sta,
+void ieee80211_sta_set_buffered_dup(struct ieee80211_sta *sta,
 				u8 tid, bool buffered);
 
 /**
- * ieee80211_get_tx_rates - get the selected transmit rates for a packet
+ * ieee80211_get_tx_rates_dup - get the selected transmit rates for a packet
  *
  * Call this function in a driver with per-packet rate selection support
  * to combine the rate info in the packet tx info with the most recent
@@ -3666,14 +3666,14 @@ void ieee80211_sta_set_buffered(struct i
  * @dest: buffer for extracted rate/retry information
  * @max_rates: maximum number of rates to fetch
  */
-void ieee80211_get_tx_rates(struct ieee80211_vif *vif,
+void ieee80211_get_tx_rates_dup(struct ieee80211_vif *vif,
 			    struct ieee80211_sta *sta,
 			    struct sk_buff *skb,
 			    struct ieee80211_tx_rate *dest,
 			    int max_rates);
 
 /**
- * ieee80211_tx_status - transmit status callback
+ * ieee80211_tx_status_dup - transmit status callback
  *
  * Call this function for all transmitted frames after they have been
  * transmitted. It is permissible to not call this function for
@@ -3681,43 +3681,43 @@ void ieee80211_get_tx_rates(struct ieee8
  *
  * This function may not be called in IRQ context. Calls to this function
  * for a single hardware must be synchronized against each other. Calls
- * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe()
+ * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe_dup()
  * may not be mixed for a single hardware. Must not run concurrently with
- * ieee80211_rx() or ieee80211_rx_ni().
+ * ieee80211_rx_dup() or ieee80211_rx_ni().
  *
  * @hw: the hardware the frame was transmitted by
  * @skb: the frame that was transmitted, owned by mac80211 after this call
  */
-void ieee80211_tx_status(struct ieee80211_hw *hw,
+void ieee80211_tx_status_dup(struct ieee80211_hw *hw,
 			 struct sk_buff *skb);
 
 /**
- * ieee80211_tx_status_noskb - transmit status callback without skb
+ * ieee80211_tx_status_noskb_dup - transmit status callback without skb
  *
- * This function can be used as a replacement for ieee80211_tx_status
+ * This function can be used as a replacement for ieee80211_tx_status_dup
  * in drivers that cannot reliably map tx status information back to
  * specific skbs.
  *
  * Calls to this function for a single hardware must be synchronized
  * against each other. Calls to this function, ieee80211_tx_status_ni()
- * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.
+ * and ieee80211_tx_status_irqsafe_dup() may not be mixed for a single hardware.
  *
  * @hw: the hardware the frame was transmitted by
  * @sta: the receiver station to which this packet is sent
  *	(NULL for multicast packets)
  * @info: tx status information
  */
-void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,
+void ieee80211_tx_status_noskb_dup(struct ieee80211_hw *hw,
 			       struct ieee80211_sta *sta,
 			       struct ieee80211_tx_info *info);
 
 /**
  * ieee80211_tx_status_ni - transmit status callback (in process context)
  *
- * Like ieee80211_tx_status() but can be called in process context.
+ * Like ieee80211_tx_status_dup() but can be called in process context.
  *
- * Calls to this function, ieee80211_tx_status() and
- * ieee80211_tx_status_irqsafe() may not be mixed
+ * Calls to this function, ieee80211_tx_status_dup() and
+ * ieee80211_tx_status_irqsafe_dup() may not be mixed
  * for a single hardware.
  *
  * @hw: the hardware the frame was transmitted by
@@ -3727,27 +3727,27 @@ static inline void ieee80211_tx_status_n
 					  struct sk_buff *skb)
 {
 	local_bh_disable();
-	ieee80211_tx_status(hw, skb);
+	ieee80211_tx_status_dup(hw, skb);
 	local_bh_enable();
 }
 
 /**
- * ieee80211_tx_status_irqsafe - IRQ-safe transmit status callback
+ * ieee80211_tx_status_irqsafe_dup - IRQ-safe transmit status callback
  *
- * Like ieee80211_tx_status() but can be called in IRQ context
+ * Like ieee80211_tx_status_dup() but can be called in IRQ context
  * (internally defers to a tasklet.)
  *
- * Calls to this function, ieee80211_tx_status() and
+ * Calls to this function, ieee80211_tx_status_dup() and
  * ieee80211_tx_status_ni() may not be mixed for a single hardware.
  *
  * @hw: the hardware the frame was transmitted by
  * @skb: the frame that was transmitted, owned by mac80211 after this call
  */
-void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,
+void ieee80211_tx_status_irqsafe_dup(struct ieee80211_hw *hw,
 				 struct sk_buff *skb);
 
 /**
- * ieee80211_report_low_ack - report non-responding station
+ * ieee80211_report_low_ack_dup - report non-responding station
  *
  * When operating in AP-mode, call this function to report a non-responding
  * connected STA.
@@ -3755,7 +3755,7 @@ void ieee80211_tx_status_irqsafe(struct
  * @sta: the non-responding connected sta
  * @num_packets: number of packets sent to @sta without a response
  */
-void ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);
+void ieee80211_report_low_ack_dup(struct ieee80211_sta *sta, u32 num_packets);
 
 #define IEEE80211_MAX_CSA_COUNTERS_NUM 2
 
@@ -3775,7 +3775,7 @@ struct ieee80211_mutable_offsets {
 };
 
 /**
- * ieee80211_beacon_get_template - beacon template generation function
+ * ieee80211_beacon_get_template_dup - beacon template generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @offs: &struct ieee80211_mutable_offsets pointer to struct that will
@@ -3794,12 +3794,12 @@ struct ieee80211_mutable_offsets {
  * Return: The beacon template. %NULL on error.
  */
 struct sk_buff *
-ieee80211_beacon_get_template(struct ieee80211_hw *hw,
+ieee80211_beacon_get_template_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif,
 			      struct ieee80211_mutable_offsets *offs);
 
 /**
- * ieee80211_beacon_get_tim - beacon generation function
+ * ieee80211_beacon_get_tim_dup - beacon generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @tim_offset: pointer to variable that will receive the TIM IE offset.
@@ -3820,7 +3820,7 @@ ieee80211_beacon_get_template(struct iee
  *
  * Return: The beacon template. %NULL on error.
  */
-struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_beacon_get_tim_dup(struct ieee80211_hw *hw,
 					 struct ieee80211_vif *vif,
 					 u16 *tim_offset, u16 *tim_length);
 
@@ -3829,47 +3829,47 @@ struct sk_buff *ieee80211_beacon_get_tim
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
- * See ieee80211_beacon_get_tim().
+ * See ieee80211_beacon_get_tim_dup().
  *
- * Return: See ieee80211_beacon_get_tim().
+ * Return: See ieee80211_beacon_get_tim_dup().
  */
 static inline struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw,
 						   struct ieee80211_vif *vif)
 {
-	return ieee80211_beacon_get_tim(hw, vif, NULL, NULL);
+	return ieee80211_beacon_get_tim_dup(hw, vif, NULL, NULL);
 }
 
 /**
- * ieee80211_csa_update_counter - request mac80211 to decrement the csa counter
+ * ieee80211_csa_update_counter_dup - request mac80211 to decrement the csa counter
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
  * The csa counter should be updated after each beacon transmission.
  * This function is called implicitly when
- * ieee80211_beacon_get/ieee80211_beacon_get_tim are called, however if the
+ * ieee80211_beacon_get/ieee80211_beacon_get_tim_dup are called, however if the
  * beacon frames are generated by the device, the driver should call this
  * function after each beacon transmission to sync mac80211's csa counters.
  *
  * Return: new csa counter value
  */
-u8 ieee80211_csa_update_counter(struct ieee80211_vif *vif);
+u8 ieee80211_csa_update_counter_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_csa_finish - notify mac80211 about channel switch
+ * ieee80211_csa_finish_dup - notify mac80211 about channel switch
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
  * After a channel switch announcement was scheduled and the counter in this
  * announcement hits 1, this function must be called by the driver to
  * notify mac80211 that the channel can be changed.
  */
-void ieee80211_csa_finish(struct ieee80211_vif *vif);
+void ieee80211_csa_finish_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_csa_is_complete - find out if counters reached 1
+ * ieee80211_csa_is_complete_dup - find out if counters reached 1
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
  * This function returns whether the channel switch counters reached zero.
  */
-bool ieee80211_csa_is_complete(struct ieee80211_vif *vif);
+bool ieee80211_csa_is_complete_dup(struct ieee80211_vif *vif);
 
 
 /**
@@ -3888,7 +3888,7 @@ struct sk_buff *ieee80211_proberesp_get(
 					struct ieee80211_vif *vif);
 
 /**
- * ieee80211_pspoll_get - retrieve a PS Poll template
+ * ieee80211_pspoll_get_dup - retrieve a PS Poll template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -3901,11 +3901,11 @@ struct sk_buff *ieee80211_proberesp_get(
  *
  * Return: The PS Poll template. %NULL on error.
  */
-struct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_pspoll_get_dup(struct ieee80211_hw *hw,
 				     struct ieee80211_vif *vif);
 
 /**
- * ieee80211_nullfunc_get - retrieve a nullfunc template
+ * ieee80211_nullfunc_get_dup - retrieve a nullfunc template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -3918,11 +3918,11 @@ struct sk_buff *ieee80211_pspoll_get(str
  *
  * Return: The nullfunc template. %NULL on error.
  */
-struct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_nullfunc_get_dup(struct ieee80211_hw *hw,
 				       struct ieee80211_vif *vif);
 
 /**
- * ieee80211_probereq_get - retrieve a Probe Request template
+ * ieee80211_probereq_get_dup - retrieve a Probe Request template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @src_addr: source MAC address
  * @ssid: SSID buffer
@@ -3934,13 +3934,13 @@ struct sk_buff *ieee80211_nullfunc_get(s
  *
  * Return: The Probe Request template. %NULL on error.
  */
-struct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_probereq_get_dup(struct ieee80211_hw *hw,
 				       const u8 *src_addr,
 				       const u8 *ssid, size_t ssid_len,
 				       size_t tailroom);
 
 /**
- * ieee80211_rts_get - RTS frame generation function
+ * ieee80211_rts_get_dup - RTS frame generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame: pointer to the frame that is going to be protected by the RTS.
@@ -3953,13 +3953,13 @@ struct sk_buff *ieee80211_probereq_get(s
  * the next RTS frame from the 802.11 code. The low-level is responsible
  * for calling this function before and RTS frame is needed.
  */
-void ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+void ieee80211_rts_get_dup(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		       const void *frame, size_t frame_len,
 		       const struct ieee80211_tx_info *frame_txctl,
 		       struct ieee80211_rts *rts);
 
 /**
- * ieee80211_rts_duration - Get the duration field for an RTS frame
+ * ieee80211_rts_duration_dup - Get the duration field for an RTS frame
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame_len: the length of the frame that is going to be protected by the RTS.
@@ -3971,12 +3971,12 @@ void ieee80211_rts_get(struct ieee80211_
  *
  * Return: The duration.
  */
-__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_rts_duration_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif, size_t frame_len,
 			      const struct ieee80211_tx_info *frame_txctl);
 
 /**
- * ieee80211_ctstoself_get - CTS-to-self frame generation function
+ * ieee80211_ctstoself_get_dup - CTS-to-self frame generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame: pointer to the frame that is going to be protected by the CTS-to-self.
@@ -3989,14 +3989,14 @@ __le16 ieee80211_rts_duration(struct iee
  * the next CTS-to-self frame from the 802.11 code. The low-level is responsible
  * for calling this function before and CTS-to-self frame is needed.
  */
-void ieee80211_ctstoself_get(struct ieee80211_hw *hw,
+void ieee80211_ctstoself_get_dup(struct ieee80211_hw *hw,
 			     struct ieee80211_vif *vif,
 			     const void *frame, size_t frame_len,
 			     const struct ieee80211_tx_info *frame_txctl,
 			     struct ieee80211_cts *cts);
 
 /**
- * ieee80211_ctstoself_duration - Get the duration field for a CTS-to-self frame
+ * ieee80211_ctstoself_duration_dup - Get the duration field for a CTS-to-self frame
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @frame_len: the length of the frame that is going to be protected by the CTS-to-self.
@@ -4008,13 +4008,13 @@ void ieee80211_ctstoself_get(struct ieee
  *
  * Return: The duration.
  */
-__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_ctstoself_duration_dup(struct ieee80211_hw *hw,
 				    struct ieee80211_vif *vif,
 				    size_t frame_len,
 				    const struct ieee80211_tx_info *frame_txctl);
 
 /**
- * ieee80211_generic_frame_duration - Calculate the duration field for a frame
+ * ieee80211_generic_frame_duration_dup - Calculate the duration field for a frame
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @band: the band to calculate the frame duration on
@@ -4026,14 +4026,14 @@ __le16 ieee80211_ctstoself_duration(stru
  *
  * Return: The duration.
  */
-__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,
+__le16 ieee80211_generic_frame_duration_dup(struct ieee80211_hw *hw,
 					struct ieee80211_vif *vif,
 					enum ieee80211_band band,
 					size_t frame_len,
 					struct ieee80211_rate *rate);
 
 /**
- * ieee80211_get_buffered_bc - accessing buffered broadcast and multicast frames
+ * ieee80211_get_buffered_bc_dup - accessing buffered broadcast and multicast frames
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4048,16 +4048,16 @@ __le16 ieee80211_generic_frame_duration(
  *
  * Note: buffered frames are returned only after DTIM beacon frame was
  * generated with ieee80211_beacon_get() and the low-level driver must thus
- * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc() returns
+ * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc_dup() returns
  * NULL if the previous generated beacon was not DTIM, so the low-level driver
  * does not need to check for DTIM beacons separately and should be able to
  * use common code for all beacons.
  */
 struct sk_buff *
-ieee80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+ieee80211_get_buffered_bc_dup(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
 
 /**
- * ieee80211_get_tkip_p1k_iv - get a TKIP phase 1 key for IV32
+ * ieee80211_get_tkip_p1k_iv_dup - get a TKIP phase 1 key for IV32
  *
  * This function returns the TKIP phase 1 key for the given IV32.
  *
@@ -4065,7 +4065,7 @@ ieee80211_get_buffered_bc(struct ieee802
  * @iv32: IV32 to get the P1K for
  * @p1k: a buffer to which the key will be written, as 5 u16 values
  */
-void ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_p1k_iv_dup(struct ieee80211_key_conf *keyconf,
 			       u32 iv32, u16 *p1k);
 
 /**
@@ -4083,14 +4083,14 @@ static inline void ieee80211_get_tkip_p1
 					  struct sk_buff *skb, u16 *p1k)
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	const u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);
+	const u8 *data = (u8 *)hdr + ieee80211_hdrlen_dup(hdr->frame_control);
 	u32 iv32 = get_unaligned_le32(&data[4]);
 
-	ieee80211_get_tkip_p1k_iv(keyconf, iv32, p1k);
+	ieee80211_get_tkip_p1k_iv_dup(keyconf, iv32, p1k);
 }
 
 /**
- * ieee80211_get_tkip_rx_p1k - get a TKIP phase 1 key for RX
+ * ieee80211_get_tkip_rx_p1k_dup - get a TKIP phase 1 key for RX
  *
  * This function returns the TKIP phase 1 key for the given IV32
  * and transmitter address.
@@ -4100,11 +4100,11 @@ static inline void ieee80211_get_tkip_p1
  * @iv32: IV32 to get the P1K for
  * @p1k: a buffer to which the key will be written, as 5 u16 values
  */
-void ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_rx_p1k_dup(struct ieee80211_key_conf *keyconf,
 			       const u8 *ta, u32 iv32, u16 *p1k);
 
 /**
- * ieee80211_get_tkip_p2k - get a TKIP phase 2 key
+ * ieee80211_get_tkip_p2k_dup - get a TKIP phase 2 key
  *
  * This function computes the TKIP RC4 key for the IV values
  * in the packet.
@@ -4114,11 +4114,11 @@ void ieee80211_get_tkip_rx_p1k(struct ie
  *	encrypted with this key
  * @p2k: a buffer to which the key will be written, 16 bytes
  */
-void ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_tkip_p2k_dup(struct ieee80211_key_conf *keyconf,
 			    struct sk_buff *skb, u8 *p2k);
 
 /**
- * ieee80211_aes_cmac_calculate_k1_k2 - calculate the AES-CMAC sub keys
+ * ieee80211_aes_cmac_calculate_k1_k2_dup - calculate the AES-CMAC sub keys
  *
  * This function computes the two AES-CMAC sub-keys, based on the
  * previously installed master key.
@@ -4127,7 +4127,7 @@ void ieee80211_get_tkip_p2k(struct ieee8
  * @k1: a buffer to be filled with the 1st sub-key
  * @k2: a buffer to be filled with the 2nd sub-key
  */
-void ieee80211_aes_cmac_calculate_k1_k2(struct ieee80211_key_conf *keyconf,
+void ieee80211_aes_cmac_calculate_k1_k2_dup(struct ieee80211_key_conf *keyconf,
 					u8 *k1, u8 *k2);
 
 /**
@@ -4155,7 +4155,7 @@ struct ieee80211_key_seq {
 };
 
 /**
- * ieee80211_get_key_tx_seq - get key TX sequence counter
+ * ieee80211_get_key_tx_seq_dup - get key TX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @seq: buffer to receive the sequence data
@@ -4168,11 +4168,11 @@ struct ieee80211_key_seq {
  * can be done concurrently, for example when queues are stopped
  * and the stop has been synchronized.
  */
-void ieee80211_get_key_tx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_key_tx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_get_key_rx_seq - get key RX sequence counter
+ * ieee80211_get_key_rx_seq_dup - get key RX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @tid: The TID, or -1 for the management frame value (CCMP only);
@@ -4187,11 +4187,11 @@ void ieee80211_get_key_tx_seq(struct iee
  * Note that this function may only be called when no RX processing
  * can be done concurrently.
  */
-void ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_get_key_rx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      int tid, struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_set_key_tx_seq - set key TX sequence counter
+ * ieee80211_set_key_tx_seq_dup - set key TX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @seq: new sequence data
@@ -4204,11 +4204,11 @@ void ieee80211_get_key_rx_seq(struct iee
  * Note that this function may only be called when no TX processing
  * can be done concurrently.
  */
-void ieee80211_set_key_tx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_set_key_tx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_set_key_rx_seq - set key RX sequence counter
+ * ieee80211_set_key_rx_seq_dup - set key RX sequence counter
  *
  * @keyconf: the parameter passed with the set key
  * @tid: The TID, or -1 for the management frame value (CCMP only);
@@ -4224,11 +4224,11 @@ void ieee80211_set_key_tx_seq(struct iee
  * Note that this function may only be called when no RX processing
  * can be done concurrently.
  */
-void ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,
+void ieee80211_set_key_rx_seq_dup(struct ieee80211_key_conf *keyconf,
 			      int tid, struct ieee80211_key_seq *seq);
 
 /**
- * ieee80211_remove_key - remove the given key
+ * ieee80211_remove_key_dup - remove the given key
  * @keyconf: the parameter passed with the set key
  *
  * Remove the given key. If the key was uploaded to the hardware at the
@@ -4236,12 +4236,12 @@ void ieee80211_set_key_rx_seq(struct iee
  * instead assumed to have been removed already.
  *
  * Note that due to locking considerations this function can (currently)
- * only be called during key iteration (ieee80211_iter_keys().)
+ * only be called during key iteration (ieee80211_iter_keys_dup().)
  */
-void ieee80211_remove_key(struct ieee80211_key_conf *keyconf);
+void ieee80211_remove_key_dup(struct ieee80211_key_conf *keyconf);
 
 /**
- * ieee80211_gtk_rekey_add - add a GTK key from rekeying during WoWLAN
+ * ieee80211_gtk_rekey_add_dup - add a GTK key from rekeying during WoWLAN
  * @vif: the virtual interface to add the key on
  * @keyconf: new key data
  *
@@ -4261,48 +4261,48 @@ void ieee80211_remove_key(struct ieee802
  * the return code 1 to reconfigure the device, this key will be part
  * of the reconfiguration.
  *
- * Note that the driver should also call ieee80211_set_key_rx_seq()
+ * Note that the driver should also call ieee80211_set_key_rx_seq_dup()
  * for the new key for each TID to set up sequence counters properly.
  *
  * IMPORTANT: If this replaces a key that is present in the hardware,
  * then it will attempt to remove it during this call. In many cases
- * this isn't what you want, so call ieee80211_remove_key() first for
+ * this isn't what you want, so call ieee80211_remove_key_dup() first for
  * the key that's being replaced.
  */
 struct ieee80211_key_conf *
-ieee80211_gtk_rekey_add(struct ieee80211_vif *vif,
+ieee80211_gtk_rekey_add_dup(struct ieee80211_vif *vif,
 			struct ieee80211_key_conf *keyconf);
 
 /**
- * ieee80211_gtk_rekey_notify - notify userspace supplicant of rekeying
+ * ieee80211_gtk_rekey_notify_dup - notify userspace supplicant of rekeying
  * @vif: virtual interface the rekeying was done on
  * @bssid: The BSSID of the AP, for checking association
  * @replay_ctr: the new replay counter after GTK rekeying
  * @gfp: allocation flags
  */
-void ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,
+void ieee80211_gtk_rekey_notify_dup(struct ieee80211_vif *vif, const u8 *bssid,
 				const u8 *replay_ctr, gfp_t gfp);
 
 /**
- * ieee80211_wake_queue - wake specific queue
+ * ieee80211_wake_queue_dup - wake specific queue
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @queue: queue number (counted from zero).
  *
  * Drivers should use this function instead of netif_wake_queue.
  */
-void ieee80211_wake_queue(struct ieee80211_hw *hw, int queue);
+void ieee80211_wake_queue_dup(struct ieee80211_hw *hw, int queue);
 
 /**
- * ieee80211_stop_queue - stop specific queue
+ * ieee80211_stop_queue_dup - stop specific queue
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @queue: queue number (counted from zero).
  *
  * Drivers should use this function instead of netif_stop_queue.
  */
-void ieee80211_stop_queue(struct ieee80211_hw *hw, int queue);
+void ieee80211_stop_queue_dup(struct ieee80211_hw *hw, int queue);
 
 /**
- * ieee80211_queue_stopped - test status of the queue
+ * ieee80211_queue_stopped_dup - test status of the queue
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  * @queue: queue number (counted from zero).
  *
@@ -4311,26 +4311,26 @@ void ieee80211_stop_queue(struct ieee802
  * Return: %true if the queue is stopped. %false otherwise.
  */
 
-int ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue);
+int ieee80211_queue_stopped_dup(struct ieee80211_hw *hw, int queue);
 
 /**
- * ieee80211_stop_queues - stop all queues
+ * ieee80211_stop_queues_dup - stop all queues
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  *
  * Drivers should use this function instead of netif_stop_queue.
  */
-void ieee80211_stop_queues(struct ieee80211_hw *hw);
+void ieee80211_stop_queues_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_wake_queues - wake all queues
+ * ieee80211_wake_queues_dup - wake all queues
  * @hw: pointer as obtained from ieee80211_alloc_hw().
  *
  * Drivers should use this function instead of netif_wake_queue.
  */
-void ieee80211_wake_queues(struct ieee80211_hw *hw);
+void ieee80211_wake_queues_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_scan_completed - completed hardware scan
+ * ieee80211_scan_completed_dup - completed hardware scan
  *
  * When hardware scan offload is used (i.e. the hw_scan() callback is
  * assigned) this function needs to be called by the driver to notify
@@ -4340,20 +4340,20 @@ void ieee80211_wake_queues(struct ieee80
  * @hw: the hardware that finished the scan
  * @aborted: set to true if scan was aborted
  */
-void ieee80211_scan_completed(struct ieee80211_hw *hw, bool aborted);
+void ieee80211_scan_completed_dup(struct ieee80211_hw *hw, bool aborted);
 
 /**
- * ieee80211_sched_scan_results - got results from scheduled scan
+ * ieee80211_sched_scan_results_dup - got results from scheduled scan
  *
  * When a scheduled scan is running, this function needs to be called by the
  * driver whenever there are new scan results available.
  *
  * @hw: the hardware that is performing scheduled scans
  */
-void ieee80211_sched_scan_results(struct ieee80211_hw *hw);
+void ieee80211_sched_scan_results_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_sched_scan_stopped - inform that the scheduled scan has stopped
+ * ieee80211_sched_scan_stopped_dup - inform that the scheduled scan has stopped
  *
  * When a scheduled scan is running, this function can be called by
  * the driver if it needs to stop the scan to perform another task.
@@ -4362,7 +4362,7 @@ void ieee80211_sched_scan_results(struct
  *
  * @hw: the hardware that is performing scheduled scans
  */
-void ieee80211_sched_scan_stopped(struct ieee80211_hw *hw);
+void ieee80211_sched_scan_stopped_dup(struct ieee80211_hw *hw);
 
 /**
  * enum ieee80211_interface_iteration_flags - interface iteration flags
@@ -4380,12 +4380,12 @@ enum ieee80211_interface_iteration_flags
 };
 
 /**
- * ieee80211_iterate_active_interfaces - iterate active interfaces
+ * ieee80211_iterate_active_interfaces_dup - iterate active interfaces
  *
  * This function iterates over the interfaces associated with a given
  * hardware that are currently active and calls the callback for them.
  * This function allows the iterator function to sleep, when the iterator
- * function is atomic @ieee80211_iterate_active_interfaces_atomic can
+ * function is atomic @ieee80211_iterate_active_interfaces_atomic_dup can
  * be used.
  * Does not iterate over a new interface during add_interface().
  *
@@ -4394,19 +4394,19 @@ enum ieee80211_interface_iteration_flags
  * @iterator: the iterator function to call
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_active_interfaces(struct ieee80211_hw *hw,
+void ieee80211_iterate_active_interfaces_dup(struct ieee80211_hw *hw,
 					 u32 iter_flags,
 					 void (*iterator)(void *data, u8 *mac,
 						struct ieee80211_vif *vif),
 					 void *data);
 
 /**
- * ieee80211_iterate_active_interfaces_atomic - iterate active interfaces
+ * ieee80211_iterate_active_interfaces_atomic_dup - iterate active interfaces
  *
  * This function iterates over the interfaces associated with a given
  * hardware that are currently active and calls the callback for them.
  * This function requires the iterator callback function to be atomic,
- * if that is not desired, use @ieee80211_iterate_active_interfaces instead.
+ * if that is not desired, use @ieee80211_iterate_active_interfaces_dup instead.
  * Does not iterate over a new interface during add_interface().
  *
  * @hw: the hardware struct of which the interfaces should be iterated over
@@ -4414,7 +4414,7 @@ void ieee80211_iterate_active_interfaces
  * @iterator: the iterator function to call, cannot sleep
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,
+void ieee80211_iterate_active_interfaces_atomic_dup(struct ieee80211_hw *hw,
 						u32 iter_flags,
 						void (*iterator)(void *data,
 						    u8 *mac,
@@ -4422,7 +4422,7 @@ void ieee80211_iterate_active_interfaces
 						void *data);
 
 /**
- * ieee80211_iterate_active_interfaces_rtnl - iterate active interfaces
+ * ieee80211_iterate_active_interfaces_rtnl_dup - iterate active interfaces
  *
  * This function iterates over the interfaces associated with a given
  * hardware that are currently active and calls the callback for them.
@@ -4433,7 +4433,7 @@ void ieee80211_iterate_active_interfaces
  * @iterator: the iterator function to call, cannot sleep
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_active_interfaces_rtnl(struct ieee80211_hw *hw,
+void ieee80211_iterate_active_interfaces_rtnl_dup(struct ieee80211_hw *hw,
 					      u32 iter_flags,
 					      void (*iterator)(void *data,
 						u8 *mac,
@@ -4441,7 +4441,7 @@ void ieee80211_iterate_active_interfaces
 					      void *data);
 
 /**
- * ieee80211_iterate_stations_atomic - iterate stations
+ * ieee80211_iterate_stations_atomic_dup - iterate stations
  *
  * This function iterates over all stations associated with a given
  * hardware that are currently uploaded to the driver and calls the callback
@@ -4452,12 +4452,12 @@ void ieee80211_iterate_active_interfaces
  * @iterator: the iterator function to call, cannot sleep
  * @data: first argument of the iterator function
  */
-void ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,
+void ieee80211_iterate_stations_atomic_dup(struct ieee80211_hw *hw,
 				       void (*iterator)(void *data,
 						struct ieee80211_sta *sta),
 				       void *data);
 /**
- * ieee80211_queue_work - add work onto the mac80211 workqueue
+ * ieee80211_queue_work_dup - add work onto the mac80211 workqueue
  *
  * Drivers and mac80211 use this to add work onto the mac80211 workqueue.
  * This helper ensures drivers are not queueing work when they should not be.
@@ -4465,10 +4465,10 @@ void ieee80211_iterate_stations_atomic(s
  * @hw: the hardware struct for the interface we are adding work for
  * @work: the work we want to add onto the mac80211 workqueue
  */
-void ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work);
+void ieee80211_queue_work_dup(struct ieee80211_hw *hw, struct work_struct *work);
 
 /**
- * ieee80211_queue_delayed_work - add work onto the mac80211 workqueue
+ * ieee80211_queue_delayed_work_dup - add work onto the mac80211 workqueue
  *
  * Drivers and mac80211 use this to queue delayed work onto the mac80211
  * workqueue.
@@ -4477,12 +4477,12 @@ void ieee80211_queue_work(struct ieee802
  * @dwork: delayable work to queue onto the mac80211 workqueue
  * @delay: number of jiffies to wait before queueing
  */
-void ieee80211_queue_delayed_work(struct ieee80211_hw *hw,
+void ieee80211_queue_delayed_work_dup(struct ieee80211_hw *hw,
 				  struct delayed_work *dwork,
 				  unsigned long delay);
 
 /**
- * ieee80211_start_tx_ba_session - Start a tx Block Ack session.
+ * ieee80211_start_tx_ba_session_dup - Start a tx Block Ack session.
  * @sta: the station for which to start a BA session
  * @tid: the TID to BA on.
  * @timeout: session timeout value (in TUs)
@@ -4493,11 +4493,11 @@ void ieee80211_queue_delayed_work(struct
  * the need to start aggregation on a certain RA/TID, the session level
  * will be managed by the mac80211.
  */
-int ieee80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid,
+int ieee80211_start_tx_ba_session_dup(struct ieee80211_sta *sta, u16 tid,
 				  u16 timeout);
 
 /**
- * ieee80211_start_tx_ba_cb_irqsafe - low level driver ready to aggregate.
+ * ieee80211_start_tx_ba_cb_irqsafe_dup - low level driver ready to aggregate.
  * @vif: &struct ieee80211_vif pointer from the add_interface callback
  * @ra: receiver address of the BA session recipient.
  * @tid: the TID to BA on.
@@ -4506,11 +4506,11 @@ int ieee80211_start_tx_ba_session(struct
  * finished with preparations for the BA session. It can be called
  * from any context.
  */
-void ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
+void ieee80211_start_tx_ba_cb_irqsafe_dup(struct ieee80211_vif *vif, const u8 *ra,
 				      u16 tid);
 
 /**
- * ieee80211_stop_tx_ba_session - Stop a Block Ack session.
+ * ieee80211_stop_tx_ba_session_dup - Stop a Block Ack session.
  * @sta: the station whose BA session to stop
  * @tid: the TID to stop BA.
  *
@@ -4520,10 +4520,10 @@ void ieee80211_start_tx_ba_cb_irqsafe(st
  * the need to stop aggregation on a certain RA/TID, the session level
  * will be managed by the mac80211.
  */
-int ieee80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid);
+int ieee80211_stop_tx_ba_session_dup(struct ieee80211_sta *sta, u16 tid);
 
 /**
- * ieee80211_stop_tx_ba_cb_irqsafe - low level driver ready to stop aggregate.
+ * ieee80211_stop_tx_ba_cb_irqsafe_dup - low level driver ready to stop aggregate.
  * @vif: &struct ieee80211_vif pointer from the add_interface callback
  * @ra: receiver address of the BA session recipient.
  * @tid: the desired TID to BA on.
@@ -4532,11 +4532,11 @@ int ieee80211_stop_tx_ba_session(struct
  * finished with preparations for the BA session tear down. It
  * can be called from any context.
  */
-void ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,
+void ieee80211_stop_tx_ba_cb_irqsafe_dup(struct ieee80211_vif *vif, const u8 *ra,
 				     u16 tid);
 
 /**
- * ieee80211_find_sta - find a station
+ * ieee80211_find_sta_dup - find a station
  *
  * @vif: virtual interface to look for station on
  * @addr: station's address
@@ -4546,11 +4546,11 @@ void ieee80211_stop_tx_ba_cb_irqsafe(str
  * Note: This function must be called under RCU lock and the
  * resulting pointer is only valid under RCU lock as well.
  */
-struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,
+struct ieee80211_sta *ieee80211_find_sta_dup(struct ieee80211_vif *vif,
 					 const u8 *addr);
 
 /**
- * ieee80211_find_sta_by_ifaddr - find a station on hardware
+ * ieee80211_find_sta_by_ifaddr_dup - find a station on hardware
  *
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  * @addr: remote station's address
@@ -4571,12 +4571,12 @@ struct ieee80211_sta *ieee80211_find_sta
  *
  * DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.
  */
-struct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,
+struct ieee80211_sta *ieee80211_find_sta_by_ifaddr_dup(struct ieee80211_hw *hw,
 					       const u8 *addr,
 					       const u8 *localaddr);
 
 /**
- * ieee80211_sta_block_awake - block station from waking up
+ * ieee80211_sta_block_awake_dup - block station from waking up
  * @hw: the hardware
  * @pubsta: the station
  * @block: whether to block or unblock
@@ -4604,16 +4604,16 @@ struct ieee80211_sta *ieee80211_find_sta
  * it is unblocked, regardless of whether the station actually
  * woke up while blocked or not.
  */
-void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
+void ieee80211_sta_block_awake_dup(struct ieee80211_hw *hw,
 			       struct ieee80211_sta *pubsta, bool block);
 
 /**
- * ieee80211_sta_eosp - notify mac80211 about end of SP
+ * ieee80211_sta_eosp_dup - notify mac80211 about end of SP
  * @pubsta: the station
  *
  * When a device transmits frames in a way that it can't tell
  * mac80211 in the TX status about the EOSP, it must clear the
- * %IEEE80211_TX_STATUS_EOSP bit and call this function instead.
+ * %ieee80211_tx_status_EOSP bit and call this function instead.
  * This applies for PS-Poll as well as uAPSD.
  *
  * Note that just like with _tx_status() and _rx() drivers must
@@ -4626,10 +4626,10 @@ void ieee80211_sta_block_awake(struct ie
  *     you'd need the _irqsafe version, look at the git history
  *     and restore the _irqsafe version!
  */
-void ieee80211_sta_eosp(struct ieee80211_sta *pubsta);
+void ieee80211_sta_eosp_dup(struct ieee80211_sta *pubsta);
 
 /**
- * ieee80211_iter_keys - iterate keys programmed into the device
+ * ieee80211_iter_keys_dup - iterate keys programmed into the device
  * @hw: pointer obtained from ieee80211_alloc_hw()
  * @vif: virtual interface to iterate, may be %NULL for all
  * @iter: iterator function that will be called for each key
@@ -4646,7 +4646,7 @@ void ieee80211_sta_eosp(struct ieee80211
  * in which they were originally installed and handed to the
  * set_key callback.
  */
-void ieee80211_iter_keys(struct ieee80211_hw *hw,
+void ieee80211_iter_keys_dup(struct ieee80211_hw *hw,
 			 struct ieee80211_vif *vif,
 			 void (*iter)(struct ieee80211_hw *hw,
 				      struct ieee80211_vif *vif,
@@ -4656,7 +4656,7 @@ void ieee80211_iter_keys(struct ieee8021
 			 void *iter_data);
 
 /**
- * ieee80211_iter_chan_contexts_atomic - iterate channel contexts
+ * ieee80211_iter_chan_contexts_atomic_dup - iterate channel contexts
  * @hw: pointre obtained from ieee80211_alloc_hw().
  * @iter: iterator function
  * @iter_data: data passed to iterator function
@@ -4674,7 +4674,7 @@ void ieee80211_iter_keys(struct ieee8021
  * found while iterating, whether they've been re-added already
  * or not.
  */
-void ieee80211_iter_chan_contexts_atomic(
+void ieee80211_iter_chan_contexts_atomic_dup(
 	struct ieee80211_hw *hw,
 	void (*iter)(struct ieee80211_hw *hw,
 		     struct ieee80211_chanctx_conf *chanctx_conf,
@@ -4682,7 +4682,7 @@ void ieee80211_iter_chan_contexts_atomic
 	void *iter_data);
 
 /**
- * ieee80211_ap_probereq_get - retrieve a Probe Request template
+ * ieee80211_ap_probereq_get_dup - retrieve a Probe Request template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4695,11 +4695,11 @@ void ieee80211_iter_chan_contexts_atomic
  *
  * Return: The Probe Request template. %NULL on error.
  */
-struct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,
+struct sk_buff *ieee80211_ap_probereq_get_dup(struct ieee80211_hw *hw,
 					  struct ieee80211_vif *vif);
 
 /**
- * ieee80211_beacon_loss - inform hardware does not receive beacons
+ * ieee80211_beacon_loss_dup - inform hardware does not receive beacons
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4707,10 +4707,10 @@ struct sk_buff *ieee80211_ap_probereq_ge
  * %IEEE80211_CONF_PS is set, the driver needs to inform whenever the
  * hardware is not receiving beacons with this function.
  */
-void ieee80211_beacon_loss(struct ieee80211_vif *vif);
+void ieee80211_beacon_loss_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_connection_loss - inform hardware has lost connection to the AP
+ * ieee80211_connection_loss_dup - inform hardware has lost connection to the AP
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4723,10 +4723,10 @@ void ieee80211_beacon_loss(struct ieee80
  * This function will cause immediate change to disassociated state,
  * without connection recovery attempts.
  */
-void ieee80211_connection_loss(struct ieee80211_vif *vif);
+void ieee80211_connection_loss_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_resume_disconnect - disconnect from AP after resume
+ * ieee80211_resume_disconnect_dup - disconnect from AP after resume
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  *
@@ -4746,10 +4746,10 @@ void ieee80211_connection_loss(struct ie
  * calls this function, or at least not any locks it needs in the
  * key configuration paths (if it supports HW crypto).
  */
-void ieee80211_resume_disconnect(struct ieee80211_vif *vif);
+void ieee80211_resume_disconnect_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_cqm_rssi_notify - inform a configured connection quality monitoring
+ * ieee80211_cqm_rssi_notify_dup - inform a configured connection quality monitoring
  *	rssi threshold triggered
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
@@ -4760,37 +4760,37 @@ void ieee80211_resume_disconnect(struct
  * monitoring is configured with an rssi threshold, the driver will inform
  * whenever the rssi level reaches the threshold.
  */
-void ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,
+void ieee80211_cqm_rssi_notify_dup(struct ieee80211_vif *vif,
 			       enum nl80211_cqm_rssi_threshold_event rssi_event,
 			       gfp_t gfp);
 
 /**
- * ieee80211_cqm_beacon_loss_notify - inform CQM of beacon loss
+ * ieee80211_cqm_beacon_loss_notify_dup - inform CQM of beacon loss
  *
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @gfp: context flags
  */
-void ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp);
+void ieee80211_cqm_beacon_loss_notify_dup(struct ieee80211_vif *vif, gfp_t gfp);
 
 /**
- * ieee80211_radar_detected - inform that a radar was detected
+ * ieee80211_radar_detected_dup - inform that a radar was detected
  *
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  */
-void ieee80211_radar_detected(struct ieee80211_hw *hw);
+void ieee80211_radar_detected_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_chswitch_done - Complete channel switch process
+ * ieee80211_chswitch_done_dup - Complete channel switch process
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @success: make the channel switch successful or not
  *
  * Complete the channel switch post-process: set the new operational channel
  * and wake up the suspended queues.
  */
-void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success);
+void ieee80211_chswitch_done_dup(struct ieee80211_vif *vif, bool success);
 
 /**
- * ieee80211_request_smps - request SM PS transition
+ * ieee80211_request_smps_dup - request SM PS transition
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @smps_mode: new SM PS mode
  *
@@ -4798,23 +4798,23 @@ void ieee80211_chswitch_done(struct ieee
  * mode. This is useful when the driver has more information than
  * the stack about possible interference, for example by bluetooth.
  */
-void ieee80211_request_smps(struct ieee80211_vif *vif,
+void ieee80211_request_smps_dup(struct ieee80211_vif *vif,
 			    enum ieee80211_smps_mode smps_mode);
 
 /**
- * ieee80211_ready_on_channel - notification of remain-on-channel start
+ * ieee80211_ready_on_channel_dup - notification of remain-on-channel start
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  */
-void ieee80211_ready_on_channel(struct ieee80211_hw *hw);
+void ieee80211_ready_on_channel_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_remain_on_channel_expired - remain_on_channel duration expired
+ * ieee80211_remain_on_channel_expired_dup - remain_on_channel duration expired
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  */
-void ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw);
+void ieee80211_remain_on_channel_expired_dup(struct ieee80211_hw *hw);
 
 /**
- * ieee80211_stop_rx_ba_session - callback to stop existing BA sessions
+ * ieee80211_stop_rx_ba_session_dup - callback to stop existing BA sessions
  *
  * in order not to harm the system performance and user experience, the device
  * may request not to allow any rx ba session and tear down existing rx ba
@@ -4827,11 +4827,11 @@ void ieee80211_remain_on_channel_expired
  * @ba_rx_bitmap: Bit map of open rx ba per tid
  * @addr: & to bssid mac address
  */
-void ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
+void ieee80211_stop_rx_ba_session_dup(struct ieee80211_vif *vif, u16 ba_rx_bitmap,
 				  const u8 *addr);
 
 /**
- * ieee80211_send_bar - send a BlockAckReq frame
+ * ieee80211_send_bar_dup - send a BlockAckReq frame
  *
  * can be used to flush pending frames from the peer's aggregation reorder
  * buffer.
@@ -4841,10 +4841,10 @@ void ieee80211_stop_rx_ba_session(struct
  * @tid: the TID of the aggregation session
  * @ssn: the new starting sequence number for the receiver
  */
-void ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);
+void ieee80211_send_bar_dup(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);
 
 /**
- * ieee80211_start_rx_ba_session_offl - start a Rx BA session
+ * ieee80211_start_rx_ba_session_offl_dup - start a Rx BA session
  *
  * Some device drivers may offload part of the Rx aggregation flow including
  * AddBa/DelBa negotiation but may otherwise be incapable of full Rx
@@ -4857,11 +4857,11 @@ void ieee80211_send_bar(struct ieee80211
  * @addr: station mac address
  * @tid: the rx tid
  */
-void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,
+void ieee80211_start_rx_ba_session_offl_dup(struct ieee80211_vif *vif,
 					const u8 *addr, u16 tid);
 
 /**
- * ieee80211_stop_rx_ba_session_offl - stop a Rx BA session
+ * ieee80211_stop_rx_ba_session_offl_dup - stop a Rx BA session
  *
  * Some device drivers may offload part of the Rx aggregation flow including
  * AddBa/DelBa negotiation but may otherwise be incapable of full Rx
@@ -4874,7 +4874,7 @@ void ieee80211_start_rx_ba_session_offl(
  * @addr: station mac address
  * @tid: the rx tid
  */
-void ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif,
+void ieee80211_stop_rx_ba_session_offl_dup(struct ieee80211_vif *vif,
 				       const u8 *addr, u16 tid);
 
 /* Rate control API */
@@ -4955,7 +4955,7 @@ static inline int rate_supported(struct
 }
 
 /**
- * rate_control_send_low - helper for drivers for management/no-ack frames
+ * rate_control_send_low_dup - helper for drivers for management/no-ack frames
  *
  * Rate control algorithms that agree to use the lowest rate to
  * send management frames and NO_ACK data with the respective hw
@@ -4972,7 +4972,7 @@ static inline int rate_supported(struct
  * @priv_sta: private rate control structure. This may be null.
  * @txrc: rate control information we sholud populate for mac80211.
  */
-bool rate_control_send_low(struct ieee80211_sta *sta,
+bool rate_control_send_low_dup(struct ieee80211_sta *sta,
 			   void *priv_sta,
 			   struct ieee80211_tx_rate_control *txrc);
 
@@ -5007,7 +5007,7 @@ bool rate_usable_index_exists(struct iee
 }
 
 /**
- * rate_control_set_rates - pass the sta rate selection to mac80211/driver
+ * rate_control_set_rates_dup - pass the sta rate selection to mac80211/driver
  *
  * When not doing a rate control probe to test rates, rate control should pass
  * its rate selection to mac80211. If the driver supports receiving a station
@@ -5018,12 +5018,12 @@ bool rate_usable_index_exists(struct iee
  * @pubsta: &struct ieee80211_sta pointer to the target destination.
  * @rates: new tx rate set to be used for this station.
  */
-int rate_control_set_rates(struct ieee80211_hw *hw,
+int rate_control_set_rates_dup(struct ieee80211_hw *hw,
 			   struct ieee80211_sta *pubsta,
 			   struct ieee80211_sta_rates *rates);
 
-int ieee80211_rate_control_register(const struct rate_control_ops *ops);
-void ieee80211_rate_control_unregister(const struct rate_control_ops *ops);
+int ieee80211_rate_control_register_dup(const struct rate_control_ops *ops);
+void ieee80211_rate_control_unregister_dup(const struct rate_control_ops *ops);
 
 static inline bool
 conf_is_ht20(struct ieee80211_conf *conf)
@@ -5081,14 +5081,14 @@ ieee80211_vif_type_p2p(struct ieee80211_
 	return ieee80211_iftype_p2p(vif->type, vif->p2p);
 }
 
-void ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,
+void ieee80211_enable_rssi_reports_dup(struct ieee80211_vif *vif,
 				   int rssi_min_thold,
 				   int rssi_max_thold);
 
-void ieee80211_disable_rssi_reports(struct ieee80211_vif *vif);
+void ieee80211_disable_rssi_reports_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_ave_rssi - report the average RSSI for the specified interface
+ * ieee80211_ave_rssi_dup - report the average RSSI for the specified interface
  *
  * @vif: the specified virtual interface
  *
@@ -5097,22 +5097,22 @@ void ieee80211_disable_rssi_reports(stru
  * Return: The average RSSI value for the requested interface, or 0 if not
  * applicable.
  */
-int ieee80211_ave_rssi(struct ieee80211_vif *vif);
+int ieee80211_ave_rssi_dup(struct ieee80211_vif *vif);
 
 /**
- * ieee80211_report_wowlan_wakeup - report WoWLAN wakeup
+ * ieee80211_report_wowlan_wakeup_dup - report WoWLAN wakeup
  * @vif: virtual interface
  * @wakeup: wakeup reason(s)
  * @gfp: allocation flags
  *
- * See cfg80211_report_wowlan_wakeup().
+ * See cfg80211_report_wowlan_wakeup_dup().
  */
-void ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,
+void ieee80211_report_wowlan_wakeup_dup(struct ieee80211_vif *vif,
 				    struct cfg80211_wowlan_wakeup *wakeup,
 				    gfp_t gfp);
 
 /**
- * ieee80211_tx_prepare_skb - prepare an 802.11 skb for transmission
+ * ieee80211_tx_prepare_skb_dup - prepare an 802.11 skb for transmission
  * @hw: pointer as obtained from ieee80211_alloc_hw()
  * @vif: virtual interface
  * @skb: frame to be sent from within the driver
@@ -5121,7 +5121,7 @@ void ieee80211_report_wowlan_wakeup(stru
  *
  * Note: must be called under RCU lock
  */
-bool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,
+bool ieee80211_tx_prepare_skb_dup(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif, struct sk_buff *skb,
 			      int band, struct ieee80211_sta **sta);
 
@@ -5153,7 +5153,7 @@ struct ieee80211_noa_data {
 };
 
 /**
- * ieee80211_parse_p2p_noa - initialize NoA tracking data from P2P IE
+ * ieee80211_parse_p2p_noa_dup - initialize NoA tracking data from P2P IE
  *
  * @attr: P2P NoA IE
  * @data: NoA tracking data
@@ -5161,16 +5161,16 @@ struct ieee80211_noa_data {
  *
  * Return: number of successfully parsed descriptors
  */
-int ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,
+int ieee80211_parse_p2p_noa_dup(const struct ieee80211_p2p_noa_attr *attr,
 			    struct ieee80211_noa_data *data, u32 tsf);
 
 /**
- * ieee80211_update_p2p_noa - get next pending P2P GO absent state change
+ * ieee80211_update_p2p_noa_dup - get next pending P2P GO absent state change
  *
  * @data: NoA tracking data
  * @tsf: current TSF timestamp
  */
-void ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf);
+void ieee80211_update_p2p_noa_dup(struct ieee80211_noa_data *data, u32 tsf);
 
 /**
  * ieee80211_tdls_oper - request userspace to perform a TDLS operation
@@ -5180,14 +5180,14 @@ void ieee80211_update_p2p_noa_dup(struct
  * @reason_code: reason code for the operation, valid for TDLS teardown
  * @gfp: allocation flags
  *
- * See cfg80211_tdls_oper_request().
+ * See cfg80211_tdls_oper_request_dup().
  */
-void ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,
+void ieee80211_tdls_oper_request_dup(struct ieee80211_vif *vif, const u8 *peer,
 				 enum nl80211_tdls_operation oper,
 				 u16 reason_code, gfp_t gfp);
 
 /**
- * ieee80211_reserve_tid - request to reserve a specific TID
+ * ieee80211_reserve_tid_dup - request to reserve a specific TID
  *
  * There is sometimes a need (such as in TDLS) for blocking the driver from
  * using a specific TID so that the FW can use it for certain operations such
@@ -5205,10 +5205,10 @@ void ieee80211_tdls_oper_request(struct
  *
  * Returns: 0 on success, else on failure
  */
-int ieee80211_reserve_tid(struct ieee80211_sta *sta, u8 tid);
+int ieee80211_reserve_tid_dup(struct ieee80211_sta *sta, u8 tid);
 
 /**
- * ieee80211_unreserve_tid - request to unreserve a specific TID
+ * ieee80211_unreserve_tid_dup - request to unreserve a specific TID
  *
  * Once there is no longer any need for reserving a certain TID, this function
  * should be called, and no longer will packets have their TID modified for
@@ -5221,10 +5221,10 @@ int ieee80211_reserve_tid(struct ieee802
  * @sta: the station
  * @tid: the TID to unreserve
  */
-void ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid);
+void ieee80211_unreserve_tid_dup(struct ieee80211_sta *sta, u8 tid);
 
 /**
- * ieee80211_ie_split - split an IE buffer according to ordering
+ * ieee80211_ie_split_dup - split an IE buffer according to ordering
  *
  * @ies: the IE buffer
  * @ielen: the length of the IE buffer
@@ -5248,6 +5248,6 @@ void ieee80211_unreserve_tid(struct ieee
  * buffer starts, which may be @ielen if the entire (remainder)
  * of the buffer should be used.
  */
-size_t ieee80211_ie_split(const u8 *ies, size_t ielen,
+size_t ieee80211_ie_split_dup(const u8 *ies, size_t ielen,
 			  const u8 *ids, int n_ids, size_t offset);
 #endif /* MAC80211_H */
--- a/include/net/regulatory.h	2015-06-23 11:07:42.675848940 +0200
+++ b/include/net/regulatory.h	2015-06-23 16:42:02.064819187 +0200
@@ -94,10 +94,10 @@ struct regulatory_request {
  *	ISO / IEC 3166 alpha2 it belongs to. When this is enabled
  *	we will disregard the first regulatory hint (when the
  *	initiator is %REGDOM_SET_BY_CORE). Drivers that use
- *	wiphy_apply_custom_regulatory() should have this flag set
+ *	wiphy_apply_custom_regulatory_dup() should have this flag set
  *	or the regulatory core will set it for the wiphy.
- *	If you use regulatory_hint() *after* using
- *	wiphy_apply_custom_regulatory() the wireless core will
+ *	If you use regulatory_hint_dup() *after* using
+ *	wiphy_apply_custom_regulatory_dup() the wireless core will
  *	clear the REGULATORY_CUSTOM_REG for your wiphy as it would be
  *	implied that the device somehow gained knowledge of its region.
  * @REGULATORY_STRICT_REG: tells us that the wiphy for this device
@@ -111,8 +111,8 @@ struct regulatory_request {
  *	has these channels enabled would enable them for this wiphy,
  *	the device's original regulatory domain will be trusted as the
  *	base. You can program the superset of regulatory rules for this
- *	wiphy with regulatory_hint() for cards programmed with an
- *	ISO3166-alpha2 country code. wiphys that use regulatory_hint()
+ *	wiphy with regulatory_hint_dup() for cards programmed with an
+ *	ISO3166-alpha2 country code. wiphys that use regulatory_hint_dup()
  *	will have their wiphy->regd programmed once the regulatory
  *	domain is set, and all other regulatory hints will be ignored
  *	until their own regulatory domain gets programmed.
--- a/include/net/cfg80211.h	2015-07-21 19:24:11.754130831 +0200
+++ b/include/net/cfg80211.h	2015-07-21 19:24:26.480130471 +0200
@@ -3130,7 +3130,7 @@ struct wiphy {
 
 	u16 max_acl_mac_addrs;
 
-	u32 flags, regulatory_flags, features;
+	u32 flags, features;
 
 	u32 ap_sme_capa;
 
@@ -3156,8 +3156,10 @@ struct wiphy {
 	u32 hw_version;
 
 #ifdef CONFIG_PM
+	union {
+	struct wiphy_wowlan_support wowlan_dummy;
 	const struct wiphy_wowlan_support *wowlan;
-	struct cfg80211_wowlan *wowlan_config;
+	};
 #endif
 
 	u16 max_remain_on_channel_duration;
@@ -3227,6 +3229,11 @@ struct wiphy {
 	u8 max_num_csa_counters;
 	u8 max_adj_channel_rssi_comp;
 
+#ifdef CONFIG_PM
+	struct cfg80211_wowlan *wowlan_config;
+#endif
+	u32 regulatory_flags;
+
 	char priv[0] __aligned(NETDEV_ALIGN);
 };
 
@@ -3437,6 +3444,8 @@ struct wireless_dev {
 
 	struct mutex mtx;
 
+	struct work_struct cleanup_work;
+
 	bool use_4addr, p2p_started;
 
 	u8 address[ETH_ALEN] __aligned(sizeof(u16));
@@ -3444,6 +3453,12 @@ struct wireless_dev {
 	/* currently used for IBSS and SME - might be rearranged later */
 	u8 ssid[IEEE80211_MAX_SSID_LEN];
 	u8 ssid_len, mesh_id_len, mesh_id_up_len;
+       enum {
+               CFG80211_SME_IDLE,
+               CFG80211_SME_CONNECTING,
+               CFG80211_SME_CONNECTED,
+       } sme_state;
+
 	struct cfg80211_conn *conn;
 	struct cfg80211_cached_keys *connect_keys;
 
@@ -3452,10 +3467,9 @@ struct wireless_dev {
 
 	struct cfg80211_internal_bss *current_bss; /* associated / joined */
 	struct cfg80211_chan_def preset_chandef;
-	struct cfg80211_chan_def chandef;
+	struct ieee80211_channel *channel;
 
 	bool ibss_fixed;
-	bool ibss_dfs_possible;
 
 	bool ps;
 	int ps_timeout;
@@ -3466,9 +3480,6 @@ struct wireless_dev {
 
 	bool cac_started;
 	unsigned long cac_start_time;
-	unsigned int cac_time_ms;
-
-	u32 owner_nlportid;
 
 #ifdef CONFIG_CFG80211_WEXT
 	/* wext data */
@@ -3484,6 +3495,12 @@ struct wireless_dev {
 		bool prev_bssid_valid;
 	} wext;
 #endif
+
+	bool ibss_dfs_possible;
+	struct cfg80211_chan_def chandef;
+	unsigned int cac_time_ms;
+	u32 owner_nlportid;
+
 };
 
 static inline u8 *wdev_address(struct wireless_dev *wdev)

